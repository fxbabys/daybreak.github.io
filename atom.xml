<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeremy&#39;s blog</title>
  
  <subtitle>Share the technology and life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jeremygo.cn/"/>
  <updated>2018-09-28T04:40:09.955Z</updated>
  <id>https://jeremygo.cn/</id>
  
  <author>
    <name>Day Break</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零实现一个Promise</title>
    <link href="https://jeremygo.cn/2018/09/28/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise/"/>
    <id>https://jeremygo.cn/2018/09/28/从零实现一个Promise/</id>
    <published>2018-09-28T01:01:38.000Z</published>
    <updated>2018-09-28T04:40:09.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从暑假开始开发Vue项目，其中使用最频繁的库就是官方推荐的<a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a>，基于Promise的HTTP库，这里参考了几篇优秀的解读文章尝试实现自己的Promise~</p><p>Promise 是 ES6 新增的语法，解决了回调地狱的问题</p></blockquote><p>本文将根据 <a href="https://promisesaplus.com" target="_blank" rel="noopener">Promise A+ 规范</a> 解读并从零实现一个Promise，通过 <a href="https://github.com/promises-aplus/promises-tests#promisesa-compliance-test-suite" target="_blank" rel="noopener">promises-aplus/promises-tests</a> 所有测试</p><h3 id="Promise-标准解读"><a href="#Promise-标准解读" class="headerlink" title="Promise 标准解读"></a>Promise 标准解读</h3><p>Promise 表示一个异步操作的最终结果，主要通过 <code>then</code> 方法与之进行交互，该方法注册了两个回调函数，用来接收 Promise resolve 的终值或者 Promise reject 被拒绝的原因</p><h4 id="Promises-States"><a href="#Promises-States" class="headerlink" title="Promises States"></a>Promises States</h4><p>一个 Promise 必须是以下三个状态之一: </p><ul><li>pending</li><li>fulfilled (resolved)</li><li>rejected</li></ul><p>初始状态为 pending, 一旦转为 fulfilled 或 rejected, 就不能再次转为其它状态, 状态确定的过程叫做 settle</p><h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a><code>then</code> 方法</h4><ul><li>一个 Promise 必须提供一个 <code>then</code>方法，并且接收两个参数，返回的也是一个Promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><h4 id="The-Promise-Resolution-Procedure"><a href="#The-Promise-Resolution-Procedure" class="headerlink" title="The Promise Resolution Procedure"></a>The Promise Resolution Procedure</h4><p>不同实现的 Promise 之间可以无缝地相互调用, 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// MyPromise 表示自己实现的Promise库</span></span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">2</span>)　　　　　<span class="comment">// ES6 Promise</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h3><h4 id="基本构造函数"><a href="#基本构造函数" class="headerlink" title="基本构造函数"></a>基本构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  _this.currentState = PENDING <span class="comment">// Promise当前状态</span></span><br><span class="line">  _this.value = <span class="literal">undefined</span>      <span class="comment">// Promise的值</span></span><br><span class="line"></span><br><span class="line">  _this.resolvedCallbacks = [] <span class="comment">// 用于状态为 pending 时保存 then　中的回调</span></span><br><span class="line">  _this.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123; <span class="comment">// 若 value 是一个 Promise　则递归执行</span></span><br><span class="line">      <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 标准3.1: 异步执行</span></span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = RESOLVED</span><br><span class="line">        _this.value = value</span><br><span class="line">        _this.resolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = REJECTED</span><br><span class="line">        _this.value = reason</span><br><span class="line">        _this.rejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;  <span class="comment">// 考虑到执行fn时可能出错, 所以这里try/catch一下, 并将catch到的值reject回去</span></span><br><span class="line">    fn(_this.resolve, _this.reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    _this.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="then-方法-1"><a href="#then-方法-1" class="headerlink" title="then 方法"></a><code>then</code> 方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 规范 2.2.7: then 必须返回一个新的Promise</span></span><br><span class="line">  <span class="keyword">let</span> promise2</span><br><span class="line">  <span class="comment">// 规范 2.2: onResolved 和 onRejected 为可选参数 如果类型不是函数需要忽略并且实现了透传</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="params">v</span> =&gt;</span> v</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> &#123; <span class="keyword">throw</span> r &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === RESOLVED) &#123;</span><br><span class="line">    <span class="comment">// promise1(this/self)的状态已经确定并且为resolved, 调用onResolved</span></span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 规范 2.2.4: 保证 onFulfilled onRjected 异步执行</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onResolved(self.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(self.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === PENDING) &#123;</span><br><span class="line">    <span class="comment">// 当前Promise还处于pending状态不能确定调用onResolved还是onRejected</span></span><br><span class="line">    <span class="comment">// 所以需要将 两种情况的判断处理逻辑 作为callback 放入当前Promise对象的回调数组里</span></span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.resolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onResolved(self.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.rejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(self.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同Promise间的交互"><a href="#不同Promise间的交互" class="headerlink" title="不同Promise间的交互"></a>不同Promise间的交互</h4><p><code>then</code> 方法返回 <code>x</code> 可能是一个Promise对象(thenable)，为了确保调用成功，需要实现标准2.3的内容，这样即使实现方式不同，但遵循同样的标准不同的Promise之间也可以无缝地相互调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规范2.3: 针对不同的Promise实现交互</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span> (<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 规范2.3.1: x与promise2不能相同, 避免循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaing cycle detected for promise'</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 规范2.3.2: x是一个Promise 状态为pending则需要继续等待 否则执行</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">      x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">      &#125;, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.3.3.3: resolve或reject其中一个执行过则忽略其它的</span></span><br><span class="line">  <span class="keyword">let</span> thenCalledOrThrow = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123; <span class="comment">// 规范2.3.3</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.1: x.then可能是getter（函数）, 如果是函数就执行</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.3</span></span><br><span class="line">        then.call(</span><br><span class="line">          x, </span><br><span class="line">          y =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>  <span class="comment">// 2.3.3.3.3 三处谁执行就以谁的为准</span></span><br><span class="line">            thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">            resolutionProcedure(promise2, y, resolve, reject)  <span class="comment">// 2.3.3.3.1</span></span><br><span class="line">          &#125;,</span><br><span class="line">          r =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>  <span class="comment">// 2.3.3.3.3 三处谁执行就以谁的为准</span></span><br><span class="line">            thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">            reject(r)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span></span><br><span class="line">      thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.3.4</span></span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在上述完整代码最后加入测试的脚本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dfd = &#123;&#125;</span><br><span class="line">  dfd.promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    dfd.resolve = resolve</span><br><span class="line">    dfd.reject = reject</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = MyPromise</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后安装 <code>promises-aplus-tests</code>  执行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g promises-aplus-tests</span><br><span class="line">promises-aplus-tests Promise.js</span><br></pre></td></tr></table></figure><p>Success !</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1fvp1uj1rk3j20kt09cjsa.jpg" alt=""></p><p>参考链接：</p><p><a href="https://yuchengkai.cn/docs/zh/frontend/#promise-%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">面试图谱: Promise实现</a></p><p><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="noopener">剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;从暑假开始开发Vue项目，其中使用最频繁的库就是官方推荐的&lt;a href=&quot;https://github.com/axios/axios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;axios&lt;/a&gt;，基于Promise的HTT
      
    
    </summary>
    
    
      <category term="Wheels" scheme="https://jeremygo.cn/tags/Wheels/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(9.23)</title>
    <link href="https://jeremygo.cn/2018/09/23/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-9-23/"/>
    <id>https://jeremygo.cn/2018/09/23/每周精进-9-23/</id>
    <published>2018-09-23T00:31:04.000Z</published>
    <updated>2018-09-24T16:28:10.079Z</updated>
    
    <content type="html"><![CDATA[<p>从暑假结束到现在近一个月, 大部分的时间都在忙课程和组织迎新, 整体的学习感觉并不好, 博客和github都一直在闲置,  趁着放假的机会好好整理一下思绪, 还是希望能利用好最后一个学期上课的时间多做明年春招的准备,争取进入大厂去见识更广阔的世界~</p><p>因此决定坚持开始一个每周有所精进的阶段, 每周日定好下一周的小目标, 下一周最先开始说明目标完成情况,以此督促自己~</p><p>9.30日前完成: </p><ul><li>学习实现Promise发布到轮子项目上, 尽量能作博客说明</li><li>基于umi重构react-hackernews</li><li>精听六级听力一篇. 完成六级作文一篇</li></ul><p>近期书单:  Node.js: 来一打C++扩展</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从暑假结束到现在近一个月, 大部分的时间都在忙课程和组织迎新, 整体的学习感觉并不好, 博客和github都一直在闲置,  趁着放假的机会好好整理一下思绪, 还是希望能利用好最后一个学期上课的时间多做明年春招的准备,争取进入大厂去见识更广阔的世界~&lt;/p&gt;
&lt;p&gt;因此决定坚
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>移动端页面开发总结</title>
    <link href="https://jeremygo.cn/2018/08/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>https://jeremygo.cn/2018/08/04/移动端页面开发总结/</id>
    <published>2018-08-04T15:35:28.000Z</published>
    <updated>2018-08-04T16:46:06.869Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工作室暑期集训在带17级成员做官网，这里主要总结一些移动端页面开发的基本知识~</p></blockquote><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><ul><li>概念：一个像素就是计算机屏幕所能显示一种特定颜色的最小区域</li><li>web前端开发中：<ul><li>设备像素：设备屏幕的物理像素，对任何设备来说物理像素的数量是固定的</li><li>CSS像素：抽象的像素概念，专为web开发者创造<ul><li>比如：给一个元素设置 <code>width: 200px</code> 即这个元素的宽度跨越了200个CSS像素</li><li>跨越的设备像素：取决于<strong>手机屏幕</strong>和<strong>用户的缩放</strong><ul><li>iPhone的像素密度是普通屏幕的2倍此时<code>200px</code> 跨越了400个设备像素</li><li>用户缩小页面到一定程度时，一个CSS像素会明显小于一个设备像素，用户缩放页面就是在缩放CSS像素，设备像素大小数量都是固定的</li></ul></li></ul></li></ul></li></ul><h3 id="移动端的视口"><a href="#移动端的视口" class="headerlink" title="移动端的视口"></a>移动端的视口</h3><ul><li><p>视口是html的父元素，也称为初始包含块，即<strong>html元素的百分比是基于视口的</strong></p></li><li><p>布局视口：移动端CSS布局的依据视口</p><ul><li><p>PC浏览器中，视口的宽度 = 浏览器窗口的宽度</p></li><li><p>移动端中CSS布局会依据布局视口来计算</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1fty3uhhse3j208c0anq4l.jpg" alt=""></p></li><li><p>获取布局视口的宽高：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight</span><br></pre></td></tr></table></figure></li></ul></li><li><p>视觉视口：用户所看见的网站区域</p></li><li><p>理想视口：理想的布局视口：</p><ul><li><p>将布局视口设为理想视口</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name="viewport" content="width=device-width" /&gt;</span><br></pre></td></tr></table></figure><p>width指布局视口的宽度、device-width指理想视口的宽度</p></li></ul></li></ul><h3 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h3><ul><li><p>Device Pixel Ratio（DPR），计算公式：</p><ul><li>前提（缩放比例为1）：DPR = 设备像素个数 / 理想视口CSS像素个数（device-width）</li><li>浏览器手机预览模式显示的是<strong>理想视口宽高</strong></li></ul></li><li><p>缩放页面：缩小放大的是CSS像素</p></li><li><p>meta 标签：</p><ul><li><p>让布局视口和理想视口的宽度匹配，常用属性：</p><blockquote><ol><li>width: 设置布局视口的宽</li><li>init-scale：设置页面的初始缩放程度</li><li>minimum-scale：设置页面的最小缩放程度</li><li>maximum-scale：设置页面的最大缩放程度</li><li>user-scalable：是否允许用户对页面进行缩放</li></ol></blockquote></li><li><p>常用实例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span><br></pre></td></tr></table></figure></li></ul></li><li><p>媒体查询：</p><ul><li><p>响应式设计的基础：</p><ul><li>检测媒体类型，如 screen、tv等</li><li>检测布局视口的特性，如视口的宽高分辨率等</li><li>特性相关查询，如检测浏览器是否支持某某特性</li></ul></li><li><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> 媒体类型 and (视口特性阈值) &#123;</span><br><span class="line">    // css code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="从设计图到页面开发"><a href="#从设计图到页面开发" class="headerlink" title="从设计图到页面开发"></a>从设计图到页面开发</h3><ul><li><p>起因：设计图依据设备像素进行设计，而CSS布局依据布局视口的尺寸进行计算</p></li><li><p>解决方案一：</p><ul><li><p>将布局视口的尺寸设置为和设备像素尺寸相等，在设置meta标签后即需要设置理想视口尺寸</p><ul><li><p>CSS缩放值 = 设备像素比的倒数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>).setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width, initial-scale='</span> + scale + <span class="string">', maximum-scale='</span> + scale + <span class="string">', minimum-scale='</span> + scale + <span class="string">', user-scalable=no'</span></span><br></pre></td></tr></table></figure><p>无论任何设备，布局视口的宽度总是等于设备像素</p></li></ul></li><li><p>元素跟着设备变化而等比缩放</p><ul><li><p>rem：<strong>相对于html标签字体大小的单位</strong></p></li><li><p>动态设置html字体大小：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = <span class="built_in">document</span>.documentElemet.clientWidth / <span class="number">10</span> + <span class="string">'px'</span></span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>文字字体大小还是用px</strong></p></li></ul></li><li><p>思路：通过js动态修改meta标签使布局视口尺寸等于设计图尺寸（设备像素尺寸），再用rem代替px使得页面在不同设备中等比缩放</p></li></ul></li><li><p>解决方案二：</p><ul><li><p>不修改meta标签，正常使用缩放为1:1的meta标签</p></li><li><p>将页面的总宽度设置为以rem为单位的定值，如750px总宽取100px的font-size即7.5rem</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">7.5</span> + <span class="string">'px'</span></span><br></pre></td></tr></table></figure></li><li><p>开发页面时通过设计图尺寸/100得到rem尺寸</p></li></ul></li><li><p>文字字体大小设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">321px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">16px</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">321px</span>) and (max-width: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">17px</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">19px</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新的思路</p><ul><li><p>沿用rem布局方案，所有布局元素与属性采用rem做单位</p></li><li><p><strong>html设置font-size使用vw视口单位</strong></p><p>​</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;工作室暑期集训在带17级成员做官网，这里主要总结一些移动端页面开发的基本知识~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;像素&quot;&gt;&lt;a href=&quot;#像素&quot; class=&quot;headerlink&quot; title=&quot;像素&quot;&gt;&lt;/a&gt;像素&lt;/h3
      
    
    </summary>
    
    
      <category term="CSS" scheme="https://jeremygo.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vuex核心</title>
    <link href="https://jeremygo.cn/2018/07/13/Vuex%E6%A0%B8%E5%BF%83/"/>
    <id>https://jeremygo.cn/2018/07/13/Vuex核心/</id>
    <published>2018-07-13T12:54:54.000Z</published>
    <updated>2018-08-02T12:11:47.587Z</updated>
    
    <content type="html"><![CDATA[<p>在封装<a href="https://github.com/fxbabys/hy-vue-admin" target="_blank" rel="noopener">Hy-Vue-Admin</a> 的登录逻辑时，对于登录状态的管理设计刚开始利用很直观的全局cookie保存状态，写起来感觉很别扭而且麻烦，参考了成熟的后台管理模板登录的逻辑以后决定使用Vue官方推荐的Vuex进行全局状态的管理：</p><blockquote><p>Vuex 是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。  —— 官方定义</p></blockquote><h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><ul><li>使用Vue开发单页应用时，经常需要操作一些组件间共享的数据或状态：<ul><li>应用规模较小时，可以使用 props、事件等常用的父子组件的组件间通信方法，单向数据流</li><li>应用规模较大时，即多个组件共享状态时，单向数据流的简洁性很容易被破坏：<ul><li>多个视图依赖于同一状态</li><li>不同视图的行为需要变更同一状态</li></ul></li></ul></li><li>传统解决方式存在的问题：<ul><li>对问题一：传参的方法在多层嵌套的组件下将会变得十分繁琐并且无法处理兄弟组件间状态传递的情况</li><li>对问题二：经常采用父子组件直接引用或者通过事件来变更和同步多个组件间状态的多份拷贝，这种模式非常低效，很容易导致无法维护的代码</li></ul></li><li>新的思路：<ul><li>将组件的共享状态抽取出来，以一个全局单例模式管理</li><li>不管在组件树的哪个位置，任何组件都能直接获取状态或者触发行为</li><li>通过定义和隔离状态管理中的各种概念并且强制遵守一定的规则，代码会更结构化且易维护</li></ul></li></ul><p>先放一张官方图~~</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1ft8jrzhbghj20jh0fb0ta.jpg" alt=""></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>单一状态树理念，每个应用只包含一个 store 实例</p><ul><li><p>Vuex 通过 store 选项将状态从根组件注入到每一个子组件中（<code>Vue.use(Vuex)</code>）:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    store, <span class="comment">// 把 store 对象提供给 store 选项</span></span><br><span class="line">    components: &#123; Counter &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Vue 组件中获取 Vuex 状态：子组件通过 <code>this.$store</code> 访问到 store 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123; Count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapState 辅助函数 与 对象展开运算符</p></li><li>组件仍然保有局部状态<ul><li>使用 Vuex 并不是一定需要将所有的状态放入Vuex</li><li>如果有的状态严格属于单个组件，最好还是作为组件的局部状态</li></ul></li></ul><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 中的 store 中的状态的唯一方法是提交 mutation：</p><ul><li>每个 mutation 都有一个字符串的 事件类型（type） 和一个 回调函数（handler）。回调函数就是我们实际进行状态更改的地方，并且它会默认接受 state 作为第一个参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>不能直接调用一个 mutation handler，要以事件注册的理念：当触发一个类型为 <code>increment</code> 的mutation时，调用此函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><ul><li>提交载荷：可以向 <code>store.commit</code> 传入额外的参数</li><li>Mutation 必须是同步函数：任何由 mutation 事件类型导致的状态变更都应在此刻完成</li></ul><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>类似于 mutation ，区别：</p><ul><li>Action 提交的是 mutation，不是直接变更状态</li><li>Action 可以包含任意异步操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        increment (context) &#123;</span><br><span class="line">            context.commit(<span class="string">'increment'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，即可以通过 <code>context.commit</code> 提交一个mutation</p><ul><li><p>Action 通过 <code>store.dispatch</code> 方法触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>使用单一状态树，应用的所有状态将会集中到一个很大的对象，store对象容易变得臃肿</p><p>因此，Vuex允许我们将store分割成模块，每个模块拥有自己的 state、mutation、action甚至是嵌套子模块</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>src 目录下写全局状态管理的代码，其中包含了 user 的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">|—— api</span><br><span class="line">  |—— login.js      # user login api接口</span><br><span class="line">|—— ……</span><br><span class="line">|—— ……</span><br><span class="line">|—— store</span><br><span class="line">  |—— modules</span><br><span class="line">  |—— user.js     # store中的user module</span><br><span class="line">  |—— getters.js</span><br><span class="line">  |—— index.js</span><br><span class="line">|—— utils</span><br><span class="line">  |—— auth.js       # 对user token的相关操作</span><br><span class="line">  |—— request.js    # axios 登录请求的拦截器</span><br></pre></td></tr></table></figure><p>store 中的user module：</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1ft95ctmkx1j20g50l8405.jpg" alt=""></p><p>Login.vue 中 点击登录分发 Action Login：</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1ft95ewfxw6j20cs0a4q3o.jpg" alt=""></p><p>user模块中actions首先调用登录接口，成功返回token后提交commit设置state token并且使用cookie保存token：</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1ft95holq1uj20ho06j0t8.jpg" alt=""></p><p>至此登录保存token状态的整体逻辑完成</p><p>退出的逻辑也与这个类似，点击退出分发action，调用退出接口返回成功状态码后提交commit设置state token为空并删除cookie，可自行阅读实现代码~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在封装&lt;a href=&quot;https://github.com/fxbabys/hy-vue-admin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hy-Vue-Admin&lt;/a&gt; 的登录逻辑时，对于登录状态的管理设计刚开始利用很直观的全局cookie保
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://jeremygo.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习</title>
    <link href="https://jeremygo.cn/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <id>https://jeremygo.cn/2018/06/29/计算机网络复习/</id>
    <published>2018-06-29T12:23:06.000Z</published>
    <updated>2018-06-30T03:40:30.562Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络相关知识的复习整理~</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="单工、半双工、双工、串行和并行通信"><a href="#单工、半双工、双工、串行和并行通信" class="headerlink" title="单工、半双工、双工、串行和并行通信"></a>单工、半双工、双工、串行和并行通信</h4><ul><li>单工：只有一个信道，传输方向只能单向</li><li>半双工：只有一个信道，传输方向为双向，但同一时刻只能单向传输</li><li>全双工：双信道，同时可以双向数据传输</li><li>串行通信：一组数据在一条线路上一位一位的传送</li><li>并行通信：一组数据在多条线路上同时传送</li></ul><h4 id="协议的三要素"><a href="#协议的三要素" class="headerlink" title="协议的三要素"></a>协议的三要素</h4><ul><li>语法</li><li>语义</li><li>同步</li></ul><h4 id="比较电路交换、分组交换、报文交换"><a href="#比较电路交换、分组交换、报文交换" class="headerlink" title="比较电路交换、分组交换、报文交换"></a>比较电路交换、分组交换、报文交换</h4><table><thead><tr><th>交换方式</th><th>优点（本质/核心思想）</th><th>缺点</th></tr></thead><tbody><tr><td>电路交换</td><td>（1）资源独占 （2）提供面向连接的服务 （3）通信相对可靠</td><td>（1）成本高 （2）资源利用率低</td></tr><tr><td>分组交换</td><td>（1）分组 （2）存储转发 （3）资源共享 （4）灵活性高，适合计算机之间的通信</td><td>（1）可靠性不高 （2）可能出现延迟和堵塞</td></tr><tr><td>报文交换</td><td>不分组的分组交换</td></tr></tbody></table><h4 id="比较数据报网络和虚电路网络"><a href="#比较数据报网络和虚电路网络" class="headerlink" title="比较数据报网络和虚电路网络"></a>比较数据报网络和虚电路网络</h4><table><thead><tr><th style="text-align:center">分组交换方式</th><th style="text-align:center">数据报网络</th><th style="text-align:center">虚电路网络</th></tr></thead><tbody><tr><td style="text-align:center">路由模式</td><td style="text-align:center">源端向目的端发送分组，远端仅根据目标端选择下一条路，分组会在下一结点选择最优的下一条路，同一文件的不同分组可能沿不同的路传输</td><td style="text-align:center">远端与目的端首先建立一条虚拟电路，结点根据分组标签确定所走的虚电路，同一文件的不同分组沿同一条虚电路传输</td></tr><tr><td style="text-align:center">可靠性</td><td style="text-align:center">不强，可能形成环路</td><td style="text-align:center">较好</td></tr><tr><td style="text-align:center">路由器工作量</td><td style="text-align:center">相对较小</td><td style="text-align:center">较高，需要维护每条虚电路的状态</td></tr><tr><td style="text-align:center">QoS</td><td style="text-align:center">不易实现</td><td style="text-align:center">容易实现</td></tr><tr><td style="text-align:center">使用范围</td><td style="text-align:center">因特网</td><td style="text-align:center">ATM、帧中继网络</td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center">灵活、简单</td><td style="text-align:center">复杂</td></tr></tbody></table><h4 id="比较面向连接和无连接服务"><a href="#比较面向连接和无连接服务" class="headerlink" title="比较面向连接和无连接服务"></a>比较面向连接和无连接服务</h4><table><thead><tr><th>服务方式</th><th>面向连接</th><th>无连接</th></tr></thead><tbody><tr><td>数据传输</td><td>建立连接、数据通信、释放连接</td><td>无需连接、直接通信</td></tr><tr><td>可靠性</td><td>可靠</td><td>不可靠，但速度快（尽最大努力服务）</td></tr><tr><td>传输层相应协议</td><td>TCP，电路交换，虚电路</td><td>UDP，IP，Ethernet</td></tr></tbody></table><h4 id="比较带宽、吞吐量和传播速度"><a href="#比较带宽、吞吐量和传播速度" class="headerlink" title="比较带宽、吞吐量和传播速度"></a>比较带宽、吞吐量和传播速度</h4><ul><li>带宽：网络可通过的最高数据传输速率（bit/s）</li><li>吞吐量：网络实际通过的数据传输速率</li><li>传播速度：信号在介质上的传播速率（m/s）</li></ul><h4 id="详细说明分组交换网的延迟有哪些及造成的原因"><a href="#详细说明分组交换网的延迟有哪些及造成的原因" class="headerlink" title="详细说明分组交换网的延迟有哪些及造成的原因"></a>详细说明分组交换网的延迟有哪些及造成的原因</h4><table><thead><tr><th style="text-align:center">延迟类型</th><th style="text-align:center">定义</th><th style="text-align:center">原因</th></tr></thead><tbody><tr><td style="text-align:center">传输延迟</td><td style="text-align:center">数据从结点发送到链路上所消耗的时间</td><td style="text-align:center">网络带宽，数据大小，链路特性，网络特性</td></tr><tr><td style="text-align:center">传播延迟</td><td style="text-align:center">信号从一个结点发送到另一个结点在链路上所消耗的时间</td><td style="text-align:center">传播介质，链路长度</td></tr><tr><td style="text-align:center">结点处理延迟（排队延迟和处理延迟）</td><td style="text-align:center">路由器上排队等待、数据处理和转发至输出链路等所消耗的时间</td><td style="text-align:center">网络拥塞程度，转发表规模，路由器性能</td></tr></tbody></table><h4 id="ping、tracert、ipconfig、nslookup、netstat-的作用"><a href="#ping、tracert、ipconfig、nslookup、netstat-的作用" class="headerlink" title="ping、tracert、ipconfig、nslookup、netstat 的作用"></a>ping、tracert、ipconfig、nslookup、netstat 的作用</h4><ul><li>ping和tracert均用以验证简单TCP/IP网络的连通性</li><li>ping：默认测试4次，发送ICMP请求数据包，并等待接收方的ICMP应答包，显示RTT（Round-trip time，往返时延）和TTL（Time to live，生存时间）</li><li>tracert：通过TTL的递增对路由进行跟踪，测试并显示每个结点的往返时延3次</li></ul><h4 id="什么是互联网"><a href="#什么是互联网" class="headerlink" title="什么是互联网"></a>什么是互联网</h4><ul><li>互联网是网络的网络，它是将全球异构的网络互联起来的网络。互联网由许多终端设备、通信介质和中间设备组成，在TCP/IP协议簇的基础上通过各种应用程序进行通信</li></ul><h4 id="双绞线的制作方法（T568B和T568A）"><a href="#双绞线的制作方法（T568B和T568A）" class="headerlink" title="双绞线的制作方法（T568B和T568A）"></a>双绞线的制作方法（T568B和T568A）</h4><ul><li>T568B：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕</li><li>T568A：白绿，绿，白橙，蓝，白蓝，橙白棕，棕</li></ul><h4 id="直通线和交叉线的应用"><a href="#直通线和交叉线的应用" class="headerlink" title="直通线和交叉线的应用"></a>直通线和交叉线的应用</h4><ul><li>直通线：两端均为T568B，一般用于不同类设备之间</li><li>交叉线：一端为T568B、一端为T568A，一般用于相同或相近设备之间</li></ul><h4 id="网络为什么要分层，如何分层，分层之后如何发送和接收数据以及分层的理解"><a href="#网络为什么要分层，如何分层，分层之后如何发送和接收数据以及分层的理解" class="headerlink" title="网络为什么要分层，如何分层，分层之后如何发送和接收数据以及分层的理解"></a>网络为什么要分层，如何分层，分层之后如何发送和接收数据以及分层的理解</h4><ul><li>分层原因：简单、容易学习与讨论。模块化的设计便于讨论，同时也简化了维护和升级。具体表现在某个层次的服务对系统的其他层次透明，且某个层次的改变只需改变与其相邻层次的接口</li></ul><table><thead><tr><th>OSI体系结构</th><th>TCP/IP 体系结构</th><th>各分层作用</th><th>PDU（协议数据单元）</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>负责各种网络应用、进程与进程之间的通信</td><td>消息</td></tr><tr><td>表示层</td><td></td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>负责端到端数据的传输控制</td><td>报文段</td></tr><tr><td>网络层</td><td>网络层（网际层）</td><td>负责选路和不同网段数据的转发</td><td>分组</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>数据在一段链路上相邻结点间的传输</td><td>帧</td></tr><tr><td>物理层</td><td>物理层</td><td>负责信号物理通信的规则</td><td>比特流</td></tr></tbody></table><p>  数据的发送与接收：发送端将数据进行层层封装（应用层、传输层、网络层和数据链路层均在上一层的基础上加一首部，同时数据链路层在分组最后加一CRC冗余校验码尾部），接收端则按层次结构由下向上层层解封，获得原始数据</p><ul><li>协议分层：协议是对两个对等实体进行通信的规则的集合，其下层为上层提供服务且对上层透明，对某层协议而言，收发双方使用的协议是相同即水平的；而各层协议间下层对上层提供的服务的接口的服务是垂直的</li></ul><h4 id="计算机网络通信的分层模型包含哪些地址信息？"><a href="#计算机网络通信的分层模型包含哪些地址信息？" class="headerlink" title="计算机网络通信的分层模型包含哪些地址信息？"></a>计算机网络通信的分层模型包含哪些地址信息？</h4><table><thead><tr><th>地址</th><th>作用</th><th>所在分层</th></tr></thead><tbody><tr><td>端口（源端口、目的端口）</td><td>传输层向应用层提供的地址，以区分不同应用程序的数据</td><td>传输层</td></tr><tr><td>IP地址（源IP地址、目的IP地址）</td><td>网络层提供的地址，以区分不同网络间的收发双方</td><td>网络层</td></tr><tr><td>MAC地址（源MAC地址、目的MAC地址）</td><td>数据链路层的地址，以区分同一网络内的收发双方</td><td>数据链路层</td></tr></tbody></table><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="网络应用的两种模式"><a href="#网络应用的两种模式" class="headerlink" title="网络应用的两种模式"></a>网络应用的两种模式</h4><ul><li>C/S：客户端-服务器模式，客户向服务器发送请求，服务器响应并提供服务，双方IP地址不能随意改变</li><li>P2P：对等模式，任意的主机既是客户端，又是服务器</li></ul><h4 id="套接字的概念"><a href="#套接字的概念" class="headerlink" title="套接字的概念"></a>套接字的概念</h4><ul><li>套接字=IP地址+端口号，用以唯一确定某台主机的某个进程</li><li>IP地址：IPv4为32位、IPv6为128位，用以唯一确定某台主机在因特网上的位置</li><li>端口号：16位，用以唯一确定某台主机的某个通信进程</li></ul><h4 id="常见网络应用的端口号"><a href="#常见网络应用的端口号" class="headerlink" title="常见网络应用的端口号"></a>常见网络应用的端口号</h4><p>（C:\Windows\System32\drivers\etc\services）</p><table><thead><tr><th>协议</th><th>端口号</th><th>传输层</th><th>定义</th></tr></thead><tbody><tr><td>ftp-data</td><td>20</td><td>tcp</td><td>FTP，data</td></tr><tr><td>ftp</td><td>21</td><td>tcp</td><td>FTP，control</td></tr><tr><td></td><td>22</td><td>tcp</td><td>SSH Remote Login Protocol</td></tr><tr><td>telnet</td><td>23</td><td>tcp</td><td></td></tr><tr><td>smtp</td><td>25</td><td>tcp</td><td>Simple Mail Transfer</td></tr><tr><td>DNS</td><td>53</td><td>tcp、udp</td><td>Domain Name Server</td></tr><tr><td>http</td><td>80</td><td>tcp</td><td>World Wide Web</td></tr><tr><td>pop3</td><td>110</td><td>tcp</td><td>Post Office protocol Version3</td></tr><tr><td>https</td><td>443</td><td>tcp、udp</td><td>HTTP over TLS/SSL</td></tr></tbody></table><h4 id="DNS的查询方式"><a href="#DNS的查询方式" class="headerlink" title="DNS的查询方式"></a>DNS的查询方式</h4><table><thead><tr><th>查询方式</th><th>查询模式</th><th>区别</th></tr></thead><tbody><tr><td>递归查询</td><td>正向查询</td><td>当根域名服务器不能解析时，其会直接向目标域名的授权域名服务器查询，并将结果返回给发送器请求的本地域名服务器</td></tr><tr><td>迭代查询</td><td>正向查询</td><td>当根域名服务器不能解析时，其会直接返回目标域名的授权域名服务器地址给发送请求的本地域名服务器，让请求方自行查询</td></tr><tr><td>反向查询</td><td>反向查询</td><td>通过IP地址获得相应的域名地址</td></tr></tbody></table><h4 id="URL的概念"><a href="#URL的概念" class="headerlink" title="URL的概念"></a>URL的概念</h4><ul><li>URL，统一资源定位符，用以在整个因特网内唯一标记网上的各种文档和对象</li></ul><h4 id="HTTP协议概述，比较HTTP1-0和HTTP1-1"><a href="#HTTP协议概述，比较HTTP1-0和HTTP1-1" class="headerlink" title="HTTP协议概述，比较HTTP1.0和HTTP1.1"></a>HTTP协议概述，比较HTTP1.0和HTTP1.1</h4><ul><li>HTTP：超文本传送协议，应用层协议之一，因特网中最重要的协议之一，通常用于进行web页面的传输，采用C/S模式工作，使用TCP作为传输层协议，默认使用80端口，具体包括HTTP1.0和HTTP1.1两类</li><li>HTTP1.0：非持续连接，使用多条TCP连接获取对象，在完整收到每个对象后才发送下一个对象的请求</li><li>HTTP1.1：持续连接，在同一条TCP连接上同时发送多个页面链接的请求，并依次接收</li></ul><h4 id="FTP的基本概念"><a href="#FTP的基本概念" class="headerlink" title="FTP的基本概念"></a>FTP的基本概念</h4><ul><li>FTP，文件传输协议，应用层协议之一，采用C/S模式工作，使用TCP作为传输层协议，FTP属于维护状态的协议，默认使用数据端口为20，控制端口为21。使用两条连接的好处在于使FTP的控制更容易，编程更方便，且使整个传输过程中连接都不断开，更有助于状态的维护。同时当FTP传输一个文件结束后，控制连接并不断开，如果要重新下一个新文件，仅需控制连接重新协商建立新的数据连接</li></ul><h4 id="了解电子邮件相关的协议：smtp，pop，mime，imap"><a href="#了解电子邮件相关的协议：smtp，pop，mime，imap" class="headerlink" title="了解电子邮件相关的协议：smtp，pop，mime，imap"></a>了解电子邮件相关的协议：smtp，pop，mime，imap</h4><h4 id="DNS中RR的类型"><a href="#DNS中RR的类型" class="headerlink" title="DNS中RR的类型"></a>DNS中RR的类型</h4><table><thead><tr><th>type</th><th>value</th></tr></thead><tbody><tr><td>A</td><td>域名对应的IP地址</td></tr><tr><td>NS</td><td>域名对应的权威域名服务器名称</td></tr><tr><td>CNAME</td><td>域名对应的别名</td></tr><tr><td>MX</td><td>域名对应的邮件服务器名称</td></tr><tr><td>PTR</td><td>Name对应的名字（反向查询）</td></tr></tbody></table><h4 id="电子邮件系统的组成"><a href="#电子邮件系统的组成" class="headerlink" title="电子邮件系统的组成"></a>电子邮件系统的组成</h4><ul><li>用户代理：电子邮件客户端软件</li><li>邮件服务器：提供邮件服务的主机</li><li>邮件发送和接收协议</li></ul><h4 id="常用cmd命令"><a href="#常用cmd命令" class="headerlink" title="常用cmd命令"></a>常用cmd命令</h4><ul><li>nslookup：域名查询，查询internet域名信息</li><li>ftp：传送文件</li><li>telnet：远程控制</li><li>ping：可以检查网络是否连通</li><li>tracert：用于确定IP数据包访问目标所采取的路径</li><li>netstat：查看在内核中访问网络及相关信息的程序</li><li>ipconfig：可用于显示当前的TCP/IP配置的设置值</li><li>arp：可查看局域网内IP与MAC地址的对应，静态配置记录，情况记录等</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="比较传输层和网络层"><a href="#比较传输层和网络层" class="headerlink" title="比较传输层和网络层"></a>比较传输层和网络层</h4><ul><li>传输层负责端到端之间的数据传输的控制。传输层依赖于网络层的服务，传输层向应用层提供服务。网络层主要为主机之间如何选路而到达目的端提供服务，而传输层加强了网络层的服务，在数据能到达对方的前提下，对数据传输进行控制，为进程间的通信提供服务</li></ul><h4 id="比较UDP和TCP"><a href="#比较UDP和TCP" class="headerlink" title="比较UDP和TCP"></a>比较UDP和TCP</h4><table><thead><tr><th>传输服务</th><th style="text-align:center">可靠性</th><th style="text-align:center">设计理念</th><th style="text-align:center">面向连接</th><th style="text-align:center">流量控制</th><th style="text-align:center">拥塞控制</th><th style="text-align:center">三次握手</th><th style="text-align:center">协议首部</th></tr></thead><tbody><tr><td>UDP</td><td style="text-align:center">不可靠</td><td style="text-align:center">尽力而为，可以乱序甚至丢失</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center"></td></tr><tr><td>TCP</td><td style="text-align:center">可靠</td><td style="text-align:center">必须保证数据正确、按序到达接收端。采用：序号机制、确认机制、缓存机制、重传机制、滑动窗口机制</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr></tbody></table><h4 id="停止等待协议的实现机制"><a href="#停止等待协议的实现机制" class="headerlink" title="停止等待协议的实现机制"></a>停止等待协议的实现机制</h4><ul><li>停止等待协议：SW，发送方每发送一个报文，必须等待接收方确认后才能发送下一个报文</li><li>rdt1.0：在信道完全可靠地前提下（数据不会出错和乱序），无需做其它处理即可实现停等协议</li><li>rdt2.0：在信道可能出错的前提下（数据乱序但不会丢失），使用ACK/NAK机制，发送方建有数据缓存，当收到ACK后发送下一分组，收到NAK则重传</li><li>rdt2.1：在信道可能出错的前提下做了进一步的改进，发送方对每个分组0/1循环编号，接收方将对每个收到的分组进行确认，回复数据所编的序号；如遇到重复分组，接收方丢弃并对分组再次确认（仍回复所编序号即可）；如遇到数据错误，则回复上一次正确的确认序号</li><li>rdt3.0：在信道中数据可能乱序甚至出错的前提下，发送方在rdt2.1的基础上，进一步通过“超时”机制发现数据丢失（超时不一定数据丢失，此时编号机制仍能控制传输）</li></ul><h4 id="比较GBN和SR"><a href="#比较GBN和SR" class="headerlink" title="比较GBN和SR"></a>比较GBN和SR</h4><ul><li>GBN和SR都属于滑动窗口协议</li><li>滑动窗口协议允许发送方在没有收到接收方的ACK的前提下发送多个数据包，因此有以下三点改变<ul><li>发送方需要使用发送窗口来限制没有收到ACK情况下最多发送的数据量</li><li>发送方和接收方均增加缓存</li><li>分组序号必须增大</li></ul></li></ul><table><thead><tr><th style="text-align:center">发送类型</th><th style="text-align:center">发送方</th><th style="text-align:center">接收方</th><th style="text-align:center">累计确认</th><th style="text-align:center">窗口大小</th></tr></thead><tbody><tr><td style="text-align:center">GBN</td><td style="text-align:center">连续发送至窗口满，然后等待，收到接收方确认后窗口向后移动。某个分组出错或丢失则重传该分组即其后面所有已发送但未收到确认的分组</td><td style="text-align:center">对按序到达的分组确认，对乱序或错误的分组丢弃，并发送最后一次正确收到的分组的确认</td><td style="text-align:center">某一分组的确认意味着之前所有分组均正确</td><td style="text-align:center">序号个数-1</td></tr><tr><td style="text-align:center">SR</td><td style="text-align:center">某个分组出错或丢失仅重传该分组</td><td style="text-align:center">增加接收缓存（接收窗口），若收到的分组乱序则缓存该分组，等到按序后再一起提交整个缓存（因此接收缓存一般等于发送窗口大小）</td><td style="text-align:center">不同上</td><td style="text-align:center">序号个数/2</td></tr></tbody></table><h4 id="掌握TCP的首部字段"><a href="#掌握TCP的首部字段" class="headerlink" title="掌握TCP的首部字段"></a>掌握TCP的首部字段</h4><ul><li>源端口号、目的端口号：各占2字节，端口是传输层向应用层提供服务的接口</li><li>序号：占4字节，TCP连接下数据流中的每一个字节都编上一个号，序号字段的值指的是本报文段所发送的数据的第一个字节的编号</li><li>确认号：占4个字节，是期望收到对方的写一个报文段的第一个字节的序号（下一报文段序号字段），当有数据发送给对方时顺便确认，当没有数据发送给对方时单独发一确认报文</li><li>首部长度：占4位，表示TCP首部的字节数，该字段限制了TCP首部最大值为60字节</li><li>保留：占6位，保留为今后扩展使用，目前全部置为0</li><li>特殊标记：各占1位<ul><li>URG：紧急标志，值为1时有效，通知本报文段有紧急数据，应尽快传送</li><li>ACK：确认标记，值为1时有效，正常情况下只有第一次握手时为0</li><li>PSH：推送字段，值为1时，接收方在收到该报文段的数据就尽快将其交付给应用进程，而不再等到整个缓存填满</li><li>RST：复位标记，值为1时，表明TCP连接中出现严重差错（主机崩溃等），必须强行释放连接，属于单方面强行断开连接</li><li>SYN：同步标记，值为1时，表示是一个连接请求报文，正常情况下只有第一次握手和第二次握手时SYN=1，其余均=0</li><li>FIN：终止标记，值为1时，表示发送方的报文段数据已发送完毕，请求对方释放该连接，当接收方确认后，发送方将释放发送缓存</li></ul></li><li>窗口：占2字节，窗口字段是流量控制的关键，用来控制对方发送窗口的大小（单位为字节），接收方根据自身的窗口大小确定自己的接收窗口大小，然后通知发送方以确定对方窗口大小的上限</li><li>检验和：占2字节，检验范围包括首部和数据两个部分，在计算检验和时，要在报文段前加12个字节的伪首部</li><li>紧急指针</li><li>选项</li><li>填充</li></ul><h4 id="掌握TCP的序号和确认机制"><a href="#掌握TCP的序号和确认机制" class="headerlink" title="掌握TCP的序号和确认机制"></a>掌握TCP的序号和确认机制</h4><ul><li>序号：TCP首部的序号基于字节。建立连接之初，发送方随机生成初始序号，之后收发双方的每个字节都对应一个编号，而TCP首部中的序号是该报文段第一个字节的编号</li><li>确认：TCP首部的确认号是期望对方发送的下一个数据的第一个字节的编号，即对方下一个报文段的序号。如果某个报文段没有携带数据，对方不需要确认即对方确认号不变，但对于特殊报文，如SYN=1的报文（建立连接），FIN=0的报文（断开连接），对方必须做确认</li><li>TCP属于累积确认，乱序到达数据会缓存</li></ul><h4 id="掌握TCP三次握手和断开连接的详细过程"><a href="#掌握TCP三次握手和断开连接的详细过程" class="headerlink" title="掌握TCP三次握手和断开连接的详细过程"></a>掌握TCP三次握手和断开连接的详细过程</h4><ul><li>三次握手：<ul><li>A-&gt;B，第一次：A随机初始化自己的序号SN（A），确认号置0，初始化窗口大小，SYN=1请求建立连接</li><li>B-&gt;A，第二次：B随机初始化自己的序号SN（B），确认号为SN（A）+1，初始化窗口大小，ACK=1表示B对A的确认，SYN=1请求建立连接</li><li>A-&gt;B，第三次：确认号为SN（B）+1，ACK=1表示A对B的确认，SYN=0</li></ul></li><li>四次挥手：<ul><li>正常断开<ul><li>A-&gt;B，第一次：A：确认号为SN。（B）‘+1，ACK=1，FIN=1请求断开连接</li><li>B-&gt;A，第二次：B：确认号为SN（A）’+1，ACK=1</li><li>B-&gt;A，第三次：B：序号和序列号均与上一次相同，ACK=1，FIN=1请求断开连接</li><li>A-&gt;B，第四次：A：确认号为SN（B）‘+1，ACK=1</li></ul></li><li>异常断开<ul><li>A-&gt;B，第一次：A：确认号为SN。（B）’+1，ACK=1，RST=1请求异常中断</li><li>B-&gt;A，第二次：B：确认号为SN（A）‘+1，ACK=1</li></ul></li></ul></li></ul><h4 id="TCP的流量控制方法"><a href="#TCP的流量控制方法" class="headerlink" title="TCP的流量控制方法"></a>TCP的流量控制方法</h4><ul><li>首部定义了窗口大小：接收方明确通过首部窗口字段发送接收窗口大小，从而限制发送方发送窗口的最大值，而发送方保证发送窗口大小不超过对方发送的接收窗口的大小</li></ul><h4 id="掌握TCP的拥塞控制思想"><a href="#掌握TCP的拥塞控制思想" class="headerlink" title="掌握TCP的拥塞控制思想"></a>掌握TCP的拥塞控制思想</h4><ul><li>五个特征<ul><li>使用拥塞控制窗口cwnd控制发送窗口大小，发送窗口上限值=MIN（rwnd，cwnd）</li><li>分组超时则认为拥塞，反之收到确认则认为网络未拥塞</li><li>拥塞则少发（cwnd减少），未拥塞则多发（cwnd增大）</li><li>网络未知的情况下，cwnd从最小开始，收到确认后cwnd逐渐增大</li><li>为提高效率，开始增加速度快，到了一定阶段后增速变慢</li></ul></li><li>慢启动阶段：窗口初始值（假设为1）指数规律增长，至慢开始门限ssthrest（假设为16），当指数增长结果大于ssthrest时，增长至ssthrest</li><li>拥塞避免阶段：从ssthrest（16）起，以线性规律增长N，直至发生超时（重回慢启动）</li><li>重回慢启动：重回窗口初始值，慢开始门限ssthrest为N值减半（N/2）</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="网络层的作用"><a href="#网络层的作用" class="headerlink" title="网络层的作用"></a>网络层的作用</h4><ul><li>负责将各种不同的网络互联，负责将数据段封装成数据包，关注于分组从一个节点到另一个节点的选路</li></ul><h4 id="数据报网络与虚电路网络的特点与比较"><a href="#数据报网络与虚电路网络的特点与比较" class="headerlink" title="数据报网络与虚电路网络的特点与比较"></a>数据报网络与虚电路网络的特点与比较</h4><table><thead><tr><th></th><th>数据报网络（因特网模型）</th><th>虚电路网络</th></tr></thead><tbody><tr><td>是否先建立连接</td><td>在网络层无连接建立</td><td>发送分组前建立一条虚拟电路</td></tr><tr><td>选路</td><td>一般分组使用目标IP进行路由选择</td><td>每个分组携有标签，由标签决定下一跳</td></tr><tr><td></td><td>同一文件的不同分组可能走不同路径</td><td>在建立连接阶段确定固定路由，所有数据走同一路径</td></tr><tr><td>优点</td><td>灵活，适应性强，网络成本低</td><td>可靠，容易提供QoS，转发速度快</td></tr></tbody></table><h4 id="IP地址的发展"><a href="#IP地址的发展" class="headerlink" title="IP地址的发展"></a>IP地址的发展</h4><p>全分类IP地址-&gt;子网掩码-&gt;无类别域间路由</p><h4 id="全分类的IP地址"><a href="#全分类的IP地址" class="headerlink" title="全分类的IP地址"></a>全分类的IP地址</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">网络号位数</th><th style="text-align:center">主机号位数</th><th style="text-align:center">网络个数</th><th style="text-align:center">主机个数</th><th style="text-align:center">地址范围</th></tr></thead><tbody><tr><td style="text-align:center">A类</td><td style="text-align:center">8</td><td style="text-align:center">24</td><td style="text-align:center">2^7-1</td><td style="text-align:center">2^24-1</td><td style="text-align:center">1.0.0.0-126.255.255.255</td></tr><tr><td style="text-align:center">B类</td><td style="text-align:center">16</td><td style="text-align:center">16</td><td style="text-align:center">2^14</td><td style="text-align:center">2^16-1</td><td style="text-align:center">128.0.0.0-191.255.255.255</td></tr><tr><td style="text-align:center">C类</td><td style="text-align:center">32</td><td style="text-align:center">8</td><td style="text-align:center">2^21</td><td style="text-align:center">2^8-1</td><td style="text-align:center">192.0.0.0-223.255.255.255</td></tr><tr><td style="text-align:center">D类</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">224.0.0.0-239.255.255.255</td></tr></tbody></table><h4 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h4><ul><li>广播地址：主机号全1的地址</li><li>网络地址：主机号全0的地址</li><li>内网地址（私有地址）：10.0.0.0-10.255.255.255，172.16.0.0-172.31.255.255，192.168.0.0-192.168.255.255</li><li>链路本地地址：169.254.0.0-169.254.255.255（无IP地址时由操作系统临时分配的IP地址）</li><li>本地环回地址：127.0.0.0-127.255.255.255</li><li>本地链路广播地址：255.255.255.255</li></ul><h4 id="IP网络和物理网络的概念"><a href="#IP网络和物理网络的概念" class="headerlink" title="IP网络和物理网络的概念"></a>IP网络和物理网络的概念</h4><ul><li>IP网络：IP地址分为网络部分和主机部分，网络部分相同的地址属于同一个IP网络</li><li>物理网络：不经过路由器就可以直接到达的主机唯一同一个物理网络。位于同一物理网络的主机可以直接根据链路层的物理地址寻址</li><li>IP地址和物理网络的关系是多对一的，即多个IP网络可以用于同一物理网络，但同一个IP网络不可以用于多个物理网络。路由器用于转发不同IP网络的分组</li></ul><h4 id="定长掩码的划分和vlsm的划分"><a href="#定长掩码的划分和vlsm的划分" class="headerlink" title="定长掩码的划分和vlsm的划分"></a>定长掩码的划分和vlsm的划分</h4><ul><li>子网掩码的作用：划分子网，便于管理，提高IP地址利用率</li><li>定长掩码（FLSM）：一连串长度不变的数字，通过子网划分确定一个本地区域网路的边界<ul><li>确定子网数</li><li>确定每个子网的IP数</li><li>确定子网掩码</li><li>确定每个子网的IP</li></ul></li><li>由于子网定长，而子网内主机数较少，造成IP地址的浪费，当子网数过多或者单个子网内所需IP数过多时，甚至无法完成子网的划分</li><li>变长掩码（VLSM）：根据不同网段中不同的主机数使用不同长度的子网掩码，即可在某一子网（如/27）中进一步划分出若干个子网（如/30）来</li><li>注意：子网之间通信需要路由器，子网是主机号中划分的，若出现多条路由同时匹配时采用掩码最长前缀匹配原则选择路径</li></ul><h4 id="CIDR地址的表示和路由汇总"><a href="#CIDR地址的表示和路由汇总" class="headerlink" title="CIDR地址的表示和路由汇总"></a>CIDR地址的表示和路由汇总</h4><ul><li>CIDR（无类别域间选路）：取消IP地址的分类限制，以改善IP地址的分配方式，缓解IP地址的危机。CIDR利用层次网络和路由汇总减小路由器中路由表的规模，提高转发速度</li><li>CIDR地址的IP地址由前缀和掩码决定，如10.12.1.1/12其网络号为255.240.0.0，CIDR地址进行路由匹配时采用最长前缀匹配原则</li><li>路由汇总：将连续的多个网络地址汇总为一个网络地址，与层次物理网络结合，能极大的减少路由器上路由表的规模，将多个网络汇总成一个CIDR地址块，形成“超网”，属于不精确汇总（所有属于汇总后的地址块都属于汇总前的地址块称为精确汇总，否则称不精确汇总），不精确汇总可能导致错误的路由</li></ul><h4 id="掌握IP协议的首部"><a href="#掌握IP协议的首部" class="headerlink" title="掌握IP协议的首部"></a>掌握IP协议的首部</h4><ul><li>IP协议是无连接、不可靠的协议，包括IPv4和IPv6两个版本。IPv4包括20个字节的固定首部和长度可变的可选首部</li><li>版本：占4位，表示IP协议版本，IPv4版本值为4</li><li>首部长度：占4位，表示首部的单位长度（每单位4字节），故首部最大长度为60字节</li><li>总长度：占2字节，表示首部和数据的总长度（单位为字节），故数据报的最大分组长度为65535字节（含IP首部），最大数据长度为65515字节（假设首部20字节），但总长度不允许超过MTU（最大传送单元），否则将其分片</li><li>标识：占2字节，分组超过MTU时会进行分片，同一分组的不同分片标识相同</li><li>标志：占3位，包括DF、MF两个标志。DF=1表示该分组不允许分片，MF=1表示该分组后面还有分片</li><li>片偏移：占15位，指出该分片在原分组的位置，以8个字节为单位</li><li>生存时间：占1字节，TTL，表示数据报在网络中的寿命，其单位为秒（实际单位为跳），分组每经过一个路由器TTL就减一，当路由器收到TTL=0的分组时会将其丢弃，TTL能有效的避免该分组在网络上无限循环的转发</li><li>协议：占1字节，指出数据报携带的数据使用上层的何种协议，从而帮助目的主机的网络层将数据部分上交给哪个处理过程</li><li>首部校验和：占2字节，字段只检验数据报的首部，不包括数据部分</li><li>源地址、目的地址：各占4字节，表示发送接收方的IP地址，一般路由器不会改变分组的源IP地址和目的IP地址</li><li>可选字段</li><li>填充</li></ul><h4 id="ICMP的基本工作原理"><a href="#ICMP的基本工作原理" class="headerlink" title="ICMP的基本工作原理"></a>ICMP的基本工作原理</h4><ul><li>ICMP：Internet控制报文协议，用于因特网的传输控制和拆差错报告，主要用于分组传输过程中的异常报告，包括：<ul><li>目标地址不可达</li><li>网络拥塞</li><li>TTL到期</li><li>IP分组检验和失败</li></ul></li><li>注意：<ul><li>对出错的ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对某一分片后的分组，仅发送第一个分片的ICMP差错报告报文，后续分片不再发送</li><li>组播地址数据不发送ICMP差错报告报文</li><li>对特殊地址（如127.0.0.0或0.0.0.0）的数据不发送ICMP差错报告报文</li><li>ping使用了ICMP的回送请求与回送响应报文</li><li>tracert使用了ICMP的控制协议与TTL</li></ul></li></ul><h4 id="NAT的分类和作用"><a href="#NAT的分类和作用" class="headerlink" title="NAT的分类和作用"></a>NAT的分类和作用</h4><ul><li>NAT：网络地址转换，用于IP地址的转换</li></ul><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">定义</th><th style="text-align:center">缺点</th><th style="text-align:center">比较</th></tr></thead><tbody><tr><td style="text-align:center">静态NAT</td><td style="text-align:center">将内网数据报的源IP地址一对一的转换成外网的IP地址</td><td style="text-align:center">无法缓解IP地址危机</td><td style="text-align:center">静态NAT内网IP与外网IP是一一对应的，而动态NAT的地址转换是临时的</td></tr><tr><td style="text-align:center">动态NAT池</td><td style="text-align:center">将外网合法的IP地址形成可用的NAT池。内网IP需要上网时，从NAT中取一个可用的IP地址</td><td style="text-align:center">无法使内网IP同时上网</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">端口NAT（PAT）</td><td style="text-align:center">服务器根据TCP/UDP端口号映射</td><td style="text-align:center"></td></tr></tbody></table><p>  作用：</p><ul><li>解决多个用户使用一个公网IP上网的问题，缓解了IP地址危机</li><li>实现内部IP地址隐藏及服务器负载均衡</li></ul><h4 id="DHCP的基本工作原理"><a href="#DHCP的基本工作原理" class="headerlink" title="DHCP的基本工作原理"></a>DHCP的基本工作原理</h4><ul><li>DHCP：动态主机设置协议，采用C/S模式，使用UDP协议工作，服务器端口号为67，客户端端口号为68，用于主机自动获得IP地址、子网掩码、网关地址、DNS服务器地址、租用期的相关信息</li><li>工作过程<ul><li>服务器被动打开UDP端口67，等待客户端发来的报文</li><li>客户通过UDP端口68广播DHCP发现报文</li><li>服务器发送广播报文声明可以提供IP地址</li><li>客户广播请求IP地址</li><li>服务器广播发送IP地址、网关等，客户允许租用期内使用IP</li><li>租用期即将到期，发送续约请求。如果服务器同意则继续使用该IP，否则返回第2步重新申请</li></ul></li><li>DHCP中继代理：广播DCHPREQUEST请求，中继代理单播向其他网络的DHCP服务器，获取IP地址</li></ul><h4 id="路由的概念及分类"><a href="#路由的概念及分类" class="headerlink" title="路由的概念及分类"></a>路由的概念及分类</h4><ul><li>概念：根据目标网络选择最“好”路径</li><li>分类：从路由获取方式可分为：直连路由、静态路由、动态路由</li><li>从路由匹配数量可分为：目标路由、特定主机路由、默认路由</li></ul><h4 id="比较距离向量路由算法和链路状态路由算法"><a href="#比较距离向量路由算法和链路状态路由算法" class="headerlink" title="比较距离向量路由算法和链路状态路由算法"></a>比较距离向量路由算法和链路状态路由算法</h4><ul><li>距离向量路由算法和链路状态路由算法均属于动态路由协议（让路由器通过交换信息自动获得路由信息）</li></ul><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">原理</th><th style="text-align:center">特点</th><th style="text-align:center">范围</th><th style="text-align:center">收敛时间</th><th style="text-align:center">健壮性</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">距离向量算法（DV）</td><td style="text-align:center">（1）周期性向邻居通告自己的路由信息 （2）根据邻居通告使用加法更新自己的距离向量表 （3）路由表改变时，继续通告邻居 （4） 网络中所有路由表没有改变时，算法终止</td><td style="text-align:center">好消息传的快，坏消息传的慢（形成路由环路）</td><td style="text-align:center">邻居之间</td><td style="text-align:center">不稳定</td><td style="text-align:center">不好</td><td style="text-align:center">RIP、BGP</td></tr><tr><td style="text-align:center">链路状态路由算法（LS）</td><td style="text-align:center">（1）将自己的链路状态洪泛到网络上的所有路由器 （2）每个路由器最终会知道整个网络的拓扑结构 （3）使用Dijstra最短路径算法计算自己与其他路由器最短路径，更新路由表</td><td style="text-align:center">可能产生路由震荡</td><td style="text-align:center">整个网络</td><td style="text-align:center">稳定</td><td style="text-align:center">好</td><td style="text-align:center">OSPF</td></tr></tbody></table><h4 id="掌握rip的工作原理与配置方法"><a href="#掌握rip的工作原理与配置方法" class="headerlink" title="掌握rip的工作原理与配置方法"></a>掌握rip的工作原理与配置方法</h4><ul><li>RIP使用距离向量路由算法：<ul><li>使用UDP（端口520）进行传输，按固定的时间间隔交换路由信息（30s）</li><li>RIP将距离定义为“跳数”，每经过一个路由器跳数加1，规定最大值为15（16即相当于不可达）</li><li>使用毒性逆转（即向某条路由对应的出接口通告该路由为无穷大路由）等方法缓解环路影响</li></ul></li><li>RIP包括RIP1和RIP2：<ul><li>RIP1通过广播通告路由信息，不支持验证和CIDR</li><li>RIP2通过组播通告路由信息，支持验证和CIDR</li></ul></li></ul><h4 id="IGP和EGP"><a href="#IGP和EGP" class="headerlink" title="IGP和EGP"></a>IGP和EGP</h4><ul><li>为解决路由信息过多，更新缓慢的问题，使用自治系统（AS，由一个管理部门管理的具有相同路由策略的网络系统）管理网络系统。同一AS内的路由器使用相同的路由协议称IGP（内部网关协议），如RIP，OSPF；AS之间的路由器使用的路由协议称为EGP（外部网关协议），如BGP。网关路由器同时运行IGP和EGP</li></ul><h4 id="OSPF路由协议"><a href="#OSPF路由协议" class="headerlink" title="OSPF路由协议"></a>OSPF路由协议</h4><ul><li>使用链路状态路由算法，无路由自环，支持区域划分适用于大规模网络，支持CIDR、VLSM，支持验证，使用组播方式发送协议报文，基于IP，为停等协议，自身可实现可靠传输，收敛速度快，链路代价为10^8/网络带宽</li><li>OSPF使用路由器标识（32位无符号整数，整个自治系统唯一）唯一确定OSPF路由器</li><li>OSPF划分区域来减少洪泛范围，其中ABR负责区域之间的信息传递，它使用距离矢量算法</li><li>OSPF支持的网络拓扑结构：广播式多点接入网络、点到点网络、点到多点网络等</li><li>在全连通网络中，选取DR（村长）和BDR，DR负责通告路由</li></ul><h4 id="IPv6的基本概念"><a href="#IPv6的基本概念" class="headerlink" title="IPv6的基本概念"></a>IPv6的基本概念</h4><ul><li>版本：占4位，指明协议版本号</li><li>通信量类：占1字节，区分不同IPv6数据报或类别</li><li>流标号</li><li>有效载荷长度：占2字节，除首部外的数据长度（包括扩展首部），故最大长度为64KB</li><li>下一个首部：占1字节，相当于IPv4中的协议字段</li><li>跳数限制：占1字节，远端在数据发出时设置跳数限制，路由器每转发一次跳数减1，跳数为1时将被丢弃</li><li>源地址、目的地址：各占4字节</li></ul><h4 id="IPv6针对IPv4的改进"><a href="#IPv6针对IPv4的改进" class="headerlink" title="IPv6针对IPv4的改进"></a>IPv6针对IPv4的改进</h4><ul><li>增加IP地址范围</li><li>尽可能减少路由器的额外工作</li><li>提高路由器转发分组的速度</li><li>更好的实现路由汇总</li><li>更好实现QoS提高协议的灵活性，增加了移动性和安全性</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="比较数据链路层和传输层"><a href="#比较数据链路层和传输层" class="headerlink" title="比较数据链路层和传输层"></a>比较数据链路层和传输层</h4><ul><li>数据链路层：负责一段链路的两端之间的通信，由网卡负责数据链路层的协议</li></ul><table><thead><tr><th style="text-align:center">服务层</th><th style="text-align:center">通信</th><th style="text-align:center">范围</th><th style="text-align:center">服务对象</th></tr></thead><tbody><tr><td style="text-align:center">传输层</td><td style="text-align:center">收发双方主机到主机</td><td style="text-align:center">整个网络</td><td style="text-align:center">应用层，端口</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:center">一段链路端到端</td><td style="text-align:center">同一局域网内</td><td style="text-align:center">物理层、MAC地址</td></tr></tbody></table><h4 id="网卡的作用"><a href="#网卡的作用" class="headerlink" title="网卡的作用"></a>网卡的作用</h4><ul><li>数据的封装与解封：<ul><li>发送时将收到的上层分组加上首部和尾部形成以太网的帧并通过物理层发出</li><li>接收时则将收到的分组剥去首部和尾部形成分组并送交上层</li></ul></li><li>链路管理<ul><li>实现CSMA/CD：带冲突检测的载波监听多路访问</li><li>编码与译码：实现曼彻斯特编码与译码</li></ul></li></ul><h4 id="比较IP地址和MAC地址"><a href="#比较IP地址和MAC地址" class="headerlink" title="比较IP地址和MAC地址"></a>比较IP地址和MAC地址</h4><table><thead><tr><th style="text-align:center">地址类型</th><th style="text-align:center">定义</th><th style="text-align:center">目的</th><th style="text-align:center">长度</th><th style="text-align:center">范围</th><th style="text-align:center">所在TCP层</th><th style="text-align:center">获取对方地址方式</th></tr></thead><tbody><tr><td style="text-align:center">IP地址</td><td style="text-align:center">因特网上不同网络间能够通信的唯一地址</td><td style="text-align:center">不同网段间的通信</td><td style="text-align:center">IPv4：32位，IPv6：128位</td><td style="text-align:center">广域网</td><td style="text-align:center">网络层</td><td style="text-align:center">DNS</td></tr><tr><td style="text-align:center">MAC地址</td><td style="text-align:center">局域网中固化在硬件上的地址</td><td style="text-align:center">同一网段内结点间通信</td><td style="text-align:center">48位</td><td style="text-align:center">局域网</td><td style="text-align:center">数据链路层</td><td style="text-align:center">ARP</td></tr></tbody></table><h4 id="CRC冗余检验的计算方法以及奇偶校验"><a href="#CRC冗余检验的计算方法以及奇偶校验" class="headerlink" title="CRC冗余检验的计算方法以及奇偶校验"></a>CRC冗余检验的计算方法以及奇偶校验</h4><ul><li>CRC冗余检验：<ul><li>待校验数据除以一个约定好的除数，若能除尽则校验正确，否则出错</li><li>差错率高，能纠错</li></ul></li><li>具体做法：<ul><li>数据比特流看出二进制数据作为被除数D</li><li>选择一个n位的二进制数作为除数G</li><li>发送方采用异或方式D除以G得到余数R，即为CRC冗余校验码</li></ul></li><li>奇偶校验：通过在数据后添加1位，保证新的数据中1有奇数个<ul><li>一维奇偶校验能查错</li><li>二维奇偶校验能纠错（1位）</li></ul></li></ul><h4 id="FDMA、TDMA、CDMA"><a href="#FDMA、TDMA、CDMA" class="headerlink" title="FDMA、TDMA、CDMA"></a>FDMA、TDMA、CDMA</h4><ul><li>均属于信道分割技术</li><li>FDMA：频分复用<ul><li>信道按频率分割成若干频段，每个站点分得固定的频段，该站点不用时相应频段被闲置浪费</li></ul></li><li>TDMA：时分复用<ul><li>信道根据时间分成多个固定长度的时间片，每个用户允许在不同的时间片上传输信息，某个时间片上无用户传送信息则导致信道浪费</li></ul></li><li>CDMA：码分复用<ul><li>大部分用于无线通信场合，用户共享相同频道，每个用户用自己的码片序列对数据编码，允许多用户共存和发送信号，对相互的干扰极小</li></ul></li></ul><h4 id="CSMA-CD的工作原理"><a href="#CSMA-CD的工作原理" class="headerlink" title="CSMA/CD的工作原理"></a>CSMA/CD的工作原理</h4><ul><li>CSMA/CD，带冲突检测的载波监听多路访问，核心思想包括：<ul><li>先听后讲：信道空闲则讲，否则等待</li><li>边听边讲：发送信号时不断检测是否碰撞</li><li>碰撞即停</li><li>退避重传：二进制指数退避算法重传</li><li>多次碰撞，放弃发送：最多16次</li></ul></li><li>二进制退避算法：<ul><li>确定基本退避时间，一般为争用期2τ（端到端的往返时延）</li><li>定义重传次数k（k&lt;=10）</li><li>从整数集合{0,1，……，2^k-1}中随机取一数记为r，则重传退避时延为r*2τ</li><li>重传16次仍不成功则丢弃该帧，并向高层报告</li></ul></li></ul><h4 id="ARP的工作原理"><a href="#ARP的工作原理" class="headerlink" title="ARP的工作原理"></a>ARP的工作原理</h4><ul><li>ARP：通过IP地址获得MAC地址</li><li>工作原理：<ul><li>发送方A向接收方B发送数据前，查看本地的ARP缓存表，若没有则广播发送ARP请求包</li><li>局域网内主机和网关均将A的MAC地址记入ARP缓存表，但不响应</li><li>接收方若在局域网内，B收到广播请求后向A单播发送响应ARP报文</li><li>接收方若不在局域网内，则向网关获取B的MAC地址，网关ARP缓存表中有则直接回复响应，没有则继续发送ARP请求报文</li></ul></li></ul><h4 id="最短帧长的作用和计算方法"><a href="#最短帧长的作用和计算方法" class="headerlink" title="最短帧长的作用和计算方法"></a>最短帧长的作用和计算方法</h4><ul><li>传统的以太网的最短帧长为64字节，从而确保碰撞帧的检测，小于64字节的帧被认为是碰撞帧，因此实际发送数据小于64字节时会被自动填充</li></ul><h4 id="碰撞域和广播域的判断"><a href="#碰撞域和广播域的判断" class="headerlink" title="碰撞域和广播域的判断"></a>碰撞域和广播域的判断</h4><ul><li>一个CSMA/CD网络即是一个碰撞域，基于物理层。网络设备中中继器（Repeater）和集线器（Hub）不能隔离碰撞域，网桥、二层交换机、路由器和三层交换机可以隔离碰撞域</li><li>广播域是指网段上收听送往所在网段的所有广播的所有设备的集合，基于数据链路层。只有路由器和三层交换机可以隔离广播域</li><li>交换机上有多少个端口连到了网络，就有多少个碰撞域；路由器上有多少个端口连到了网络，就有多少个广播域</li></ul><h4 id="MAC地址的基本特点"><a href="#MAC地址的基本特点" class="headerlink" title="MAC地址的基本特点"></a>MAC地址的基本特点</h4><ul><li>单播MAC地址：固化在网卡上<ul><li>十六进制表示：AC-DE-48-D0-00-80</li><li>二进制表示：第八位必须为0</li></ul></li><li>广播MAC地址：FF-FF-FF-FF-FF-FF</li><li>组播MAC地址：组播MAC地址通过组播IP地址后23位映射而成</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;计算机网络相关知识的复习整理~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;h4 id=&quot;单工、半双工、双工、串行和并行
      
    
    </summary>
    
    
      <category term="Courses" scheme="https://jeremygo.cn/tags/Courses/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习</title>
    <link href="https://jeremygo.cn/2018/06/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <id>https://jeremygo.cn/2018/06/24/操作系统复习/</id>
    <published>2018-06-24T01:10:05.000Z</published>
    <updated>2018-06-27T13:32:59.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大二下即将结束，这里将操作系统的重点概念整理一下方便复习~</p></blockquote><h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><h4 id="何谓多道程序设计？叙述它的主要特征和优点"><a href="#何谓多道程序设计？叙述它的主要特征和优点" class="headerlink" title="何谓多道程序设计？叙述它的主要特征和优点"></a>何谓多道程序设计？叙述它的主要特征和优点</h4><ul><li>多道程序设计是一种软件技术。该技术使同时进入计算机主存的几个相互独立的程序在管理程序控制之下相互交替执行。当某道程序因某种原因不能继续运行下去时，管理程序便将另一道程序投入运行。这样可以使中央处理器及各外部设备尽量处于忙碌状态，从而大大提高计算机的使用效率</li><li>单处理器系统中，多道程序运行特征：<ul><li>多道：即计算机主存中同时存放几道相互独立的程序</li><li>宏观上并行：同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行但都未运行完毕</li><li>微观上串行：微观上主存中多道程序轮流或分时地占用处理器，即多道程序交替执行</li></ul></li><li>多道程序设计的优点：<ul><li>可提高CPU的利用率</li><li>可提高主存和I/O设备利用率</li><li>可增加系统吞吐量</li></ul></li></ul><h4 id="操作系统具有哪几大特征？"><a href="#操作系统具有哪几大特征？" class="headerlink" title="操作系统具有哪几大特征？"></a>操作系统具有哪几大特征？</h4><ul><li>不同的操作系统都具有四个基本特征：<ul><li>并发：并发性是指两个或多个事件在同一时间间隔内发生。多道程序环境下，并发性指宏观上一段时间内多道程序在同时运行；单处理器系统中，每一时刻只能执行一道程序即微观上交替执行</li><li>共享：共享是指系统中的资源可供主存中多个并发执行的进程共同使用</li><li>虚拟：指通过某种技术把一个物理实体变成若干个逻辑上的对应物</li><li>异步性：多道程序环境下允许多个进程并发执行，但由于资源等因素限制，进程是以异步方式允许的。只要运行环境相同，作业经多次运行都会获得完全相同的结果，因此异步运行是允许的</li></ul></li></ul><h4 id="在交互性、及时性和可靠性方面比较分时系统与实时系统"><a href="#在交互性、及时性和可靠性方面比较分时系统与实时系统" class="headerlink" title="在交互性、及时性和可靠性方面比较分时系统与实时系统"></a>在交互性、及时性和可靠性方面比较分时系统与实时系统</h4><ul><li>交互性：分时系统交互性强，实时系统交互性弱。因为交互性强不能满足实时系统响应速度快和高可靠性的要求</li><li>及时性：实时系统要求快速响应而及时性强，分时系统相比较弱</li><li>可靠性：实时系统要求高可靠性而可靠性强，分时系统相比较弱</li></ul><h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><h4 id="何谓进程？它有哪些基本状态？列举使进程状态发生变化的事件"><a href="#何谓进程？它有哪些基本状态？列举使进程状态发生变化的事件" class="headerlink" title="何谓进程？它有哪些基本状态？列举使进程状态发生变化的事件"></a>何谓进程？它有哪些基本状态？列举使进程状态发生变化的事件</h4><ul><li>进程是可并发执行的程序在一个数据集上的一次执行过程，是系统进行资源分配的基本单位</li><li>进程有就绪、执行、等待三个基本状态</li><li>状态变化事件<ul><li>就绪 -&gt; 执行：进程调度程序分配CPU</li><li>执行 -&gt; 等待：正在执行的进程因访问I/O设备而无法继续执行时</li><li>等待 -&gt; 就绪：因访问I/O设备正在等待的进程在访问I/O设备结束后<ul><li>执行 -&gt; 就绪：正在执行的进程如因时间片用完而被暂停执行时  吧  </li></ul></li></ul></li></ul><h4 id="比较进程和程序的区别"><a href="#比较进程和程序的区别" class="headerlink" title="比较进程和程序的区别"></a>比较进程和程序的区别</h4><ul><li>程序是指令的有序集合，是一个在时间上按严格次序前后相继的操作序列，是一个静态的概念</li><li>进程是可并发执行的程序在一个数据集上的一次执行过程，是系统进行资源分配的基本单位，它具有以下五个基本特征：<ul><li>动态性：进程最基本的特性，表现为：“它由创建而产生，由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡”</li><li>并发性：多个进程实体同存于主存中，能在一段时间内同时运行；它是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的正是为了使程序能和其它进程的程序并发执行，而程序不能并发执行</li><li>独立性：进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。未建立进程的程序都不能作为一个独立的单位参加运行。进程与程序并非是一一对应的，一个程序运行在不同的数据集上就构成不同的进程</li><li>异步性：进程按各自独立的、不可预知的速度向前推进即进程按异步方式运行。这一特征导致程序执行的不可再现性，因此在操作系统中必须采取某种措施来保证各程序之间能协调运行</li><li>结构特征：进程实体在结构上由程序段、数据段、及进程控制块三部分组成，有人统称这三部分为“进程映像”</li></ul></li></ul><h4 id="进程调度的功能有哪些？"><a href="#进程调度的功能有哪些？" class="headerlink" title="进程调度的功能有哪些？"></a>进程调度的功能有哪些？</h4><ul><li>记录系统中所有进程的执行情况</li><li>选择占有处理器的进程</li><li>把处理器分配给进程，即进行进程上下文切换</li><li>收回处理器</li></ul><h4 id="进程调度的时机有哪几种？"><a href="#进程调度的时机有哪几种？" class="headerlink" title="进程调度的时机有哪几种？"></a>进程调度的时机有哪几种？</h4><ul><li>正在执行的进程执行完毕</li><li>执行中的进程自己调用阻塞原语将自己阻塞起来进入等待状态</li><li>执行中的进程调用了P原语操作从而因资源不足而被阻塞或调用了V原语操作激活了等待资源的进程队列</li><li>执行中的进程提出I/O请求后被阻塞</li><li>在分时系统中时间片已经用完</li><li>在执行完系统调用等系统程序后返回用户进程即系统进程执行完毕时</li><li>在可剥夺CPU执行方式时就绪队列中某进程优先级高于当前执行进程的优先级</li></ul><h4 id="在信号量s上作PV操作时，s-gt-0、s-0、s-lt-0时的物理意义是什么？"><a href="#在信号量s上作PV操作时，s-gt-0、s-0、s-lt-0时的物理意义是什么？" class="headerlink" title="在信号量s上作PV操作时，s&gt;0、s=0、s&lt;0时的物理意义是什么？"></a>在信号量s上作PV操作时，s&gt;0、s=0、s&lt;0时的物理意义是什么？</h4><ul><li>s &gt; 0：还有s个可用资源</li><li>s = 0：已无可用资源</li><li>s &lt; 0：已无可用资源并且还有|s|个进程在等待使用资源</li></ul><h4 id="若系统有同类资源m个，被n个进程共享，问：m-gt-n-和-m-lt-n-时每个进程最多可以请求多少个这类资源使系统一定不会发生死锁？"><a href="#若系统有同类资源m个，被n个进程共享，问：m-gt-n-和-m-lt-n-时每个进程最多可以请求多少个这类资源使系统一定不会发生死锁？" class="headerlink" title="若系统有同类资源m个，被n个进程共享，问：m &gt; n 和 m &lt;= n 时每个进程最多可以请求多少个这类资源使系统一定不会发生死锁？"></a>若系统有同类资源m个，被n个进程共享，问：m &gt; n 和 m &lt;= n 时每个进程最多可以请求多少个这类资源使系统一定不会发生死锁？</h4><ul><li>m &gt; n：m / n （向上取整）</li><li>m &lt;= n：1</li></ul><h4 id="何谓死锁？产生死锁的原因和必要条件是什么？"><a href="#何谓死锁？产生死锁的原因和必要条件是什么？" class="headerlink" title="何谓死锁？产生死锁的原因和必要条件是什么？"></a>何谓死锁？产生死锁的原因和必要条件是什么？</h4><ul><li>在系统中存在一组进程（两个以上），每一个进程都占用了某种资源而又都在永久等待其中另一进程所占用的进程所占用的资源</li><li>产生原因：<ul><li>竞争资源：系统中供多个进程所共享的资源不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁</li><li>进程推进顺序非法：进程在运行过程中，请求和释放资源的顺序不当导致进程死锁</li></ul></li><li>四个必要条件：<ul><li>互斥条件：进程应互斥使用资源，任意时刻一个资源仅为一个进程独占，若另一个进程请求一个已被占用的资源时，它被置为等待状态直到占用者释放资源</li><li>占有且等待条件：一个进程请求资源得不到满足而等待时，不释放已占有的资源</li><li>不剥夺条件：任一进程不能从另一进程那抢夺资源，即已被占用的资源只能由占用进程自己来释放</li><li>循环等待条件：存在一个循环等待链，每一个进程分别等待另一个进程所持有的资源，造成永久等待</li></ul></li></ul><h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><h4 id="解释作业和作业步"><a href="#解释作业和作业步" class="headerlink" title="解释作业和作业步"></a>解释作业和作业步</h4><ul><li>把用户在一次解题过程中要求计算机所做工作的集合称为一个作业</li><li>任何一个作业都要经过若干加工步骤才能得到结果，每一个加工步骤称为一个“作业步”</li></ul><h4 id="作业的状态分成哪几种？各种状态之间是如何转换的"><a href="#作业的状态分成哪几种？各种状态之间是如何转换的" class="headerlink" title="作业的状态分成哪几种？各种状态之间是如何转换的"></a>作业的状态分成哪几种？各种状态之间是如何转换的</h4><ul><li>通常作业分成四种状态：<ul><li>提交状态：一个作业在用户手中经过输入设备进入到外存输入井，系统为其建立作业控制块</li><li>后备状态：对于已进入输入井的作业，系统将它插入到输入井后备队列中，等待作业调度程序的调度运行</li><li>运行状态：一个处于后备状态的作业，一旦被作业调度程序选中装入主存，系统就为它分配必要的软硬件资源并建立相应的进程插入到进程就绪队列中</li><li>完成状态：作业完成其全部运行过程并释放其所占全部资源而正常结束或异常终止时</li></ul></li></ul><h4 id="叙述作业、进程和程序三者的关系"><a href="#叙述作业、进程和程序三者的关系" class="headerlink" title="叙述作业、进程和程序三者的关系"></a>叙述作业、进程和程序三者的关系</h4><ul><li>执行作业调度之前的作业是静态的，基本以文件形式存储在外部存储介质中</li><li>当作业经过作业调度的高级阶段调度后，其状态即从静态转变为动态执行状态，并为此创建了相应的作业进程，进程在经过若干次状态变更后即可完成作业功能并结束运行撤销</li><li>程序作为作业的主体部分，也是以文件形式存储在外部存储介质当中</li></ul><h4 id="作业调度的性能指标"><a href="#作业调度的性能指标" class="headerlink" title="作业调度的性能指标"></a>作业调度的性能指标</h4><ul><li>CPU利用率：CPU有效运行时间与总运行时间之比</li><li>吞吐能力：单位时间内完成作业数量</li><li>周转时间：从作业被提交进入输入井开始到作业执行完成的这段时间间隔</li><li>平均周转时间：所有作业周转时间的平均值</li><li>平均带权周转时间：带权周转时间即作业的周转时间与作业的运行时间之比</li></ul><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><h4 id="分页式存储管理和分段式存储管理有何区别？"><a href="#分页式存储管理和分段式存储管理有何区别？" class="headerlink" title="分页式存储管理和分段式存储管理有何区别？"></a>分页式存储管理和分段式存储管理有何区别？</h4><ul><li>分页和分段都采用离散分配主存方式，需要通过地址映射机构来实现地址变换</li><li>区别：<ul><li>页是信息的物理单位，是系统管理的需要而不是用户的需要；而段则是信息的逻辑单位，含有一组意义相对完整的信息，分段是为了更好地满足用户的需要</li><li>页的大小固定且由系统决定，即一个系统只能有一种大小的页面；而段的长度却不固定，由用户所编写的程序决定，通常由编译程序对源程序进行编译时根据信息的性质来划分</li><li>分页式作业的地址空间是一维的，页间的逻辑地址是连续的；而分段式作业的地址空间则是二维的，段间的逻辑地址是不连续的</li></ul></li></ul><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><h4 id="简述采用通道技术时，I-O操作的全过程"><a href="#简述采用通道技术时，I-O操作的全过程" class="headerlink" title="简述采用通道技术时，I/O操作的全过程"></a>简述采用通道技术时，I/O操作的全过程</h4><ul><li>采用通道技术当进程提出I/O请求后：<ul><li>系统首先分配通道和外设</li><li>然后按照I/O请求编制通道程序并存入主存，将其起始地址送入通道地址寄存器（CAW）</li><li>然后CPU发出“启动I/O”指令启动通道工作</li><li>启动成功后通道逐条执行通道程序中的通道指令，控制设备实现I/O操作</li></ul></li></ul><h4 id="叙述引入缓冲的主要原因，其实现的基本思想是什么？"><a href="#叙述引入缓冲的主要原因，其实现的基本思想是什么？" class="headerlink" title="叙述引入缓冲的主要原因，其实现的基本思想是什么？"></a>叙述引入缓冲的主要原因，其实现的基本思想是什么？</h4><ul><li>主要原因：<ul><li>缓和CPU与I/O设备间速度不匹配的矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li><li>提高CPU和I/O设备之间的并行性</li></ul></li><li>实现方法：<ul><li>采用专用硬件缓冲器</li><li>划分具有n个单元的主存缓冲区</li></ul></li></ul><h4 id="何谓虚拟设备？简述虚拟设备的设计思想"><a href="#何谓虚拟设备？简述虚拟设备的设计思想" class="headerlink" title="何谓虚拟设备？简述虚拟设备的设计思想"></a>何谓虚拟设备？简述虚拟设备的设计思想</h4><ul><li>虚拟设备是指采用相应的技术和方法将独占型设备变换为若干台对应的逻辑设备</li><li>其设计思想是将独占型设备改造为共享型设备。宏观上虽然十多个进程在同时使用一台独占型设备，但为每一个进程而言，它们都认为自己独占了一个设备</li></ul><h4 id="SPOOLing系统由哪些部分组成？简述它们的功能"><a href="#SPOOLing系统由哪些部分组成？简述它们的功能" class="headerlink" title="SPOOLing系统由哪些部分组成？简述它们的功能"></a>SPOOLing系统由哪些部分组成？简述它们的功能</h4><ul><li>预输入程序：把一批作业组织在一起形成作业流，由预输入程序把作业流中每个作业的初始信息由输入设备输入到输入井保存，并填写好输入表以便在作业执行中要求输入信息时可以随时找到它们的存放位置以备作业调度</li><li>井管理程序<ul><li>井管理读程序：当作业请求从输入机上读文件信息时就把任务转交给井管理读程序，从输入井读出信息供用户使用</li><li>井管理写程序：当作业请求从打印机上输出结果时就把任务转交给井管理写程序，把产生的结果保存到输出井中</li></ul></li><li>缓输出程序：缓输出程序负责查看输出井中是否有等待输出的结果信息，如果有则启动打印机把作业的结果文件打印输出，当一个作业的文件信息输出完毕后，将它占用的井区回收以供其它作业使用</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="文件系统应具有哪些功能？"><a href="#文件系统应具有哪些功能？" class="headerlink" title="文件系统应具有哪些功能？"></a>文件系统应具有哪些功能？</h4><ul><li>目录管理</li><li>文件的组织</li><li>文件存储空间的管理</li><li>文件操作</li><li>文件的共享、保护和保密</li></ul><h4 id="简述文件的结构和组织方式"><a href="#简述文件的结构和组织方式" class="headerlink" title="简述文件的结构和组织方式"></a>简述文件的结构和组织方式</h4><ul><li>逻辑结构：用户所观察到的文件组织形式，是用户可以直接处理的数据及结构，独立于物理特性构造而成。由用户构造的文件称文件的逻辑结构<ul><li>无结构的流式文件</li><li>有结构的记录式文件</li></ul></li><li>物理结构：文件在辅存上的存储组织形式，与存储介质的存储性能有关<ul><li>顺序结构</li><li>链接结构</li><li>索引结构</li></ul></li></ul><h4 id="文件的存取方式"><a href="#文件的存取方式" class="headerlink" title="文件的存取方式"></a>文件的存取方式</h4><ul><li>顺序存取：严格按照文件中的逻辑信息单位排列的逻辑地址顺序依次读取</li><li>随机存取：按任意次序随机读写文件中的信息</li><li>按键存取：用于复杂文件系统、特别是数据库管理系统中的存取方法</li></ul><h4 id="链接法共享文件主要采取哪几种实现技术？比较每种实现技术的特点"><a href="#链接法共享文件主要采取哪几种实现技术？比较每种实现技术的特点" class="headerlink" title="链接法共享文件主要采取哪几种实现技术？比较每种实现技术的特点"></a>链接法共享文件主要采取哪几种实现技术？比较每种实现技术的特点</h4><ul><li>目录链接技术：将共享文件的存储地址、长度等文件信息记录在文件目录项中，但链接后的目录结构变成了网状结构，使管理更复杂同时会导致删除异常和更新异常</li><li>基于索引结点的链接技术：将共享文件的存储地址、长度等文件信息记录在索引结点中，大大减少了删除异常和更新异常，但也会导致指针悬空及共享文件所有者为等待其他用户完成而付出高昂的代价</li><li>符号链接技术：通过调用系统过程“link”来创建一个LINK型新文件登记被链接的文件的路径名，优点主要体现在避免了指针悬空和实现网络环境下任意文件的共享两方面</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;大二下即将结束，这里将操作系统的重点概念整理一下方便复习~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引论&quot;&gt;&lt;a href=&quot;#引论&quot; class=&quot;headerlink&quot; title=&quot;引论&quot;&gt;&lt;/a&gt;引论&lt;/h3&gt;&lt;h4 id=&quot;何
      
    
    </summary>
    
    
      <category term="Courses" scheme="https://jeremygo.cn/tags/Courses/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Nginx</title>
    <link href="https://jeremygo.cn/2018/05/29/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANginx/"/>
    <id>https://jeremygo.cn/2018/05/29/深入浅出Nginx/</id>
    <published>2018-05-29T11:31:26.000Z</published>
    <updated>2018-05-29T15:46:46.384Z</updated>
    
    <content type="html"><![CDATA[<p>之前在自己的阿里云服务器上部署了Nginx服务主要用作node服务的代理，这里看到一篇不错的文章简记一下~</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Nginx是一款轻量级的Web服务器及反向代理服务器，因为内存中占用少、启动极快、高并发能力强的原因，在互联网项目中广泛应用<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1frsgjbi5aej20j40e2aax.jpg" alt=""></p><blockquote><p>当下流行的技术架构，nginx有点像入口网关</p></blockquote><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><ul><li>平时我们使用梯子访问谷歌就是一个简单的正向代理的例子，正向代理“代理”的是客户端，客户端是知道目标的，但是目标不知道客户端是通过梯子访问的</li></ul><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ul><li>我们在外网访问百度时会进行一个转发代理到内网既是反向代理，反向代理“代理”的是服务器端，这一个过程对于客户端是透明的</li></ul><h3 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h3><p>启动Nginx后，就是在80端口启动了Socket服务进行监听，Nginx涉及Mater进程和Worker进程<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1frsg790v3mj20m503uaad.jpg" alt=""></p><h4 id="Mater进程作用"><a href="#Mater进程作用" class="headerlink" title="Mater进程作用"></a>Mater进程作用</h4><ul><li>读取并验证配置文件nginx.conf，管理worker进程</li></ul><h4 id="Worker进程作用"><a href="#Worker进程作用" class="headerlink" title="Worker进程作用"></a>Worker进程作用</h4><ul><li>Worker进程作用：每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数有关（有利于进程切换）</li></ul><h4 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h4><ul><li>热部署：配置文件nginx.conf修改以后不需要stop nginx中断请求，就能让配置文件生效<br>结合worker进程负责处理具体的请求：<ul><li>方案一：修改nginx.conf后，主进程master负责推送给worker进程更新配置信息，worker进程收到信息后更新进程内部的线程信息</li><li>方案二：修改nginx.conf后，重新生成新的worker进程，以新的配置进行处理请求，老的woker进程等它们的请求处理完毕后kill掉即可<br>nginx采用方案二实现热部署</li></ul></li></ul><h4 id="如何做到高并发下的高效处理"><a href="#如何做到高并发下的高效处理" class="headerlink" title="如何做到高并发下的高效处理"></a>如何做到高并发下的高效处理</h4><ul><li>上文已经提及nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，的确有助于效率但是不够。同时处理那么多请求的问题在于，有的请求需要发生IO，可能需要很长时间，如果等着它们，就会拖慢worker的处理速度<ul><li>nginx采用了Linux的epoll模型，这个模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。所以worker只需要从epoll队列循环处理即可</li></ul></li><li>nginx挂了怎么办：nginx作为入口网关，如果出现单点问题显然是不可接受的<ul><li>解决方案：Keepalived + Nginx</li><li>keepalived 是一个高可用解决方案，主要用来防止服务器单点发生故障，可以通过和nginx配合来实现Web服务的高可用</li><li>思路：<ul><li>请求不要直接打到nginx上，应该先通过Keepalived (虚拟IP)</li><li>Keepalived 应该能监控nginx的生命状态（提供一个用户自定义的脚本，定期检查nginx进程状态，进行权重变化，从而实现nginx故障切换）<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1frsgov5bh3j20jg07tdgl.jpg" alt=""></li></ul></li></ul></li></ul><h3 id="主战场：nginx-conf"><a href="#主战场：nginx-conf" class="headerlink" title="主战场：nginx.conf"></a>主战场：nginx.conf</h3><p>nginx.conf是典型的分段配置文件</p><h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><ul><li><img src="https://ws1.sinaimg.cn/large/e4336439gy1frsgrqy6tsj20ia080t8w.jpg" alt=""></li><li>把nginx作为web server来处理静态资源<ul><li>location可以进行正则匹配，注意正则的几种形式以及优先级</li><li>nginx能提高速度的其中一个特性：动静分离，把静态资源放到nginx上，由nginx管理，动态请求转发给后端</li><li>在nginx下将静态资源、日志文件归属到不同域名（目录）下，方便管理维护</li><li>nginx可以进行ip访问控制，如有些电商平台，在nginx这一层就做了处理，内置一个黑名单模块<h4 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h4></li></ul></li><li>在location这一段配置中的root替换成proxy_pass即可<ul><li>root说明是静态资源，可以由nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，如代理到Tomcat上</li><li>反向代理过程是透明的，比如在request-&gt;nginx-&gt;Tomcat这里对于Tomcat而言请求的ip就是nginx的地址而不是真实的request地址。好在nginx不仅仅可以反向代理请求，也可以由用户自定义设置HTTP HEADER<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4></li></ul></li><li>在反向代理中，通过proxy_pass来指定Tomcat的地址，这里只能指定一台Tomcat，如果想指定多台来达到负载均衡呢？<ul><li>通过 upstream 来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（nginx监控这一组Tomcat的状态）等</li><li>将proxy_pass换成upstream指定的值即可</li></ul></li><li>带来的问题：用户状态的保存问题，如session信息不能保存到服务器上</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>在配置上开启，同时指定目录，让缓存可以存储到磁盘上</li></ul><p>参考：<br><a href="http://blog.51cto.com/zhangfengzhe/2064524" target="_blank" rel="noopener">http://blog.51cto.com/zhangfengzhe/2064524</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在自己的阿里云服务器上部署了Nginx服务主要用作node服务的代理，这里看到一篇不错的文章简记一下~&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Nginx是一款轻
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flex-Grid布局</title>
    <link href="https://jeremygo.cn/2018/03/27/Flex-Grid%E5%B8%83%E5%B1%80/"/>
    <id>https://jeremygo.cn/2018/03/27/Flex-Grid布局/</id>
    <published>2018-03-27T10:07:42.000Z</published>
    <updated>2018-03-27T12:09:42.420Z</updated>
    
    <content type="html"><![CDATA[<p>关于Flex&amp;Grid布局的语法实例</p><h4 id="Flex：更简洁制作智能布局的现代语法"><a href="#Flex：更简洁制作智能布局的现代语法" class="headerlink" title="Flex：更简洁制作智能布局的现代语法"></a>Flex：更简洁制作智能布局的现代语法</h4><ul><li>w3c于09年提出的一个新的布局方案，可以方便地实现各种页面布局</li><li>移动端开发的主流：H5页面、微信小程序</li></ul><p>对比：实现子元素在父元素水平垂直居中的效果<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1fprjjpytkgj208y06ydfp.jpg" alt=""><br>传统定位方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.dad &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    margin: auto;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.par &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 500px;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    background-color: blue;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方案都需要同时对父元素与子元素设置定位</p><p>弹性盒：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.par &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 500px;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    background-color: blue;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>语法详解：<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1fprjpsv61zj208j07cq35.jpg" alt=""><br>初始概念：主轴/纵轴(flex-direction)：默认为row：从左到右、水平排列<br>                                        column：从上到下、竖直排列<br>开始：Flex容器：父元素显式设置：display: flex<br>     Flex项目：Flex容器内的子元素<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1fprjtm573xj20fe07ftam.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/e4336439gy1fprjtywr0pj20fe07ddhl.jpg" alt=""><br>实例—简易导航系统的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// css部分参考</span><br><span class="line">html, body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">nav &#123;</span><br><span class="line">    height: 80px;</span><br><span class="line">    background-color: #646262;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-grow: 1</span><br><span class="line">&#125;</span><br><span class="line">ul li &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: white;</span><br><span class="line">&#125;</span><br><span class="line">ul li:nth-child(1) &#123;</span><br><span class="line">    margin-left: auto;</span><br><span class="line">&#125;</span><br><span class="line">ul button &#123;</span><br><span class="line">    margin-right: auto;</span><br><span class="line">    margin-left: 5%;</span><br><span class="line">    width: 70px;</span><br><span class="line">    color: white;</span><br><span class="line">    font-size: 1em;</span><br><span class="line">    background-color: #50cd50;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">ul button:hover &#123;</span><br><span class="line">    background-color: green;</span><br><span class="line">    transition: all .5s ease;</span><br><span class="line">&#125;</span><br><span class="line">img &#123;</span><br><span class="line">    width: 20%;</span><br><span class="line">    margin-left: 5%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实例二—自适应的导航栏<br>关键：搜索框自动填满导航栏剩余的位置<br>实现：.search的属性设为flex: 1(flex-grow、flex-shrink、flex-basis的缩写)<br>扩展：媒体查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@media all and (max-width: 600px) &#123;</span><br><span class="line">    .container &#123;</span><br><span class="line">        flex-wrap: wrap;</span><br><span class="line">    &#125;</span><br><span class="line">    .container &gt; li &#123;</span><br><span class="line">        flex: 1 1 50%;</span><br><span class="line">    &#125;</span><br><span class="line">    .search-input &#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media all and (max-width: 400px) &#123;</span><br><span class="line">    .container &gt; li &#123;</span><br><span class="line">        flex: 1 1 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .search-input &#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .search &#123;</span><br><span class="line">        order: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Grid：-CSS布局的未来"><a href="#Grid：-CSS布局的未来" class="headerlink" title="Grid： CSS布局的未来"></a>Grid： CSS布局的未来</h4><ul><li>二维布局</li><li>基本概念：<ul><li>网格线：分界线构成了网格的结构</li><li>网格轨道：两个相邻网格线之间的空间</li><li>网格单元格：两个相邻行与相邻列之间的网格线空间</li><li>网格区域：由任意数量的网格单元格组成</li></ul></li><li>网格容器属性：<ul><li>grid-template-columns/row：利用空格分隔的值定义网格的列与行</li><li>grid-template-areas：定义网格区域名称，从而定义网格模板</li><li>grid-(column/row)-gap：指定网格线的大小，即行列之间的宽度</li><li>justify/align-content/items：沿列/行轴对齐网格项的内容/网格</li></ul></li><li>网格项属性：<ul><li>grid-column/row：使用特定的网格线确定网格项在网格中的位置</li><li>grid-area：对应网格模板给网格项命名</li><li>justify/align-self：沿列/行轴对应网格项中的内容</li></ul></li><li>实例：自适应的首页布局：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: 1fr 5fr;</span><br><span class="line">    grid-template-rows: 100px auto 100px;</span><br><span class="line">&#125;</span><br><span class="line">.header &#123;</span><br><span class="line">    grid-column: 1 / -1;</span><br><span class="line">&#125;</span><br><span class="line">.menu &#123;</span><br><span class="line">    grid-row: 2 / 3;</span><br><span class="line">&#125;</span><br><span class="line">.content &#123;</span><br><span class="line">    grid-column: 2 / -1;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">    grid-column: 1 / -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a><br><a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html</a><br><a href="https://www.w3cplus.com/css3/a-complete-guide-css-grid-layout.html" target="_blank" rel="noopener">https://www.w3cplus.com/css3/a-complete-guide-css-grid-layout.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于Flex&amp;amp;Grid布局的语法实例&lt;/p&gt;
&lt;h4 id=&quot;Flex：更简洁制作智能布局的现代语法&quot;&gt;&lt;a href=&quot;#Flex：更简洁制作智能布局的现代语法&quot; class=&quot;headerlink&quot; title=&quot;Flex：更简洁制作智能布局的现代语法&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTML5&amp;CSS3关键点</title>
    <link href="https://jeremygo.cn/2018/03/13/HTML5-CSS3%E5%85%B3%E9%94%AE%E7%82%B9/"/>
    <id>https://jeremygo.cn/2018/03/13/HTML5-CSS3关键点/</id>
    <published>2018-03-13T12:40:27.000Z</published>
    <updated>2018-03-27T10:01:41.281Z</updated>
    
    <content type="html"><![CDATA[<p>工作室第七期培训第二课主讲了关于前端三大基础的知识，重点落在HTML5与CSS3上，这里做一个记录，类似的知识以后不断更新~</p><p>HTML:</p><ul><li>DOM树：浏览器解析HTML文本的形式，树上的所有节点都可以通过js访问</li><li>元素类型： 块级元素与行内元素的区别<ul><li>区别一：块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。<br>区别二：块级：块级元素可以设置宽高行内：行内元素不可以设置宽高<br>区别三：块级：块级元素可以设置margin，padding行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。<br>区别四：块级：display:block;行内：display:inline;可以通过修改display属性来切换块级元素和行内元素</li></ul></li><li>语义化：用正确的标签做正确的事情，不仅仅让浏览器易于理解与搜索引擎解析，也要让人易于阅读</li></ul><p>CSS：</p><ul><li>盒模型： box-sizing设置盒模型宽度的计算规则，一般设置成border-box（IE传统盒模型）</li><li>浮动： 脱离文档流，浮动后横向排列，浮动元素总是保证自己的顶部和上一个元素（标准流中的）的底部对齐；clear只能影响使用清除的元素本身</li><li>扩展：BFC（块级格式化上下文）<ul><li>浮动与清除浮动只会应用于同一个BFC内的元素</li><li>计算BFC的高度时，浮动元素也会参与计算（浮动元素的父元素高度塌陷问题）</li></ul></li><li>定位：absolute: 根据最近设置定位的祖先元素排列</li><li><p>怎样居中一个div：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 传统方案：position + transform</span><br><span class="line">    .par &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .child &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%, -50%);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 弹性盒（考虑兼容性）：flex</span><br><span class="line">    .par &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .child &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作室第七期培训第二课主讲了关于前端三大基础的知识，重点落在HTML5与CSS3上，这里做一个记录，类似的知识以后不断更新~&lt;/p&gt;
&lt;p&gt;HTML:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM树：浏览器解析HTML文本的形式，树上的所有节点都可以通过js访问&lt;/li&gt;
&lt;li&gt;元素
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Js基础笔记</title>
    <link href="https://jeremygo.cn/2018/03/04/Js%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>https://jeremygo.cn/2018/03/04/Js基础笔记/</id>
    <published>2018-03-04T13:42:07.000Z</published>
    <updated>2018-03-04T14:16:02.474Z</updated>
    
    <content type="html"><![CDATA[<p>Github关于js面试题的知识整理，这里慢慢积累~</p><h3 id="解释事件委托"><a href="#解释事件委托" class="headerlink" title="解释事件委托"></a>解释事件委托</h3><p>事件委托是一种利用事件冒泡机制，只监听父元素而不用监听每个子元素的技术。</p><p>优点：只有父元素需要一个监听器，不需要每个子元素都去监听，减少了内存占用</p><p>​       避免了对子元素的繁杂处理，可以只针对父元素进行处理</p><p>例子：</p><ul><li>e.target 点击元素</li><li>e.currentTarget 当前元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    #par &#123;</span><br><span class="line">      background: blue;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 600px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;par&quot;&gt;</span><br><span class="line">      &lt;div id=&quot;child1&quot;&gt;Item 1&lt;/div&gt;</span><br><span class="line">      &lt;div id=&quot;child2&quot;&gt;Item 2&lt;/div&gt;</span><br><span class="line">      &lt;div id=&quot;child3&quot;&gt;Item 3&lt;/div&gt;</span><br><span class="line">      &lt;div id=&quot;child4&quot;&gt;Item 4&lt;/div&gt;</span><br><span class="line">      &lt;div id=&quot;child5&quot;&gt;Item 5&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.getElementById(&quot;par&quot;)</span><br><span class="line">            .addEventListener(&quot;click&quot;, function(e) &#123;</span><br><span class="line">              console.log(e.target);</span><br><span class="line">              console.log(e.currentTarget);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="解释js中的this如何工作"><a href="#解释js中的this如何工作" class="headerlink" title="解释js中的this如何工作"></a>解释js中的this如何工作</h3><p>关键：this的值取决于函数怎样被调用</p><ul><li><p>使用了 <code>new</code> ，则 <code>this</code> 指向函数内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Constructor() &#123;</span><br><span class="line">   console.log(this);</span><br><span class="line">   this.value = 10;</span><br><span class="line">   console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Constructor();</span><br><span class="line">// Constructor&#123;&#125;</span><br><span class="line">// Constructor&#123;value: 10&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用了 <code>apply</code> <code>call</code> 或 <code>bind</code>  , <code>this</code> 指向作为参数传入的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    value: 5</span><br><span class="line">&#125;;</span><br><span class="line">var boundFn = fn.bind(obj);</span><br><span class="line">boundFn();     // -&gt; &#123; value: 5 &#125;  // 这里bind只是作为定义绑定了this</span><br><span class="line">fn.call(obj);  // -&gt; &#123; value: 5 &#125;</span><br><span class="line">fn.apply(obj); // -&gt; &#123; value: 5 &#125;</span><br></pre></td></tr></table></figure></li><li><p>作为方法调用，如 <code>obj.method()</code>，<code>this</code> 指向这个函数属性的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    value: 5,</span><br><span class="line">    printThis: function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.printThis(); // -&gt; &#123; value: 5, printThis: ƒ &#125;</span><br></pre></td></tr></table></figure></li><li><p>以上都没有，则 <code>this</code> 指向全局对象即 window，在严格模式下是undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">fn(); // -&gt; Window &#123;stop: ƒ, open: ƒ, alert: ƒ, ...&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上两种以上方式，则优先级更高的规则决定 <code>this</code> 的值</p></li><li><p>ES6箭头函数中，this 指向函数创建时作用域的值，忽略以上所有规则</p></li></ul><p>扩展：<a href="https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3" target="_blank" rel="noopener">this</a></p><h3 id="解释原型继承如何工作"><a href="#解释原型继承如何工作" class="headerlink" title="解释原型继承如何工作"></a>解释原型继承如何工作</h3><p>所有的js对象都有一个 <code>prototype</code> 属性，指向这个对象的原型对象</p><ul><li>当一个属性被访问时，如果直接存在这个对象中则输出</li><li>如果不存在这个对象中则通过原型链去找它的原型对象，直到找到这个属性或者原型链末端</li><li>这个机制模拟了经典的继承但实际上更像是委托</li></ul><h3 id="对于AMD和CommonJS如何认识"><a href="#对于AMD和CommonJS如何认识" class="headerlink" title="对于AMD和CommonJS如何认识"></a>对于AMD和CommonJS如何认识</h3><p>两种方式都是用来实现模块系统，这个概念直到ES6才在js中出现</p><ul><li>CommonJS是同步的，为了服务端开发而设计，语法更接近于其它语言的风格，同时使用服务器端与浏览器端开发之间js切换开销也更小</li><li>AMD是异步的，支持异步加载模块，更像是为了浏览器端开发而设计，但是语法风格冗杂，而且大部分时候不是必要的，特别是js只放在一个模块包时</li><li>ES6中支持同步与异步加载模块，使得我们可以坚持用一种方法，虽然现在并没有在浏览器与Node端完全展开，但我们可以使用转换程序来转换代码</li></ul><h3 id="解释function-foo-为什么没有像IIFE一样工作，需要修改哪些内容才能使它成为一个IIFE"><a href="#解释function-foo-为什么没有像IIFE一样工作，需要修改哪些内容才能使它成为一个IIFE" class="headerlink" title="解释function foo(){}() 为什么没有像IIFE一样工作，需要修改哪些内容才能使它成为一个IIFE"></a>解释<code>function foo(){}()</code> 为什么没有像IIFE一样工作，需要修改哪些内容才能使它成为一个IIFE</h3><p>IIFE 的含义是立即执行函数表达式，js解析器读取 <code>function foo(){}()</code> 成 <code>function foo(){}</code> 和 <code>()</code> ，前者是一个函数声明而后者是一个括号尝试调用一个函数但是并没有特别声明，因此会报错</p><ul><li>修改：<code>(function foo() {})()</code>  or <code>(function foo() {}())</code>  它们不会在全局范围内公开，所以我们甚至可以省略 <code>foo</code> </li></ul><h3 id="null-undefined-undeclared-之间的区别，怎样检查它们"><a href="#null-undefined-undeclared-之间的区别，怎样检查它们" class="headerlink" title="null  undefined  undeclared 之间的区别，怎样检查它们"></a><code>null</code>  <code>undefined</code>  <code>undeclared</code> 之间的区别，怎样检查它们</h3><ul><li><p><code>undeclared</code> 变量是创建一个变量赋值时没有使用 <code>var</code> <code>let</code> 或 <code>const</code> ，这会导致它成为一个全局变量，在严格模式下会报 <code>ReferenceError</code> ，所以尽量避免使用，可以将它放入 try/catch块中检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  x = 1; // Throws a ReferenceError in strict mode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">console.log(x); // 1</span><br></pre></td></tr></table></figure></li><li><p><code>undefined</code> 变量是已经被 <code>declared</code> 但是没有赋值，如果一个函数没有任何返回值也是 <code>undefined</code> ，可以使用 <code>===</code> 或者 <code>typeof</code> 去检查，如果使用 <code>==</code> 检查则 <code>null</code> 也会返回 <code>true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo;</span><br><span class="line">console.log(foo); // undefined</span><br><span class="line">console.log(foo === undefined); // true</span><br><span class="line">console.log(typeof foo === &apos;undefined&apos;); // true</span><br><span class="line"></span><br><span class="line">console.log(foo == null); // true. Wrong, don&apos;t use this to check!</span><br><span class="line"></span><br><span class="line">function bar() &#123;&#125;</span><br><span class="line">var baz = bar();</span><br><span class="line">console.log(baz); // undefined</span><br></pre></td></tr></table></figure></li><li><p><code>null</code> 变量是明确地被赋值为 <code>null</code> 的变量，代表没有值（与<code>undefined</code>不同）,使用 typeof 检查返回 object,  同样必须使用 <code>===</code>  比较检查，否则 <code>undefined</code> 也会返回 <code>true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var foo = null;</span><br><span class="line">console.log(foo === null); // true</span><br><span class="line"></span><br><span class="line">console.log(foo == undefined); // true. Wrong, don&apos;t use this to check!</span><br></pre></td></tr></table></figure></li></ul><h3 id="解释闭包，如何使用"><a href="#解释闭包，如何使用" class="headerlink" title="解释闭包，如何使用"></a>解释闭包，如何使用</h3><p>闭包是函数与函数声明时词法作用域的结合，词法的意思是词汇范围界定使用在源代码声明变量的位置来确定变量的位置(?)，闭包就是在外部函数返回以后也可以访问外部函数中变量作用域链的函数</p><p>使用场景：</p><ul><li><p>用闭包实现数据隐私或是模拟private方法，模块模式中经常用到</p></li><li><p>部分应用程序嵌套调用的场合</p><p>​</p></li></ul><h3 id="描述-forEach-和-map-循环的区别，如何抉择"><a href="#描述-forEach-和-map-循环的区别，如何抉择" class="headerlink" title="描述 forEach 和 map 循环的区别，如何抉择"></a>描述 <code>forEach</code> 和 <code>map</code> 循环的区别，如何抉择</h3><p>forEach</p><ul><li><p>遍历数组中的所有元素</p></li><li><p>每个元素都执行回调函数</p></li><li><p>没有返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a = [1, 2, 3];</span><br><span class="line">const doubled = a.forEach((num, index) =&gt; &#123;</span><br><span class="line">  // Do something with num and/or index.</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// doubled = undefined</span><br></pre></td></tr></table></figure></li></ul><p>map</p><ul><li><p>遍历数组中的所有元素</p></li><li><p>每个元素都执行回调函数返回一个新元素，最终结果返回一个新数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a = [1, 2, 3];</span><br><span class="line">const doubled = a.map(num =&gt; &#123;</span><br><span class="line">  return num * 2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// doubled = [2, 4, 6]</span><br></pre></td></tr></table></figure></li></ul><p>主要区别：map 返回一个新数组而 forEach 不返回，即如果需要不影响原有数组的结果使用 map 更好，如果不在意原有数组的影响可以使用forEach</p><p>扩展：</p><p>filter</p><ul><li><p>遍历数组所有元素</p></li><li><p>每个元素执行回调函数做判断，true保留，false取出，最终返回一个过滤的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ages = data.filter((animal) =&gt; &#123;</span><br><span class="line">  return animal.type === &apos;dog&apos;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>reduce</p><ul><li><p>遍历数组所有元素</p></li><li><p>每个元素执行回调函数，至少接收两个参数，专为累加这类操作而设计，最终返回一个相加的总和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.reduce((sum, animal) =&gt; &#123;</span><br><span class="line">  return sum + animal.age;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>扩展阅读：<a href="https://codeburst.io/javascript-learn-to-chain-map-filter-and-reduce-acd2d0562cd4" target="_blank" rel="noopener">map、filter、reduce</a></p><h3 id="匿名函数的典例"><a href="#匿名函数的典例" class="headerlink" title="匿名函数的典例"></a>匿名函数的典例</h3><ul><li><p>IIFE，避免变量泄露到全局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    // some code.</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>一次性使用的回调，在调用它们的代码内部进行声明时会更具有可读与自包含性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&quot;hei&quot;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></li><li><p>函数式编程或者Loadsh的参数（类似于回调）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">const double = arr.map(funtion(e) &#123;</span><br><span class="line">    return e*2;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(double);</span><br></pre></td></tr></table></figure></li></ul><h3 id="怎样组织自己的代码，比如模块模式或者经典继承"><a href="#怎样组织自己的代码，比如模块模式或者经典继承" class="headerlink" title="怎样组织自己的代码，比如模块模式或者经典继承"></a>怎样组织自己的代码，比如模块模式或者经典继承</h3><p>一开始会使用面向对象的方式创建Backbobe模型并添加方法</p><p>但现在更好的趋势是使用基于React/Redux鼓励单向函数编程方式的Flux体系结构，使用普通对象与编写实用纯函数来操作这些对象，并且使用 actions 和 reducers 来处理状态</p><p>关于经典继承的扩展阅读  <a href="https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4" target="_blank" rel="noopener">new rules</a></p><p>后续学深入再重新理解这个问题 ==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Github关于js面试题的知识整理，这里慢慢积累~&lt;/p&gt;
&lt;h3 id=&quot;解释事件委托&quot;&gt;&lt;a href=&quot;#解释事件委托&quot; class=&quot;headerlink&quot; title=&quot;解释事件委托&quot;&gt;&lt;/a&gt;解释事件委托&lt;/h3&gt;&lt;p&gt;事件委托是一种利用事件冒泡机制，只监听父
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://jeremygo.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP5博客搭建知识汇总</title>
    <link href="https://jeremygo.cn/2018/02/26/ThinkPHP5%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>https://jeremygo.cn/2018/02/26/ThinkPHP5博客搭建知识汇总/</id>
    <published>2018-02-26T08:11:40.000Z</published>
    <updated>2018-02-26T09:11:25.566Z</updated>
    
    <content type="html"><![CDATA[<p>工作室第七期培训后期主要以TP5搭建个人博客为主，这里将需要用到的知识笔记做个整理再加一些<br>扩展~</p><p>ThinkPHP的核心就是MVC思想：</p><ul><li>Controller： 控制器，整个应用逻辑交互的处理</li><li>Model：模型，数据库操作的逻辑处理</li><li>View：视图，页面数据的呈现</li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="新建控制器"><a href="#新建控制器" class="headerlink" title="新建控制器"></a>新建控制器</h4><ul><li><p>前台控制器目录下（application/index/controller）新建控制器文件User.php</p></li><li><p>书写User.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">  // 声明命名空间</span><br><span class="line">  namespace app\index\controller;</span><br><span class="line">  // 声明控制器</span><br><span class="line">  class User &#123;</span><br><span class="line">        public function index() &#123;</span><br><span class="line">            return &quot;User控制器下的index方法&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li><li><p>地址栏访问：域名/index.php/index/User/index</p></li><li><p>注意：</p><ul><li>控制器文件名必须首字母大写，驼峰式命名</li><li>控制器名必须跟文件名一一对应</li><li>命名空间必须和文件名对应</li><li><p>如果控制器名为驼峰式 UserInfo.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">域名/index.php/index/user_info/index</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="控制器如何加载页面"><a href="#控制器如何加载页面" class="headerlink" title="控制器如何加载页面"></a>控制器如何加载页面</h4><ul><li><p>系统View类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$view = new \think\View;</span><br><span class="line">return $view-&gt;fetch();</span><br><span class="line"></span><br><span class="line">use think\View;</span><br><span class="line">$view = new View();</span><br><span class="line">return $view-&gt;fetch();</span><br></pre></td></tr></table></figure></li><li><p>系统Controller类</p><ul><li><p>继承系统控制器类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use think\Controller;</span><br><span class="line">class User extends Controller</span><br></pre></td></tr></table></figure></li><li><p>直接使用系统控制器类的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return $this-&gt;fetch();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>系统函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return view();</span><br></pre></td></tr></table></figure></li></ul><h4 id="控制器的初始化"><a href="#控制器的初始化" class="headerlink" title="控制器的初始化"></a>控制器的初始化</h4><ul><li><p>初始化方法必须继承系统控制器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public function _initialize() &#123;</span><br><span class="line">    echo &quot;初始化方法&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只要调用控制器下的任意方法，都会先找初始化方法</p></li><li>控制器初始化方法的使用<ul><li>用来提取控制器下公共的代码</li><li>后台权限把控</li></ul></li></ul><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><ul><li>页面跳转基于系统控制器类，所以控制器必须继承系统控制器</li><li><p>方法所在路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www/tp5/thinkphp/library/traits/controller/Jump.php</span><br></pre></td></tr></table></figure></li><li><p>跳转方式</p><ul><li><p>成功跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// $this-&gt;success(提示信息,跳转地址,用户自定义数据,跳转跳转,header信息);</span><br><span class="line">// 跳转地址未设置时 默认返回上一个页面</span><br><span class="line">$this-&gt;success(&apos;跳转成功&apos;,url(&apos;index/index&apos;));</span><br></pre></td></tr></table></figure></li><li><p>失败跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;error(&apos;跳转失败&apos;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>跳转方法给模板页面的数据</p><ul><li>$code 返回的状态码  1  0 </li><li>$msg  页面提示信息</li><li>$wait  等待时间</li><li>$url     指定跳转页面，默认返回上一个页面</li><li>$data   用户自定义返回的数据</li></ul></li><li><p>相关配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 默认跳转页面对应的模板文件</span><br><span class="line">&apos;dispatch_success_tmpl&apos;  =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_jump.tpl&apos;,</span><br><span class="line">&apos;dispatch_error_tmpl&apos;    =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_jump.tpl&apos;,</span><br></pre></td></tr></table></figure></li><li><p>修改成功、失败的模板页面</p><ul><li>文件目录：<code>www/tp5/thinkphp/tpl/dispatch_jump.tpl</code><ul><li>修改成功、失败模板页面</li></ul></li><li><p>用户自定义页面跳转模板</p><ul><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 默认跳转页面对应的模板文件</span><br><span class="line">&apos;dispatch_success_tmpl&apos;  =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;success.tpl&apos;,</span><br><span class="line">&apos;dispatch_error_tmpl&apos;    =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;error.tpl&apos;,</span><br></pre></td></tr></table></figure></li><li><p>在tpl目录下新建 success.tpl 和 error.tpl 模板</p></li><li>自定义书写跳转页面</li></ul></li></ul></li></ul><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><ul><li>作用：重定向(Redirect)就是通过各种方法将各种网络请求重新定向到其它位置</li><li>使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redirect(&apos;跳转地址&apos;, &apos;其他参数&apos;, code, &apos;隐式参数&apos;);</span><br><span class="line">$this-&gt;redirect(&apos;index/index&apos;, [&apos;id&apos;=&gt;100, &apos;name&apos;=&gt;&apos;abc&apos;]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="空操作和空控制器"><a href="#空操作和空控制器" class="headerlink" title="空操作和空控制器"></a>空操作和空控制器</h4><ul><li><p>空操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主要解决一些用户恶意的地址栏输入，导致报错影响交互</span><br><span class="line">public function _empty() &#123;</span><br><span class="line">    $this-&gt;redirect(&apos;index/index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>空控制器：controller目录下新建Error.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace app\index\controller;</span><br><span class="line">use think\Controller;</span><br><span class="line"></span><br><span class="line">class Error extends Controller &#123;</span><br><span class="line">    public function index() &#123;</span><br><span class="line">        $this-&gt;redirect(&apos;index/index&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function _empty() &#123;</span><br><span class="line">        $this-&gt;redirect(&apos;index/index&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ul><li>网站上线时每一个控制器都必须添加空操作</li><li>不论前台后台都需要写一个空控制器</li></ul></li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="新建数据模型"><a href="#新建数据模型" class="headerlink" title="新建数据模型"></a>新建数据模型</h4><ul><li>手动新建<ul><li>打开前台模块（www/tp5/application/index） 新建model目录</li><li>在model目录下新建User.php</li></ul></li><li><p>命令新建</p><ul><li>切换到项目目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php think make:model app\index\model\Users</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意</p><ul><li>数据模型的名字建议和表名一致</li><li><p>如果表名与模型名不一致，可以设置表名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected $table = &quot;user&quot;;</span><br></pre></td></tr></table></figure></li><li><p>如果表名有下划线，模型名使用驼峰法命名</p></li></ul></li></ul><h4 id="模型的实例化"><a href="#模型的实例化" class="headerlink" title="模型的实例化"></a>模型的实例化</h4><ul><li><p>调用静态方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use app\index\model\User;</span><br><span class="line">$res=User::get(1);</span><br><span class="line">dump($res-&gt;toArray());</span><br></pre></td></tr></table></figure></li><li><p>实例化数据模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$user=new \app\index\model\User();</span><br><span class="line">$res=$user::get(2);</span><br><span class="line">dump($res-&gt;toArray());</span><br></pre></td></tr></table></figure></li><li><p>使用loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use think\Loader;</span><br><span class="line"></span><br><span class="line">$user=Loader::model(&quot;user&quot;);</span><br><span class="line">$res=$user::get(3);</span><br><span class="line">dump($res-&gt;toArray());</span><br></pre></td></tr></table></figure></li><li><p>使用助手函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$user=model(&quot;user&quot;);</span><br><span class="line">$res=$user::get(4);</span><br><span class="line">dump($res-&gt;toArray());</span><br></pre></td></tr></table></figure></li></ul><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><ul><li><p>单条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// get方法</span><br><span class="line">  // 使用数字</span><br><span class="line">  $res=User::get(1); // 默认主键</span><br><span class="line">  // 使用数组</span><br><span class="line">  $res=User::get([&quot;name&quot;=&gt;&apos;zgg&apos;]);  // 默认查找用户名</span><br><span class="line">  // 使用闭包函数</span><br><span class="line">  $res=User::get(function($query)&#123;</span><br><span class="line">      $query-&gt;where(&quot;id&quot;,15);</span><br><span class="line">  &#125;);</span><br><span class="line">// find方法</span><br><span class="line">  $res=User::where(&quot;id&quot;,13)-&gt;find();</span><br></pre></td></tr></table></figure></li><li><p>多条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// all</span><br><span class="line">  // 所有数据</span><br><span class="line">  $res=User::all();</span><br><span class="line">  // 字符串</span><br><span class="line">  $res=User::all(&quot;1,2,3&quot;);</span><br><span class="line">  // 数组</span><br><span class="line">  $res=User::all([5,6,7]);</span><br><span class="line">  // 数组</span><br><span class="line">  $res=User::all([&apos;pass&apos;=&gt;&apos;123&apos;]);</span><br><span class="line">  // 闭包</span><br><span class="line">  $res=User::all(function($query)&#123;</span><br><span class="line">      $query-&gt;where(&quot;pass&quot;,&quot;123&quot;)</span><br><span class="line">          -&gt;whereOr(&quot;pass&quot;,&quot;456&quot;)</span><br><span class="line">          -&gt;order(&quot;id&quot;,&quot;desc&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">// select 和 all 基本类似</span><br><span class="line">  $res=User::select();</span><br><span class="line">  $res=User::limit(2)-&gt;select();</span><br></pre></td></tr></table></figure></li><li><p>获取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取某个值</span><br><span class="line">$res=User::where(&quot;id&quot;,5)-&gt;value(&quot;name&quot;);</span><br><span class="line">// 获取某列值</span><br><span class="line">$res=User::column(&quot;name&quot;,&quot;id&quot;);</span><br></pre></td></tr></table></figure></li><li><p>动态查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// getBy字段名, 查询出第一条数据</span><br><span class="line">$res = User::getByName(&quot;user&quot;);</span><br><span class="line">dump($res-&gt;toArray());</span><br></pre></td></tr></table></figure></li></ul><h4 id="增加操作"><a href="#增加操作" class="headerlink" title="增加操作"></a>增加操作</h4><ul><li><p>设置属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置属性</span><br><span class="line">$user = new User();</span><br><span class="line">$user-&gt;name = &quot;user&quot;;</span><br><span class="line">$user-&gt;pass = 13;</span><br><span class="line">$user-&gt;age  = 22;</span><br><span class="line">$user-&gt;save(); // 返回影响行数</span><br></pre></td></tr></table></figure></li><li><p>通过data方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$user=new User();</span><br><span class="line">$user-&gt;data([</span><br><span class="line">  &quot;name&quot;=&gt;&quot;yzmedu22&quot;,</span><br><span class="line">  &quot;age&quot;=&gt;&quot;22&quot;,</span><br><span class="line">  &quot;pass&quot;=&gt;&quot;qwe&quot;,</span><br><span class="line">  ]);</span><br><span class="line">$user-&gt;save(); // 返回影响行数</span><br></pre></td></tr></table></figure></li><li><p>实例化时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$user=new User([</span><br><span class="line">  &quot;name&quot;=&gt;&quot;yzmedu23&quot;,</span><br><span class="line">  &quot;pass&quot;=&gt;&apos;zxc&apos;,</span><br><span class="line">  &quot;age&quot;=&gt;20</span><br><span class="line">  ]);</span><br><span class="line">// 返回影响行数</span><br><span class="line">$user-&gt;save();</span><br><span class="line">// allowField 屏蔽掉数据库中不存在的字段</span><br><span class="line">$user-&gt;allowField(true)-&gt;save();</span><br><span class="line">// 指定插入数据库的字段</span><br><span class="line">$user-&gt;allowField([&apos;name&apos;,&apos;age&apos;])-&gt;save();</span><br></pre></td></tr></table></figure></li><li><p>获取自增的id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump($user-&gt;id);</span><br></pre></td></tr></table></figure></li><li><p>增加多条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$user=new User();</span><br><span class="line">$list=[</span><br><span class="line">  [&apos;name&apos;=&gt;&quot;yzmedu33&quot;,&quot;age&quot;=&gt;33],</span><br><span class="line">  [&apos;name&apos;=&gt;&quot;yzmedu34&quot;,&quot;age&quot;=&gt;34]</span><br><span class="line">];</span><br><span class="line">$user-&gt;saveAll($list);</span><br></pre></td></tr></table></figure></li><li><p>create方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$user=User::create([</span><br><span class="line">  &quot;name&quot;=&gt;&quot;yzmedu35&quot;,</span><br><span class="line">  &quot;age&quot;=&gt;35</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// $user=User::get(1);</span><br><span class="line">// 返回影响行数</span><br><span class="line">// dump($user-&gt;delete());</span><br><span class="line"></span><br><span class="line">// 删除主键2</span><br><span class="line">$user=User::destroy(2);</span><br><span class="line"></span><br><span class="line">// 删除主键3,4,5</span><br><span class="line">$user=User::destroy(&quot;3,4,5&quot;);</span><br><span class="line">$user=User::destroy([6,7,8]);</span><br><span class="line"></span><br><span class="line">// 删除name</span><br><span class="line">$user=User::destroy([&apos;name&apos;=&gt;&quot;yzmedu23&quot;]);</span><br><span class="line"></span><br><span class="line">// 删除多个条件</span><br><span class="line">$user=User::destroy([&apos;name&apos;=&gt;&apos;yzmedu33&apos;,&apos;age&apos;=&gt;33]);</span><br><span class="line"></span><br><span class="line">// 使用闭包</span><br><span class="line">$user=User::destroy(function($query)&#123;</span><br><span class="line">    $query-&gt;where(&quot;id&quot;,&quot;&lt;&quot;,&quot;15&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 删除数据</span><br><span class="line">$user=User::where(&quot;id&quot;,&quot;&gt;&quot;,&quot;19&quot;)-&gt;delete();</span><br><span class="line">dump($user);</span><br></pre></td></tr></table></figure><h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 设置字段更新数据</span><br><span class="line">    $user=User::get(15);</span><br><span class="line">    $user-&gt;age=19;</span><br><span class="line">    $res=$user-&gt;save();</span><br><span class="line">    </span><br><span class="line">// 直接数组修改</span><br><span class="line">    $user=new User;</span><br><span class="line">    $res=$user-&gt;save(</span><br><span class="line">        [</span><br><span class="line">            &quot;pass&quot;=&gt;&quot;qweasd&quot;,</span><br><span class="line">            &quot;age&quot;=&gt;16,</span><br><span class="line">            </span><br><span class="line">        ],[&quot;id&quot;=&gt;16]);</span><br><span class="line">        </span><br><span class="line">// 修改数据</span><br><span class="line">    $_POST[&apos;name&apos;]=&quot;yzmedu55&quot;;</span><br><span class="line">    $_POST[&apos;pass&apos;]=&quot;pass55&quot;;</span><br><span class="line">    $_POST[&apos;age&apos;]=&quot;55&quot;;</span><br><span class="line">    $_POST[&apos;sex&apos;]=&quot;nan&quot;;</span><br><span class="line">    $_POST[&apos;id&apos;]=17;</span><br><span class="line">    $user=new User;</span><br><span class="line">    $res=$user-&gt;allowField([&apos;name&apos;,&apos;pass&apos;,&apos;age&apos;])-&gt;save($_POST,[&apos;id&apos;=&gt;17]);</span><br><span class="line">    </span><br><span class="line">// 批量更新</span><br><span class="line">    $data=[</span><br><span class="line">        [&apos;id&apos;=&gt;15,&apos;name&apos;=&gt;&quot;abc&quot;,&apos;pass&apos;=&gt;456],</span><br><span class="line">        [&apos;id&apos;=&gt;17,&apos;name&apos;=&gt;&quot;abc&quot;,&apos;pass&apos;=&gt;456],</span><br><span class="line">    ];</span><br><span class="line">    $user=new User;</span><br><span class="line">    $res=$user-&gt;saveAll($data);</span><br><span class="line">    echo User::getLastSql();</span><br><span class="line">    </span><br><span class="line">// 更新操作</span><br><span class="line">    $user=new User;</span><br><span class="line">    $res=$user-&gt;where(&quot;id&quot;,&apos;&gt;&apos;,&apos;17&apos;)-&gt;update([&apos;age&apos;=&gt;18]);</span><br><span class="line">    $res=User::where(&quot;id&quot;,&quot;&lt;&quot;,&quot;18&quot;)-&gt;update([&apos;pass&apos;=&gt;&apos;zxc&apos;]);</span><br><span class="line">    </span><br><span class="line">// 闭包更新数据</span><br><span class="line">    $user=new User;</span><br><span class="line">    $res=$user-&gt;save([&apos;name&apos;=&gt;&apos;yunzhimeng&apos;],function($query)&#123;</span><br><span class="line">        $query-&gt;where(&quot;id&quot;,&quot;15&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 统计数据条数</span><br><span class="line">$tot=User::count();</span><br><span class="line">dump($tot);</span><br><span class="line"></span><br><span class="line">// 条件判断</span><br><span class="line">$tot=User::where(&quot;age&quot;,&quot;&gt;&quot;,18)-&gt;count();</span><br><span class="line">dump($tot);</span><br><span class="line"></span><br><span class="line">// 统计最大值</span><br><span class="line">$max=User::max(&apos;age&apos;);</span><br><span class="line">dump($max);</span><br><span class="line"></span><br><span class="line">// 统计最小值</span><br><span class="line">$min=User::min(&quot;age&quot;);</span><br><span class="line">dump($min);</span><br><span class="line"></span><br><span class="line">// 平均值</span><br><span class="line">$avg=User::avg(&apos;age&apos;);</span><br><span class="line">dump($avg);</span><br><span class="line"></span><br><span class="line">// 求和</span><br><span class="line">$sum=User::sum(&apos;age&apos;);</span><br><span class="line">dump($sum);</span><br></pre></td></tr></table></figure><h4 id="获取器"><a href="#获取器" class="headerlink" title="获取器"></a>获取器</h4><ul><li><p>数据模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// sex 的获取器</span><br><span class="line">public function getSexAttr($val) &#123;</span><br><span class="line">    $status = [</span><br><span class="line">        &apos;0&apos; =&gt; &apos;男&apos;,</span><br><span class="line">        &apos;1&apos; =&gt; &apos;女&apos;</span><br><span class="line">    ];</span><br><span class="line">    return $status[$val];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// status 获取器</span><br><span class="line">public function getStatusAttr($value) &#123;</span><br><span class="line">    $status = [</span><br><span class="line">        &apos;0&apos; =&gt; &apos;禁用&apos;,</span><br><span class="line">        &apos;1&apos; =&gt; &apos;正常&apos;</span><br><span class="line">    ];</span><br><span class="line">    return $status[$value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$user = User::all();</span><br><span class="line">foreach ($user as $key =&gt; $value) &#123;</span><br><span class="line">    dump($value-&gt;toArray()); </span><br><span class="line">    dump($value-&gt;sex);        // 经过获取器的操作</span><br><span class="line">    dump($value-&gt;getData()); // 不经过获取器的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>字段为user_status 修改器名字为getUserStatusAttr</li><li>字段为status 修改器名字为getStatusAttr</li></ul></li></ul><h4 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h4><ul><li><p>数据模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 密码 修改器</span><br><span class="line">public function setPassAttr($value) &#123;</span><br><span class="line">    return md5($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 修改器</span><br><span class="line">public function setPass() &#123;</span><br><span class="line">    $user = new User();</span><br><span class="line">    $res = $user-&gt;save([&apos;pass&apos;=&gt;&apos;123&apos;], [&apos;id&apos;=&gt;&apos;1&apos;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>修改器的触发条件是 save 方法</li></ul></li></ul><h4 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h4><ul><li>修改器与自动完成的区别<ul><li>修改器：数据赋值时自动进行转换处理</li><li>自动完成：没有手动赋值的情况下手动进行处理</li></ul></li><li>自动完成<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 设置自动完成 无论更新操作和添加操作都会执行</span><br><span class="line">// protected $auto = [&apos;time&apos;, &apos;sex&apos;];</span><br><span class="line">protected $auto = [];</span><br><span class="line">protected $insert = [&apos;create_time&apos;];</span><br><span class="line">protected $update = [&apos;update_time&apos;];</span><br><span class="line">// 书写自动完成</span><br><span class="line">protected function setSexAttr() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">protected function setCreateTimeAttr() &#123;</span><br><span class="line">    return time();</span><br><span class="line">&#125;</span><br><span class="line">protected function setUpdateTimeAttr() &#123;</span><br><span class="line">    return time();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><ul><li><p>系统支持自动写入创建和更新的时间戳字段</p><ul><li><p>配置文件中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自动写入时间戳字段</span><br><span class="line">&apos;auto_timestamp&apos;  =&gt; true,</span><br></pre></td></tr></table></figure></li><li><p>数据模型中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置自动写入时间戳</span><br><span class="line">protected $autoWriteTimestamp=true;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以设置字段默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 增加时间的字段</span><br><span class="line">protected $createTime=&apos;create_times&apos;;</span><br><span class="line">// 更新时间的字段</span><br><span class="line">protected $updateTime=&apos;update_times&apos;;</span><br></pre></td></tr></table></figure></li><li><p>取消更新时间戳设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected $updateTime=false;</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图和模板"><a href="#视图和模板" class="headerlink" title="视图和模板"></a>视图和模板</h3><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><h5 id="加载页面"><a href="#加载页面" class="headerlink" title="加载页面"></a>加载页面</h5><ul><li><p>继承系统控制器类<br>param1（字符串）：模板渲染<br>param2（数组）：模板赋值<br>param3（数组）：模板替换<br>param4（数组）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return $this-&gt;fetch(param1, 2, 3, 4);</span><br></pre></td></tr></table></figure></li><li><p>使用助手函数：param与fetch相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return view();</span><br></pre></td></tr></table></figure></li><li><p>使用View类（不建议）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$view = new View();</span><br><span class="line">return $view-&gt;fetch();</span><br></pre></td></tr></table></figure></li></ul><h5 id="模板赋值"><a href="#模板赋值" class="headerlink" title="模板赋值"></a>模板赋值</h5><ul><li><p>控制器类中的assign方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;assign(&apos;name&apos;, $name);</span><br><span class="line">$this-&gt;assign(&apos;city&apos;, $city);</span><br><span class="line">return view();  // 加载页面</span><br></pre></td></tr></table></figure></li><li><p>通过fetch方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return $this-&gt;fetch(&apos;&apos;, [&apos;name&apos;=&gt;$name, &apos;city&apos;=&gt;$city]);</span><br></pre></td></tr></table></figure></li><li><p>助手函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return view(&apos;&apos;, [&apos;name&apos;=&gt;$name, &apos;city&apos;=&gt;$city]);</span><br></pre></td></tr></table></figure></li><li><p>对象赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;view-&gt;name = &quot;zgg&quot;;</span><br><span class="line">$this-&gt;view-&gt;city = &quot;ganzhou&quot;;</span><br><span class="line">return view();</span><br></pre></td></tr></table></figure></li></ul><h5 id="模板替换"><a href="#模板替换" class="headerlink" title="模板替换"></a>模板替换</h5><ul><li><p>配置文件更改（全局替换）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 视图输出字符串内容替换</span><br><span class="line">&apos;view_replace_str&apos;       =&gt; [</span><br><span class="line">    &apos;__HOMES__&apos;=&gt;&apos;/static/home/public&apos;,</span><br><span class="line">    &apos;__ADMINS__&apos;=&gt;&apos;/static/admin/public&apos;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li><li><p>部分替换</p><ul><li><p>fetch 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return $this-&gt;fetch(&apos;&apos;, [], [&apos;__HOMES__&apos;=&gt;&apos;/static/home/public&apos;]);</span><br></pre></td></tr></table></figure></li><li><p>view 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return view(&apos;&apos;, [], [&apos;__HOMES__&apos;=&gt;&apos;/static/home/public&apos;]);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 默认加载当前模块 当前控制器 当前方法对应的页面</span><br><span class="line">  return $this-&gt;fetch();</span><br><span class="line">  </span><br><span class="line">// 加载当前模块 当前控制器下的 用户定义页面</span><br><span class="line">  return $this-&gt;fetch(&apos;jiazai&apos;);</span><br><span class="line">  </span><br><span class="line">// 加载当前模块 User控制器 jiazai页面</span><br><span class="line">  return $this-&gt;fetch(&apos;User/jiazai&apos;);</span><br></pre></td></tr></table></figure><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><h5 id="模板标签"><a href="#模板标签" class="headerlink" title="模板标签"></a>模板标签</h5><ul><li><p>普通标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 模板引擎普通标签开始标记</span><br><span class="line">&apos;tpl_begin&apos;    =&gt; &apos;&lt;&#123;&apos;,</span><br><span class="line">// 模板引擎普通标签结束标记</span><br><span class="line">&apos;tpl_end&apos;      =&gt; &apos;&#125;&gt;&apos;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;$str&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure></li><li><p>标签库标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 标签库标签开始标记</span><br><span class="line">&apos;taglib_begin&apos; =&gt; &apos;&#123;&apos;,</span><br><span class="line">// 标签库标签结束标记</span><br><span class="line">&apos;taglib_end&apos;   =&gt; &apos;&#125;&apos;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;for start=&quot;1&quot; end=&quot;10&quot;&#125;</span><br><span class="line">    &#123;$i&#125;</span><br><span class="line">&#123;/for&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="变量输出"><a href="#变量输出" class="headerlink" title="变量输出"></a>变量输出</h5><ul><li><p>字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 分配字符串</span><br><span class="line">$this-&gt;assign(&quot;str&quot;, &quot;TP5.0&quot;);</span><br></pre></td></tr></table></figure></li><li><p>数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 分配数组</span><br><span class="line">$data = [</span><br><span class="line">    &quot;name&quot; =&gt; &quot;zgg&quot;,</span><br><span class="line">    &quot;age&quot;  =&gt; 19,</span><br><span class="line">];</span><br><span class="line">$this-&gt;assign(&quot;data&quot;, $data);</span><br></pre></td></tr></table></figure></li></ul><h5 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h5><ul><li><p>竖线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;$pass|md5&#125;&lt;/h2&gt;</span><br><span class="line">&lt;!-- &lt;h2&gt;&lt;?php echo md5($pass); ?&gt;&lt;/h2&gt; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;&#123;$time|date=&quot;Y-m-d H:i:s&quot;,###&#125;&lt;/h2&gt;</span><br><span class="line">&lt;!-- &lt;?php echo date(&quot;Y-m-d H:i:s&quot;,$time);?&gt; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;&#123;$pass|md5|strtoupper|substr=0,10&#125;&lt;/h2&gt;</span><br><span class="line">&lt;!-- &lt;h2&gt;&lt;?php echo substr(strtoupper(md5($pass)),0,10); ?&gt;&lt;/h2&gt; --&gt;</span><br></pre></td></tr></table></figure></li><li><p>冒号开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;:md5($pass)&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;:date(&apos;Y-m-d H:i:s&apos;,$time)&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;$name|default=&quot;小云&quot;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&lt;?php echo (isset($name) &amp;&amp; ($name !== &apos;&apos;)?$name:&quot;小云&quot;); ?&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h5 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;$status?&apos;正常&apos;:&apos;错误&apos;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;$status&gt;2?&apos;正常&apos;:&apos;错误&apos;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&lt;?php echo !empty($status) &amp;&amp; $status&gt;2?&apos;正常&apos;:&apos;错误&apos;; ?&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;$a&#125;+&#123;$b&#125;=&#123;$a+$b&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;$a&#125;-&#123;$b&#125;=&#123;$a-$b&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;$a&#125;*&#123;$b&#125;=&#123;$a*$b&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;$a&#125;/&#123;$b&#125;=&#123;$a/$b&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;$a&#125;%&#123;$b&#125;=&#123;$a%$b&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;$a++&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;$b--&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h5 id="原样输出"><a href="#原样输出" class="headerlink" title="原样输出"></a>原样输出</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;literal&#125;</span><br><span class="line">  &lt;h2&gt;hello &#123;$name&#125;&lt;/h2&gt;</span><br><span class="line">&#123;/literal&#125;</span><br></pre></td></tr></table></figure><h5 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h5><ul><li><p>系统变量：支持输出  <code>$_SERVER、$_ENV、$_POST、$_GET、$_REQUEST、$_SESSION、$_COOKIE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&#123;$_GET[&apos;id&apos;]&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;$Think.get.id&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;$_SERVER[&apos;HTTP_HOST&apos;]&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;$Think.SERVER.http_host&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>常量输出：详见附录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&#123;$Think.const.app_path&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;$Think.app_path&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;$Think.ds&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;$Think.think_path&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;$Think.IS_WIN&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;$Think.THINK_VERSION&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置文件输出：常看配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;$Think.config.app_namespace&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;$Think.config.default_lang&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="模板注释"><a href="#模板注释" class="headerlink" title="模板注释"></a>模板注释</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&#123;//$_GET[&apos;id&apos;]&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;/*$Think.get.id*/&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h5 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;include file=&quot;Public/header&quot;&#125;</span><br><span class="line">&#123;include file=&quot;Public/footer,Public/footer&quot;&#125;</span><br></pre></td></tr></table></figure><h5 id="模板布局"><a href="#模板布局" class="headerlink" title="模板布局"></a>模板布局</h5><ul><li>视图目录下新建 <code>layout.html</code></li><li><code>layout.html</code> 页面中将所有的公共部分保留，非公共部分使用 <code>{__CONTENT__}</code> 替代<br> <code>{__CONTENT__}</code>  只能存在一个</li><li>页面中如何书写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 引入模板布局</span><br><span class="line">&#123;layout name=&quot;layout&quot;/&#125;</span><br><span class="line"># 非公共区域内容</span><br><span class="line">&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;div class=&quot;col-md-10&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;jumbotron&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;__ADMINS__/img/4.jpg&quot;height=&quot;310px&quot; width=&quot;100%&quot;</span><br><span class="line">alt=&quot;&quot;&gt;</span><br><span class="line">        &lt;h2&gt;联想 后台管理系统&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;开发者 ： 赵丰泰&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h5><ul><li>视图目录下新建 <code>base.html</code></li><li><p><code>base.html</code> 中对页面进行分割</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &#123;block name=&quot;nav&quot;&#125;&#123;/block&#125;</span><br><span class="line">    &lt;div class=&quot;row body&quot;&gt;</span><br><span class="line">        &#123;block name=&quot;menu&quot;&#125;&#123;/block&#125;</span><br><span class="line">        &#123;block name=&quot;main&quot;&#125;&#123;/block&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;extend name=&quot;base&quot; /&#125;</span><br><span class="line"></span><br><span class="line">&#123;block name=&quot;nav&quot;&#125;</span><br><span class="line">    &#123;include file=&quot;public/nav&quot; /&#125;</span><br><span class="line">&#123;/block&#125;</span><br><span class="line"></span><br><span class="line">&#123;block name=&quot;main&quot;&#125;</span><br><span class="line">    &lt;div class=&quot;jumbotron&quot;&gt;</span><br><span class="line">        &lt;h2&gt;联想 后台管理系统&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;开发者 ： 赵丰泰&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;/block&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="内置标签"><a href="#内置标签" class="headerlink" title="内置标签"></a>内置标签</h5><ul><li>volist 循环<ul><li>name：需要遍历的数据</li><li>id：类似 foreach 中 value</li><li>offset：截取数据的起始位置</li><li>length：截取数据的个数</li><li>mod：奇偶数</li><li>empty：数据为空的使用</li><li>key：编号</li></ul></li><li><p>foreach 循环</p><ul><li>name：需要遍历的数据</li><li>item：类似 foreach 中 value</li><li>key：类似 foreach 中 key<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;foreach name=&quot;data&quot; item=&quot;val&quot; key=&quot;abc&quot;&#125;</span><br><span class="line">  &lt;p&gt; &#123;$abc&#125; &#123;$val.id&#125; &#123;$val.name&#125;&lt;/p&gt;</span><br><span class="line">&#123;/foreach&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>for 循环</p><ul><li>start：开始值</li><li>end：结束值</li><li>comparison：比较条件</li><li>step：步数</li><li>name：循环变量名 默认 i<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;for start=&quot;0&quot; end=&quot;10&quot; comparison=&quot;elt&quot; step=&quot;2&quot; name=&quot;abc&quot;&#125;</span><br><span class="line">  &lt;p&gt;&#123;$abc&#125;&lt;/p&gt;</span><br><span class="line">&#123;/for&#125;</span><br><span class="line"></span><br><span class="line">&#123;for start=&quot;10&quot; end=&quot;0&quot; comparison=&quot;gt&quot; step=&quot;-1&quot;&#125;</span><br><span class="line">  &lt;p&gt;&#123;$i&#125;&lt;/p&gt;</span><br><span class="line">&#123;/for&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>比较标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;eq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/eq&#125;</span><br><span class="line">&#123;neq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/neq&#125;</span><br><span class="line">&#123;lt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/lt&#125;</span><br><span class="line">&#123;gt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/gt&#125;</span><br><span class="line">&#123;egt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/egt&#125;</span><br><span class="line">&#123;elt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/elt&#125;</span><br><span class="line">&#123;heq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/heq&#125;</span><br><span class="line">&#123;nheq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/nheq&#125;</span><br></pre></td></tr></table></figure></li><li><p>if</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;if condition=&quot;$a eq $b&quot;&#125;</span><br><span class="line">    &lt;p&gt;a和b数值相等&lt;/p&gt;</span><br><span class="line">&#123;else /&#125;</span><br><span class="line">    &lt;p&gt;a和b数值不相等&lt;/p&gt;</span><br><span class="line">&#123;/if&#125;</span><br></pre></td></tr></table></figure></li><li><p>switch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;switch name=&quot;week&quot;&#125;</span><br><span class="line">    &#123;case value=&apos;1&apos;&#125;周一&#123;/case&#125;</span><br><span class="line">    &#123;case value=&apos;2&apos;&#125;周二&#123;/case&#125;</span><br><span class="line">    &#123;default /&#125; 周日</span><br><span class="line">&#123;/switch&#125;</span><br></pre></td></tr></table></figure></li><li><p>in 和 notin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;in name=&quot;week&quot; value=&quot;0,1,2,3,4,5,6&quot;&#125;</span><br><span class="line">    合法的数据</span><br><span class="line">&#123;else /&#125;</span><br><span class="line">    不合法数据</span><br><span class="line">&#123;/in&#125;</span><br></pre></td></tr></table></figure></li><li><p>between 和 notbetween</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;between name=&quot;week&quot; value=&quot;0,6&quot;&#125;</span><br><span class="line">    合法数据</span><br><span class="line">&#123;else/&#125;</span><br><span class="line">    非法数据</span><br><span class="line">&#123;/between&#125;</span><br></pre></td></tr></table></figure></li><li><p>原生PHP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;php&#125;</span><br><span class="line">    echo &quot;123&quot;;</span><br><span class="line">&#123;/php&#125;</span><br><span class="line">&lt;?php </span><br><span class="line">    echo &quot;456&quot;;</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Session与Cookie"><a href="#Session与Cookie" class="headerlink" title="Session与Cookie"></a>Session与Cookie</h3><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><ul><li><p>设置 Session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session::set(&apos;name&apos;, &apos;zgg&apos;);</span><br><span class="line">session(&apos;name&apos;, &apos;100&apos;);</span><br></pre></td></tr></table></figure></li><li><p>获取 Session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session::get(&apos;name&apos;);</span><br><span class="line">session(&apos;name&apos;);  // 返回 获取到的值 NULL</span><br></pre></td></tr></table></figure></li><li><p>判断是否设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session::has(&apos;name&apos;);</span><br><span class="line">session(&quot;?name&quot;);  // 返回 true false</span><br></pre></td></tr></table></figure></li><li><p>删除 Session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session::delete(&quot;data&quot;);</span><br><span class="line">session(&apos;name&apos;, null);  // 无返回值</span><br></pre></td></tr></table></figure></li><li><p>清空 Session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session::clear();</span><br><span class="line">session(null);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><ul><li><p>设置 Cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie::set(&apos;name&apos;, &apos;zgg&apos;, 3600);</span><br><span class="line">cookie(&apos;name&apos;, &apos;100&apos;, 3600);</span><br></pre></td></tr></table></figure></li><li><p>获取 Cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie::get(&apos;name&apos;);</span><br><span class="line">cookie(&apos;name&apos;);  // 返回 获取到的值 NULL</span><br></pre></td></tr></table></figure></li><li><p>判断是否设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie::has(&apos;name&apos;);</span><br><span class="line">cookie(&quot;?name&quot;);  // 返回 true false</span><br></pre></td></tr></table></figure></li><li><p>删除 Cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie::delete(&quot;data&quot;);</span><br><span class="line">cookie(&apos;name&apos;, null);  // 无返回值</span><br></pre></td></tr></table></figure></li><li><p>清空 Cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie::clear();</span><br><span class="line">cookie(null);</span><br></pre></td></tr></table></figure></li></ul><h3 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h3><h4 id="控制器中使用验证器"><a href="#控制器中使用验证器" class="headerlink" title="控制器中使用验证器"></a>控制器中使用验证器</h4><pre><code>// 实例化验证器类$validate=new Validate(    [        &quot;username&quot;=&gt;&quot;require|length:6,12&quot;,        &quot;password&quot;=&gt;&quot;require|confirm:repassword&quot;    ],    [        &quot;username.require&quot;=&gt;&apos;用户名不存在&apos;,        &quot;username.length&quot;=&gt;&apos;用户名长度不满足&apos;,        &quot;password.require&quot;=&gt;&apos;密码不存在&apos;,        &quot;password.confirm&quot;=&gt;&apos;两次密码不一致&apos;,    ]);// 接收用户提交的数据$data=input(&quot;post.&quot;);// 进行验证if ($validate-&gt;check($data)) {}else{    dump($validate-&gt;getError());}</code></pre><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul><li><p>控制器中书写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$data = Db::table(&quot;user&quot;)-&gt;paginate(3);</span><br><span class="line">$data = Db::table(&quot;user&quot;)-&gt;paginate(3, true);  // 简化版效果</span><br><span class="line"></span><br><span class="line">$this-&gt;assign(&quot;data&quot;, $data);</span><br><span class="line">return $this-&gt;fetch();</span><br></pre></td></tr></table></figure></li><li><p>页面中书写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;volist name=&quot;data&quot; id=&quot;val&quot;&#125;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;&#123;$val.id&#125;&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;&#123;$val.name&#125;&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;&#123;$val.pass&#125;&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  </span><br><span class="line">&#123;/volist&#125;</span><br><span class="line"></span><br><span class="line">&#123;$data-&gt;render()&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作室第七期培训后期主要以TP5搭建个人博客为主，这里将需要用到的知识笔记做个整理再加一些&lt;br&gt;扩展~&lt;/p&gt;
&lt;p&gt;ThinkPHP的核心就是MVC思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Controller： 控制器，整个应用逻辑交互的处理&lt;/li&gt;
&lt;li&gt;Model：模
      
    
    </summary>
    
    
      <category term="ThinkPHP" scheme="https://jeremygo.cn/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket实践</title>
    <link href="https://jeremygo.cn/2018/02/02/WebSocket%E5%AE%9E%E8%B7%B5/"/>
    <id>https://jeremygo.cn/2018/02/02/WebSocket实践/</id>
    <published>2018-02-02T11:04:49.000Z</published>
    <updated>2018-02-02T12:06:11.251Z</updated>
    
    <content type="html"><![CDATA[<p>做小程序项目的时候有实时通信的需求，这里就整理一下WebSocket的知识</p><h3 id="关于WebSocket"><a href="#关于WebSocket" class="headerlink" title="关于WebSocket"></a>关于WebSocket</h3><ul><li>前言：Web应用的信息交互过程一般是客户端通过浏览器发出一个请求，服务器端接收完请求后进行处理并且返回结果给客户端，然后客户端浏览器解析信息，这样的机制对于实时要求比较高的应用来说就有很大的受限了，因此需要有一种高效节能的双向通信机制来保证数据的实时传输，WebSocket应运而生</li><li>概念：<ul><li>MDN: WebSocket是一个可以创建和服务器间进行双向会话的高级技术，通过这个API你可以向服务器发送消息并接受基于事件驱动的响应，这样就不用向服务器轮询获取数据了</li><li>WebSocket有web TCP之称，顾名思义是用来通信的，作为HTML5中新增的一种通信协议，由TCP协议与编程API组成，可以在浏览器与服务器之间建立双向连接，以基于事件的方式，赋予浏览器原生的实时通信能力，从而扩展我们的web应用，提升应用性能与用户体验</li></ul></li><li>为什么使用：<br>在WebSocket出现之前有一些其它的实时通讯方案，比如轮询、长轮询、服务器发送事件<ul><li>轮询(Polling)：客户端以一定的时间间隔向服务器发送请求，通过频繁请求的方式来保持客户端和服务器端的数据同步。通常采取<code>setInterval</code>或者<code>setTimeout</code>实现。问题：客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，这样很多请求就是没有必要的，浪费带宽，低效率</li><li>长轮询(Long Polling)：对定时轮询的改进和提高，当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，以此减少无效的客户端与服务器间的交互。问题：如果服务端的数据变更非常频繁的话，与定时轮询比较起来没有本质上性能的提高</li><li>服务器发送事件(Server-Sent Event)：是HTML5规范的一个组成部分，可以实现服务器到客户端的单向数据通信，通过SSE，客户端可以自动获取数据更新，而不用重复发送HTTP请求。问题：只支持到服务器到客户端单向的事件推送，而且所有版本的IE都不支持SSE</li><li>WebSocket：在流量与负载量增大的情况下，相比于传统的Ajax轮询方案有极大的性能优势，在开发方面也不算复杂，只需要实例化WebSocket创建连接，成功后就可以发送相应消息了</li></ul></li></ul><h3 id="Node实现"><a href="#Node实现" class="headerlink" title="Node实现"></a>Node实现</h3><p>这里采用Node的ws库来实现简单的WebSocket服务器</p><ul><li><p>服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var WebSocketServer = require(&quot;ws&quot;).Server;</span><br><span class="line">var wss = new WebSocketServer(&#123;</span><br><span class="line">    port: 3001</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">wss.on(&quot;connection&quot;, function(ws) &#123;</span><br><span class="line">    ws.on(&quot;message&quot;, function(msg) &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">        ws.send(&quot;Nice to meet you!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    ws.on(&quot;close&quot;, function() &#123;</span><br><span class="line">        console.log(&quot;Stop client&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>小程序客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wx.connectSocket(&#123;</span><br><span class="line">    url: &apos;服务器的链接:3001&apos;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    header: &#123;</span><br><span class="line">        &apos;content-type&apos;: &apos;application/json&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    method: &apos;GET&apos;,</span><br><span class="line">    success: function() &#123;</span><br><span class="line">        console.log(&quot;客户端连接成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;),</span><br><span class="line">wx.onSocketOpen(function() &#123;</span><br><span class="line">    console.log(&quot;WebSocket连接已打开&quot;);</span><br><span class="line">    wx.sendSocketMessage(&#123;</span><br><span class="line">        data: &apos;Hello!&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;),</span><br><span class="line">wx.onSocketMessage(function(msg) &#123;</span><br><span class="line">    console.log(&quot;接收到：&quot;+ msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>这里特别提一下<code>wx.onSocketMessage()</code>，因为它只接收字符串和二进制类型的数据，因此如果需要发送json格式的数据就需要转换一下，只要是支持WebSocket肯定支持原生window.JSON，所以可以直接使用JSON.parse()和JSON.stringify()来转换</p><p>这样一个双向通信的实例基本就完成了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做小程序项目的时候有实时通信的需求，这里就整理一下WebSocket的知识&lt;/p&gt;
&lt;h3 id=&quot;关于WebSocket&quot;&gt;&lt;a href=&quot;#关于WebSocket&quot; class=&quot;headerlink&quot; title=&quot;关于WebSocket&quot;&gt;&lt;/a&gt;关于WebSoc
      
    
    </summary>
    
    
      <category term="WebSocket" scheme="https://jeremygo.cn/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://jeremygo.cn/2018/01/22/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://jeremygo.cn/2018/01/22/HTTP协议/</id>
    <published>2018-01-22T02:35:17.000Z</published>
    <updated>2018-01-22T08:20:35.956Z</updated>
    
    <content type="html"><![CDATA[<p>浏览公众号时看到一篇介绍HTTP较全的文章，这里做一个摘录总结，后续学习会不断完善改进~</p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><ul><li>HTTP协议：超文本传输协议，用于从万维网服务器传输超文本到本地浏览器的传送协议，是互联网上应用最为广泛的一种网络协议，所有www文件都必须遵守的这个标准</li><li>HTTP基于TCP/IP通信协议来传送数据（HTML文件、图片文件、查询结果等）</li><li>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。于1990年提出，不断地完善和扩展</li><li>HTTP协议以客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即Web服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息</li></ul><h3 id="HTTP协议版本"><a href="#HTTP协议版本" class="headerlink" title="HTTP协议版本"></a>HTTP协议版本</h3><ul><li>HTTP0.9是第一个版本，请求(Request)只有一行，比如：GET www.baidu.com</li><li>HTTP1.0最早于1996年在网页中使用，只是使用一些较为简单的网页和网络请求上</li><li><p>HTTP1.1在1999年开始广泛应用于现在的各大浏览器网络请求中，同时它也是当前使用最为广泛的协议</p></li><li><p>HTTP1.1的升级部分</p><ul><li>缓存处理：HTTP1.0主要使用header里的If-Modified-Since,Expires来作为缓存判断的标准，而HTTP1.1则引入了更多的缓存控制策略如Entity tag,If-Unmodified-Since,If-Match,If-None-Match等更多可供选择的缓存头来控制缓存策略</li><li>带宽优化及网络连接：HTTP1.0中存在浪费带宽的现象，比如客户端只是需要某个对象的一部分但  服务器却将整个对象传送过来了，并且不支持断点续传功能；HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206(Partial Content)  ，这样就方便了开发者自有的选择以便于充分利用带宽和连接</li><li>错误通知的管理：HTTP1.1中新增了24个错误状态响应码，如409(Conflict)  表示请求的资源与资源的当前状态发生冲突，410(Gone)表示服务器上的某个资源被永久性的删除</li><li>Host头处理：HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的URL并没有传递主机名(hostname),但随着虚拟主机技术的发展，一台物理服务器上可以存在多个虚拟主机，并且共享一个IP地址；HTTP1.1的请求消息和响应消息都应支持Host头域，并且请求消息中如果没有Host头域就会报告400(Bad Request)错误</li><li>长连接：HTTP1.1支持长连接(PersistentConnection)和请求的流水线(Pipelining)处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中  默认开启Connection：Keep-alive,一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点</li></ul></li><li><p>如何建立连接(三次握手)<br>HTTP是基于TCP协议的，浏览器最快也要在第三次握手时才能捎带HTTP请求报文，真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动，三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大</p><ul><li>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SENT状态，等待服务器确认；<br>SYN：同步序列编号</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包,此时服务器进入SYN_RECV状态</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕后，客户端和服务器进入ESTABLISHED(TCP连接成功)状态,完成三次握手</li></ul></li><li><p>如何关闭连接(四次挥手)</p><ul><li>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，另一方执行被动关闭</li></ul></li><li><p>TCP连接的拆除需要发送四个包，客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作</p><ul><li>客户端发送一个FIN，用来关闭客户端到服务器的数据传送</li><li>服务器收到这个FIN，发回一个ACK，确认序号为收到的序号+1，和SYN一样，一个FIN将占用一个序号</li><li>服务器关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端发回ACK报文确认，并将确认序号设置为收到序号+1</li></ul></li></ul><p><img src="https://ws1.sinaimg.cn/large/e4336439gy1fnpbj3ksqmj20lp0lfjyu.jpg" alt=""></p><ul><li>浏览器阻塞<ul><li>浏览器对于同一个域名，一般PC端浏览器针对单个域名的server同时建立6~8个连接，手机端的连接数则控制在4~6个(根据浏览器内核的不同可能会有所差异)，超过浏览器最大连接数限制，后续请求就会被阻塞</li></ul></li></ul><h3 id="HTTP2前述概念"><a href="#HTTP2前述概念" class="headerlink" title="HTTP2前述概念"></a>HTTP2前述概念</h3><ul><li>SPDY<br>SPDY协议是Google提出的基于传输控制协议(TCP)的应用层协议，通过压缩、多路复用和优先级来缩短加载时间，是一种更快加速的内容传输协议，于2009年年中发布，Chrome、FireFox、Oprea已默认开启SPDY</li><li>SPDY协议设定目标<ol><li>页面加载时间降低50%</li><li>无需网站作者修改任何内容</li><li>最小化配置复杂度，无需变更网络基础设施<br>注：为了降低50%的页面加载时间，SPDY引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层TCP连接</li></ol></li></ul><h3 id="HTTP2：SPDY升级版"><a href="#HTTP2：SPDY升级版" class="headerlink" title="HTTP2：SPDY升级版"></a>HTTP2：SPDY升级版</h3><ul><li>HTTP-WG在2012年初提议了HTTP2.0，并吸收SPDY的经验教训在此基础上制定官方标准</li><li>HTTP2的主要目标是改进传输性能，更有效地利用网络资源，实现低延迟和高吞吐量</li><li><p>HTTP2致力于突破上一代标准的性能限制，也是一个扩展，之所以要递增一个大版本，主要是因为改变了客户端与服务器之间交换数据的方式</p></li><li><p>HTTP2如何提高效率</p><ul><li>二进制分帧：HTTP2.0所有帧都采用二进制编码<ul><li>帧：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位</li><li>消息：指逻辑上的HTTP消息，比如请求、响应等，由一个或多个帧组成</li><li>流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1fnpbk79csjj20oh06ktbb.jpg" alt=""></li></ul></li><li>多路复用：允许通过单一的HTTP/2连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP2不再依赖多个TCP连接去实现多流并行。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错(乱序发送)，还可以分优先级，最后再在另一端把它们重新组合。HTTP2.0连接都是持久化的，而且客户端与服务器之间只需要一个连接(一个域名一个连接)即可</li><li>请求优先级：<ul><li>将HTTP消息分解为很多个独立的帧后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个31比特的优先值：0表示最高优先级，2的-31次方表示最低优先级</li><li>服务器可以根据流的优先级，控制资源分配(CPU、内存、带宽)，而在响应数据准备好之后，优先将最高优先级的帧发送给客户端</li><li>HTTP2.0解决了所有低效的问题：浏览器可以在发现资源时立即分配请求，指定每个流的优先级，让服务器决定最优的响应次序，这样请求不用排队，既节省了时间也最大限度地利用了每个连接</li></ul></li><li>header压缩：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2使用encoder来减少需要传输的header大小，通讯双方各自cache一份headerfields表，既避免了重复header的传输，又减小了需要传输的大小</li><li>服务端推送：<ul><li>服务器可以对一个客户端请求发送多个响应并且服务器向客户端推送资源无需客户端明确地请求</li><li>HTTP2.0连接后，客户端与服务器交换SET-TINGS帧，借此可以限定双向并发的流的最大数量</li><li>所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认猜想</li><li>服务器必须遵循请求-响应的循环，只能借着对请求的响应推送资源</li><li>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤</li></ul></li></ul></li><li><p>HTTP2的多路复用与HTTP1.1的长连接复用有什么区别</p><ul><li>HTTP1.0一次请求-响应，建立一个连接，用完关闭，每一个请求都要建立一个连接</li><li>HTTP1.1Pipeling解决方式为：若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等情况，后续请求只能被阻塞，毫无办法，即线头阻塞</li><li>HTTP2多个请求可同时在一个连接上并行执行，某个请求任务耗时严重也不会影响到其它连接的正常执行<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1fnpbl9djihj20kj0kqjyl.jpg" alt=""></li></ul></li></ul><h3 id="如何应用到自己的项目"><a href="#如何应用到自己的项目" class="headerlink" title="如何应用到自己的项目"></a>如何应用到自己的项目</h3><p>现有任何网站和应用，无需做任何修改都可以在HTTP2.0上跑起来，HTTP服务器必须运行HTTP2.0协议，但大部分用户都不会因此受影响，NGINX的话只要在配置文件中启动相应的协议就可以了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浏览公众号时看到一篇介绍HTTP较全的文章，这里做一个摘录总结，后续学习会不断完善改进~&lt;/p&gt;
&lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HTTP
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://jeremygo.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Centos7搭建Web服务器</title>
    <link href="https://jeremygo.cn/2018/01/18/Centos7%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://jeremygo.cn/2018/01/18/Centos7搭建Web服务器/</id>
    <published>2018-01-18T08:56:20.000Z</published>
    <updated>2018-08-06T08:09:01.670Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在虚拟机里装了centos7来配置lamp服务器，其中踩了好多好多……坑o(╥﹏╥)o，必须做个记录</p><p>更新：nginx 与 node 的安装</p></blockquote><h3 id="centos7安装"><a href="#centos7安装" class="headerlink" title="centos7安装"></a>centos7安装</h3><ul><li>这里就是网上下好iso镜像，然后一步步装好，建议初学者选GNONE桌面版方便操作</li></ul><h3 id="Apache、Mysql、PHP安装"><a href="#Apache、Mysql、PHP安装" class="headerlink" title="Apache、Mysql、PHP安装"></a>Apache、Mysql、PHP安装</h3><ul><li><p>Apache<br>apache软件包名称叫做httpd<br><code>yum install httpd</code><br>出现提示时一路 y+回车 就好</p><p>  启动Apache并将其设置为开机启动<br>  <code>systemctl start httpd.service</code><br>  <code>systemctl enable httpd.service</code><br>  检查httpd服务状态：<br>  <code>systemctl status httpd.service</code><br>  看到绿色的<code>active(running)</code>表示httpd服务正在运行中，<code>enabled</code>  表示httpd服务已设为开机启动</p><p>  这样HTTP协议就启动了，因为它要用到端口80，因此防火墙要放通80，这里直接就关掉它<br>  <code>systemctl stop firewalld.service</code> 停止firewall<br>  <code>systemctl disable firewalld.service</code> 禁止开机启动</p><p>  现在可以通过<code>ip addr</code>查询当前系统ip地址，在浏览器访问就可以看到apache页面<br>  Tips: 这里可以将虚拟机内部ip配置为静态的，然后修改主机hosts文件对应别名如myserver之后即可通过<a href="http://myserver直接访问" target="_blank" rel="noopener">http://myserver直接访问</a></p></li><li><p>PHP<br><code>yum install php</code><br>这里有需要的话可以进入<code>/etc/php.ini</code>做一些配置的修改<br>测试Apache能不能正常调用php，在/var/www/html目录下新建一个输出phpinfo的文件<br><code>vim /var/www/html/phpinfo.php</code><br>使用浏览器打开可以看到php信息页则说明正常<br>然后安装常用的扩展<br><code>yum -y install php-mysql php-gd php-imap php-ldap php-mbstring php-odbc php-pear php-xml php-xmlrpc</code></p></li><li><p>Mysql<br>这里推荐安装MariaDB(从RHEL 7开始Red Hat公司推荐使用它替换Mysql)<br><code>yum install mariadb-server mariadb</code><br><code>systemctl start mariadb</code> 启动mariadb<br><code>systemctl enable mariadb</code> 设置为开机启动</p><p>  这里可以启动数据库守护进程<br>  <code>mysql_secure_installation</code><br>  用来设置root密码，允许远程root登录等等</p><p>  <code>mysql -u root -p</code>使用root账号登录mariadb<br>  <code>show mysql</code>切换到mysql<br>  <code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;</code> 修改登录权限设置为允许远程登录</p></li></ul><h3 id="配置apache虚拟目录"><a href="#配置apache虚拟目录" class="headerlink" title="配置apache虚拟目录"></a>配置apache虚拟目录</h3><p>apache默认工程目录是在/var/www下的，而编辑该目录必须是root用户，因此我们有必要自定义一个目录，让apache也能识别<br><code>vim /etc/httpd/conf/httpd.conf</code>打开apache配置文件<br>找到<code>&lt;dir alias_module&gt;</code>，在内部添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">Alias /myweb &quot;/home/daybreak/www&quot;</span><br><span class="line">&lt;Directory &quot;/home/daybreak/www&quot;&gt;</span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line">    AllowOverride None</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p><p>这里我的自定义路径为/home/daybreak/www，对应别名是myweb，在浏览器输入<code>http&quot;//myserver/myweb</code>就能对真实目录/home/daybreak/www下文件进行访问</p><p>注意：这里直接访问后很可能会出现403forbidden的错误，解决方案如下</p><ol><li>确保配置虚拟目录时设置了目录访问权限即<code>Require all granted</code></li><li><p>到这里可能是网站目录的权限问题，apache要求目录具有执行权限，也就是x，所以要确保访问的目录树都具有这些权限，例如我的目录时/home/daybreak/www，则需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 /home</span><br><span class="line">chmod 755 /home/daybreak</span><br><span class="line">chmod 755 /home/daybreak/www</span><br><span class="line">或者直接 chmod 755 -R /home</span><br></pre></td></tr></table></figure></li><li><p>如果依然是403，那就是selinux的问题，把目录进行一下selinux权限设置<br><code>chcon -R -t httpd_sys_content_t /home</code></p></li></ol><p>这样访问成功后就可以通过自定义的目录访问web文档</p><h3 id="扩展：nginx-与-node-的安装"><a href="#扩展：nginx-与-node-的安装" class="headerlink" title="扩展：nginx 与 node 的安装"></a>扩展：nginx 与 node 的安装</h3><h4 id="nginx-安装"><a href="#nginx-安装" class="headerlink" title="nginx 安装"></a>nginx 安装</h4><ul><li><p>添加 centos7 nginx yum 资源库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>yum 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure></li><li><p>启动并且开机启动nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx &amp;&amp; sudo systemctl enable nginx</span><br></pre></td></tr></table></figure></li><li><p>测试nginx配置文件（查看nginx配置位置）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure></li></ul><h4 id="node-安装"><a href="#node-安装" class="headerlink" title="node 安装"></a>node 安装</h4><ul><li><p>使用官方编译的二进制数据包安装：</p><ul><li><p>进入官网<a href="https://nodejs.org/download/release/" target="_blank" rel="noopener">下载链接</a>，选择想要下载的版本链接与版本(*-linux-x64.tar.gz)，进入用户主目录使用 <code>wget</code> 命令下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/download/release/v8.9.4/node-v8.9.4-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>下载完成后解压到 <code>/usr/local</code> 目录并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar --strip-components 1 -xzvf node-v* -C /usr/local</span><br></pre></td></tr></table></figure></li><li><p>安装完成后验证安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">v8.9.4</span><br></pre></td></tr></table></figure></li></ul></li><li><p>源码安装：</p><ul><li><p>使用源码安装与二进制数据包安装的区别在于源码安装还需要编译源码才能安装</p></li><li><p>进入官网<a href="https://nodejs.org/download/release/" target="_blank" rel="noopener">下载链接</a>，选择版本(node-v*.tar.gz)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/download/release/v8.9.4/node-v8.9.4.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>下载完成后，解压并进入解压后的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf node-v8.9.4.tar.gz &amp;&amp; cd node-v8.9.4</span><br></pre></td></tr></table></figure></li><li><p>编译源码需要安装 <code>gcc</code> 和 <code>gcc-c++</code> (可先使用<code>yum info package_name</code> 检查是否已安装)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gcc gcc-c++</span><br></pre></td></tr></table></figure></li><li><p>安装完成后运行 <code>configure</code> 文件并编译，编译完成后安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>​</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在虚拟机里装了centos7来配置lamp服务器，其中踩了好多好多……坑o(╥﹏╥)o，必须做个记录&lt;/p&gt;
&lt;p&gt;更新：nginx 与 node 的安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;centos7安装&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://jeremygo.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>异步JavaScript请求</title>
    <link href="https://jeremygo.cn/2017/12/29/%E5%BC%82%E6%AD%A5JavaScript%E8%AF%B7%E6%B1%82/"/>
    <id>https://jeremygo.cn/2017/12/29/异步JavaScript请求/</id>
    <published>2017-12-29T01:56:44.000Z</published>
    <updated>2017-12-29T11:23:21.159Z</updated>
    
    <content type="html"><![CDATA[<p>在Udacity上系统学了异步JavaScript请求的课程，这里结合之前自己的理解做一个总结~</p><h3 id="Ajax与XHR"><a href="#Ajax与XHR" class="headerlink" title="Ajax与XHR"></a>Ajax与XHR</h3><p>在JavaSctipt中发出异步HTTP请求的步骤：</p><ul><li>使用<code>XMLHttpRequest</code>构造函数创建XHR对象</li><li>使用<code>.open()</code>方法-设置HTTP方法和要获取的资源的URL</li><li>设置<code>.onload()</code>属性-将此属性设为成功获取数据后将运行的函数</li><li>设置<code>.onerror()</code>属性-将此属性设为出现错误后将运行的函数</li><li>使用<code>.send()</code>方法-发送请求</li></ul><p>使用响应：</p><ul><li>使用<code>.responseText</code>属性-存储异步请求响应的文本</li></ul><p><code>XMLHttpRequest</code>：简称XHR，它提供了向服务器发送请求和解析服务器响应流畅的接口，可以以异步方式从服务器获得更多的信息<br>IE6及以下不能直接通过XHR对象实例化<code>XMLHttpRequest</code>，兼容性实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function createXHR() &#123;</span><br><span class="line">    if(typeof XMLHttpRequest != &apos;undefined&apos;) &#123;</span><br><span class="line">        return new XMLHttpRequest();</span><br><span class="line">    &#125; else if(typeof ActiveXObject != &apos;undefined&apos;) &#123;</span><br><span class="line">        var versions = [</span><br><span class="line">            &apos;MSXML2.XMLHttp.6.0&apos;,</span><br><span class="line">            &apos;MSXML2.XMLHttp.3.0&apos;,</span><br><span class="line">            &apos;MSXML2.XMLHttp&apos;</span><br><span class="line">        ];</span><br><span class="line">        for(var i = 0; i &lt; versions.length; i++) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                return new ActiveXObject(versions[i]);</span><br><span class="line">            &#125; catch(e) &#123;</span><br><span class="line">                // 跳过</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new Error(&apos;你的浏览器不支持XHR对象！&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>GET</code>与<code>POST</code>： Ajax使用时，<code>GET</code>的使用频率高于<code>POST</code>，了解一下HTTP头部信息，包含服务器返回的响应头信息和客户端发出去的请求头信息</p><p><code>GET</code>请求： 最常用的请求类型，常用于向服务器查询某些信息，在<code>.open()</code>方法的第二个参数可以通过URL后的问号给服务器传递键值对数据，服务器接收到以后就会返回响应数据，用<code>encodeURIComponent()</code>进行编码处理解决特殊字符传参产生的问题<br><code>POST</code>请求： 多用于表单提交时，通过<code>.send()</code>方法向服务器提交数据，同时一般<code>POST</code>请求还需要用XHR来模仿表单提交<br><code>xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);</code></p><p>性能上说POST请求比GET请求消耗更多，相同数据下，GET请求最多比POST快两倍</p><p>封装Ajax：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 名值对编码</span><br><span class="line">function params(data) &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i in data) &#123;</span><br><span class="line">        arr.push(encodeURIComponent(i) + &apos;=&apos; + encodeURIComponent(data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.join(&apos;&amp;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ajax(obj) &#123;</span><br><span class="line">    var xhr  = new createXHR();</span><br><span class="line">    obj.url  = obj.url + &apos;?rand=&apos; + Math.random();</span><br><span class="line">    obj.data = params(obj.data);</span><br><span class="line">    if(obj.method === &apos;get&apos;) &#123;</span><br><span class="line">        obj.url = obj.url.indexOf(&apos;?&apos;) == -1 ? obj.url + &apos;?&apos; + obj.data : obj.url + &apos;&amp;&apos; + obj.data;</span><br><span class="line">    &#125;</span><br><span class="line">    if(obj.async === true) &#123;</span><br><span class="line">        xhr.onreadystatechange = function() &#123;</span><br><span class="line">            if(xhr.readyState == 4) callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(obj.method, obj.url, obj.async);</span><br><span class="line"></span><br><span class="line">    if(obj.method === &apos;post&apos;) &#123;</span><br><span class="line">        xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">        xhr.send(obj.data);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(obj.async === false) callback();</span><br><span class="line"></span><br><span class="line">    function callback() &#123;</span><br><span class="line">        if(xhr.status == 200) &#123;</span><br><span class="line">            obj.success(xhr.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&apos;数据返回失败！状态代码：&apos; + xhr.status + &apos;，状态信息：&apos; + xhr.statusText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Udacity上系统学了异步JavaScript请求的课程，这里结合之前自己的理解做一个总结~&lt;/p&gt;
&lt;h3 id=&quot;Ajax与XHR&quot;&gt;&lt;a href=&quot;#Ajax与XHR&quot; class=&quot;headerlink&quot; title=&quot;Ajax与XHR&quot;&gt;&lt;/a&gt;Ajax与X
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web性能优化</title>
    <link href="https://jeremygo.cn/2017/12/02/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://jeremygo.cn/2017/12/02/Web性能优化/</id>
    <published>2017-12-02T05:08:33.000Z</published>
    <updated>2017-12-02T05:22:27.090Z</updated>
    
    <content type="html"><![CDATA[<p>在书上看到了关于Web性能优化方面的知识，这里先记录下来，方便以后加以实践~</p><p>Web性能优化分为服务器端和浏览器端两个方面：</p><ul><li><p>压缩源码和图片<br>► JavaScript文件源代码可以采用混淆压缩的方式<br>► CSS文件源码可以进行普通压缩<br>► JPG图片可以根据具体质量来压缩为50%-70%<br>► PNG可以使用一些开源压缩软件来压缩，比如24色变成8色、去掉一些PNG格式信息等</p></li><li><p>选择合适的图片格式<br>► 如果图片颜色数较多就使用JPG格式<br>► 如果图片颜色数较少就使用PNG格式<br>► 如果能够通过服务器端判断浏览器支持WebP，就使用WebP格式和SVG格式</p></li><li><p>合并静态资源<br>► 包括CSS、JavaScript和小图片，减少HTTP请求</p></li><li><p>开启服务器端的Gzip压缩<br>► 对于文本资源非常有效，对图片资源则没那么大的压缩比率</p></li><li><p>使用CDN<br>► 或者一些公开库使用第三方提供的静态资源地址（比如jQuery、normalize、css）。一方面增加并发下载量，另一方面能够和其他网站共享缓存</p></li><li><p>延长静态资源缓存时间<br>► 这样频繁访问网站的访客就可以更快地访问。但是这里要通过修改文件名的方式，确保资源更新的时候，用户会拉取到最新的内容</p></li><li><p>把CSS放在页面头部，JavaScript放在页面底部<br>► 这样就不会阻塞页面渲染，让页面出现长时间的空白</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在书上看到了关于Web性能优化方面的知识，这里先记录下来，方便以后加以实践~&lt;/p&gt;
&lt;p&gt;Web性能优化分为服务器端和浏览器端两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;压缩源码和图片&lt;br&gt;► JavaScript文件源代码可以采用混淆压缩的方式&lt;br&gt;► CSS文件源
      
    
    </summary>
    
    
      <category term="Web" scheme="https://jeremygo.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Git常用操作</title>
    <link href="https://jeremygo.cn/2017/11/30/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://jeremygo.cn/2017/11/30/Git常用操作/</id>
    <published>2017-11-30T14:46:08.000Z</published>
    <updated>2017-12-30T09:57:57.438Z</updated>
    
    <content type="html"><![CDATA[<p>随着做项目的深入，对Git的使用也越来越频繁，这里就做一个常用操作的总结，不断更新~</p><h3 id="Git理念"><a href="#Git理念" class="headerlink" title="Git理念"></a>Git理念</h3><p>► 工作区（即本地文件）<br>► 暂存区<br>► 本地仓库<br>► 远程仓库</p><p>使用Git项目的文件都是在上面四个地方传递</p><h3 id="本地项目关联远程仓库"><a href="#本地项目关联远程仓库" class="headerlink" title="本地项目关联远程仓库"></a>本地项目关联远程仓库</h3><p>远程库建好以后就可以运行这条命令关联到本地项目：<br><code>git remote add origin your-remote-repository-url</code></p><p>如果是直接克隆远程仓库到本地的话：<br><code>git clone your-remote-repository-url</code></p><p>可以运行以下命令查看结果：</p><p><code>git remote -v</code>  查看当前项目的远程库<br><code>git branch -a</code>  查看当前项目的所有分支</p><h3 id="远程库同步到本地"><a href="#远程库同步到本地" class="headerlink" title="远程库同步到本地"></a>远程库同步到本地</h3><p>► 在提交更新以前都要先同步一下本地仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull   等同于 git fetch + git merge</span><br></pre></td></tr></table></figure></p><p>如果需要放弃本地修改，强制覆盖本地版本的话（即保持与远程库一致）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></p><h3 id="提交本地更新到远程库"><a href="#提交本地更新到远程库" class="headerlink" title="提交本地更新到远程库"></a>提交本地更新到远程库</h3><p><code>git status</code> 检查当前项目状态</p><p>然后对于未跟踪的文件执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add untrack-file-path    跟踪单个本地文件，提交到暂存区</span><br><span class="line">git commit -m &quot;your commit&quot;  将跟踪过的文件即在暂存区的文件提交到本地仓库</span><br><span class="line">git push                     将本地仓库提交到远程库</span><br></pre></td></tr></table></figure><p>提交到远程库常用的命令还有：</p><p><code>git add .</code>      跟踪本地所有未跟踪的文件<br><code>git push -f</code>    强制提交更新，覆盖远程库 — 慎用！！！</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>► 将当前版本回退到已提交的版本历史中<br><code>git reset --hard HEAD^</code>   一个^号代表回退一个版本</p><p>更多时候我们都会找到对应的版本号进行回退：<br>首先 <code>git log</code> 显示最近到最远的提交日志<br>如果只想显示版本号和评论信息的话可以加上 <code>--pretty=oneline</code> 参数<br>现在就可以  <code>git reset --hard version number</code>  回退到对应的版本</p><p>这里还有一个常用命令：<br><code>git reflog</code> 显示你的每一次命令，对于自己命令的整理很有帮助</p><h3 id="检查修改"><a href="#检查修改" class="headerlink" title="检查修改"></a>检查修改</h3><p>► 已修改，未暂存<br><code>git diff</code></p><p>► 已暂存，未提交<br><code>git diff --cached</code></p><p>► 已提交，未推送<br><code>git diff master origin/master</code></p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>► 向commit中添加忘记的文件(即更新最近的commit)</p><ul><li>编辑文件</li><li>保存文件</li><li>暂存文件</li><li><code>git commit --amend</code></li></ul><p>► 还原commit<br><code>git revert &lt;SHA&gt;</code> 撤销目标commit做出的更改，同时创建一个新的commit记录这一更改</p><p>► 重置commit<br><code>git reset &lt;reference&gt;</code> 清除commit</p><ul><li>将HEAD和当前分支指针移到引用的commit</li><li>使用<code>--hard</code>选项清除commit</li><li>使用<code>--sort</code>选项将commit的更改移至暂存区</li><li>使用<code>--mixed</code>选项取消暂存已被commit的更改</li></ul><p>► 已修改，未暂存<br><code>git checkout -- file-path</code></p><p>► 已暂存，未提交<br><code>git reset HEAD file-path</code>  先撤销暂存区的修改<br><code>git checkout -- file-path</code> 再撤销工作区的修改</p><p>PS: 以上两个步骤都可以用 <code>git reset --hard</code> 完成，一步到位将修改完全恢复到未修改的状态</p><p>► 已提交，未推送<br><code>git reset --hard origin/master</code>  从远程库将代码取回</p><p>► 已推送<br><code>git reset --hard HEAD^</code>    先回退本地库的版本<br><code>git push -f</code>               再强制推送到远程库</p><h3 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h3><p><code>git branch</code> ：</p><ul><li>列出仓库中所有的分支名称  — 活跃分支旁会显示一个星号</li><li>创建新的分支</li><li>删除分支  — 无法删除当前所在的分支</li></ul><p><code>git checkout</code> 切换分支，可以创建新的分支，<code>-b</code>选项可以附加切换到该分支</p><p><code>git log --oneline --decorate</code> 显示日志中的分支<br><code>git log --oneline --decorate --graph --all</code>  显示实际的所有分支</p><p><code>git merge &lt;other-branch&gt;</code> 合并分支</p><p>发生合并时，git将：</p><ul><li>查看将合并的分支</li><li>查看分支的历史记录并寻找两个分支的commit历史记录都有的单个commit</li><li>将单个分支上更改的代码行合并到一起</li><li>提交一个commit来记录合并操作</li></ul><p>合并有以下两种类型：</p><ul><li>快进合并-要合并的分支位于检出分支前面。检出分支的指针将向前移动，指向另一分支所指向的同一commit</li><li>普通类型的合并<ul><li>两个完全不同的分支被合并</li><li>创建一个合并commit</li></ul></li></ul><p>合并冲突：<br>当相同的行在要合并的不同分支上做出了更改时，就会出现合并冲突。解决：</p><ul><li>找到并删掉存在合并冲突指示符的所有行</li><li>决定保留哪些行</li><li>保存文件</li><li>暂存文件</li><li>提交commit</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着做项目的深入，对Git的使用也越来越频繁，这里就做一个常用操作的总结，不断更新~&lt;/p&gt;
&lt;h3 id=&quot;Git理念&quot;&gt;&lt;a href=&quot;#Git理念&quot; class=&quot;headerlink&quot; title=&quot;Git理念&quot;&gt;&lt;/a&gt;Git理念&lt;/h3&gt;&lt;p&gt;► 工作区（即本
      
    
    </summary>
    
    
      <category term="Git" scheme="https://jeremygo.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>数据结构实验参考</title>
    <link href="https://jeremygo.cn/2017/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%8F%82%E8%80%83/"/>
    <id>https://jeremygo.cn/2017/11/29/数据结构实验参考/</id>
    <published>2017-11-29T01:44:22.000Z</published>
    <updated>2017-12-24T08:36:19.178Z</updated>
    
    <content type="html"><![CDATA[<p>逐步补上之前的数据结构实验代码，之后也会不断完善，仅供参考(<em>^▽^</em>)</p><h3 id="顺序表链表的创建输出及两种有序表的合并"><a href="#顺序表链表的创建输出及两种有序表的合并" class="headerlink" title="顺序表链表的创建输出及两种有序表的合并"></a>顺序表链表的创建输出及两种有序表的合并</h3><ul><li>对于顺序表和单链表定义不同的结构体，顺序表通过下标创建并输出<br>链表为带头结点的单链表，使用尾插法创建并输出</li><li>从头开始遍历两个升序表，将更大的存入第三个表中，并将其标记后移<br>对于单链表，需要使用头插法插入第三个单链表中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    顺序表的创建输出及两个升序表合并成一个升序顺序表</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int a[100];</span><br><span class="line">    int len;</span><br><span class="line">&#125;list;</span><br><span class="line"></span><br><span class="line">void inputList(list *L) &#123;</span><br><span class="line">    int x, i = 0;</span><br><span class="line">    printf(&quot;输入一串数(以-1结束)：&quot;);</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123;</span><br><span class="line">        L-&gt;a[i] = x;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;len = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printList(list *L) &#123;</span><br><span class="line">    printf(&quot;\n线性表为：&quot;);</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; L-&gt;len ; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, L-&gt;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertList(list *L, int x) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = L-&gt;len-1; i &gt; 0 &amp;&amp; L-&gt;a[i] &gt; x; i--) &#123;</span><br><span class="line">        L-&gt;a[i+1] = L-&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;a[i+1] = x;</span><br><span class="line">    L-&gt;len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergeDoubleUp(list *L1, list *L2, list *L3) &#123;</span><br><span class="line">    int i = 0, j = 0, tail = 0;</span><br><span class="line">    while(i &lt; L1-&gt;len &amp;&amp; j &lt; L2-&gt;len) &#123;</span><br><span class="line">        if(L1-&gt;a[i] &lt; L2-&gt;a[j]) &#123;</span><br><span class="line">            L3-&gt;a[tail] = L1-&gt;a[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            L3-&gt;a[tail] = L2-&gt;a[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        tail++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt; L1-&gt;len) &#123; L3-&gt;a[tail] = L1-&gt;a[i]; i++; tail++; &#125;</span><br><span class="line">    while(j &lt; L2-&gt;len) &#123; L3-&gt;a[tail] = L2-&gt;a[j]; j++; tail++; &#125;</span><br><span class="line">    L3-&gt;len = tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    list L1, L2, L3;</span><br><span class="line">    inputList(&amp;L1);</span><br><span class="line">    inputList(&amp;L2);</span><br><span class="line">    mergeDoubleUp(&amp;L1, &amp;L2, &amp;L3);</span><br><span class="line">    printList(&amp;L3);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    单链表的创建输出、两个升序链表合并为一个降序链表</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct k &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct k *next;</span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line">void createList(node *h) &#123;</span><br><span class="line">    node *p, *tail;</span><br><span class="line">    tail = h;</span><br><span class="line">    int x;</span><br><span class="line">    printf(&quot;输入一串数(以-1结束)：&quot;);</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123;</span><br><span class="line">        p = (node *)malloc(sizeof(node));</span><br><span class="line">        p-&gt;data = x; p-&gt;next = NULL;</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printList(node *h) &#123;</span><br><span class="line">    node *p;</span><br><span class="line">    for(p = h-&gt;next; p != NULL; p = p-&gt;next) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergeDoubleDown(node *h1, node *h2, node *h3) &#123;</span><br><span class="line">    node *i, *j, *head;</span><br><span class="line">    i = h1-&gt;next; j = h2-&gt;next;</span><br><span class="line">    while(i != NULL &amp;&amp; j != NULL) &#123;</span><br><span class="line">        if(i-&gt;data &lt; j-&gt;data) &#123;</span><br><span class="line">            head = i;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head = j;</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 头插法建立h3链表</span><br><span class="line">        head-&gt;next = h3-&gt;next;</span><br><span class="line">        h3-&gt;next = head;</span><br><span class="line">    &#125;</span><br><span class="line">    // 尾部处理</span><br><span class="line">    while(i != NULL) &#123;</span><br><span class="line">        head = (node *)malloc(sizeof(node));</span><br><span class="line">        head-&gt;data = i-&gt;data;</span><br><span class="line">        i = i-&gt;next;</span><br><span class="line">        head-&gt;next = h3-&gt;next;</span><br><span class="line">        h3-&gt;next = head;</span><br><span class="line">    &#125;</span><br><span class="line">    while(j != NULL) &#123;</span><br><span class="line">        head = (node *)malloc(sizeof(node));</span><br><span class="line">        head-&gt;data = j-&gt;data;</span><br><span class="line">        j = j-&gt;next;</span><br><span class="line">        head-&gt;next = h3-&gt;next;</span><br><span class="line">        h3-&gt;next = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    node h1, h2, h3;</span><br><span class="line">    h1.next = NULL;</span><br><span class="line">    h2.next = NULL;</span><br><span class="line">    h3.next = NULL;</span><br><span class="line">    createList(&amp;h1);</span><br><span class="line">    createList(&amp;h2);</span><br><span class="line">    printf(&quot;\n链表1为&quot;);printList(&amp;h1);</span><br><span class="line">    printf(&quot;\n链表2为&quot;);printList(&amp;h2);</span><br><span class="line">    mergeDoubleDown(&amp;h1, &amp;h2, &amp;h3);</span><br><span class="line">    printf(&quot;\n链表3为&quot;);printList(&amp;h3);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表的排序及单链表求最值"><a href="#顺序表的排序及单链表求最值" class="headerlink" title="顺序表的排序及单链表求最值"></a>顺序表的排序及单链表求最值</h3><ul><li>通过两次循环，默认为升序，如果第一次循环出现降序则进入第二次循环，第二次循环若出现升序则说明无序</li><li>设置两个标记分别从两边遍历，左为奇数时左标记继续，右为偶数时右标记继续，直到左为偶数右为奇数时则交换</li><li>设置当前标记和前驱标记遍历整个单链表，并通过预设的最大标记指针和最大前驱标记指针不断比较，遍历完最大标记指针就指向最大值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    判断顺序表是否有序、实现奇偶分开、实现选择排序算法</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int isSort(sort *L) &#123;  // 返回-1说明无序，1则有序</span><br><span class="line">    int i, j;</span><br><span class="line">    // 两次循环判断</span><br><span class="line">    for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123;</span><br><span class="line">        if(L-&gt;a[i] &gt; L-&gt;a[j]) &#123;</span><br><span class="line">            for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123;</span><br><span class="line">                if(L-&gt;a[i] &lt; L-&gt;a[j]) return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void divert(sort *L) &#123;</span><br><span class="line">    int i = 0, j = L-&gt;len-1;</span><br><span class="line">    while(i &lt; j) &#123;</span><br><span class="line">        while(L-&gt;a[i] % 2 != 0) i++;</span><br><span class="line">        while(L-&gt;a[j] % 2 == 0) j--;</span><br><span class="line">        if(i &lt; j) &#123;</span><br><span class="line">            int temp = L-&gt;a[i];</span><br><span class="line">            L-&gt;a[i] = L-&gt;a[j];</span><br><span class="line">            L-&gt;a[j] = temp;</span><br><span class="line">        &#125; else break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void selectSort(sort *L) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; L-&gt;len; i++) &#123;</span><br><span class="line">        int min = i, j;</span><br><span class="line">        for(j = i; j &lt; L-&gt;len; j++) &#123;</span><br><span class="line">            if(L-&gt;a[j] &lt; L-&gt;a[min]) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        int temp = L-&gt;a[min];</span><br><span class="line">        L-&gt;a[min] = L-&gt;a[i];</span><br><span class="line">        L-&gt;a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    选出单链表的最大值并移至末尾</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void removeMax(node *h) &#123;</span><br><span class="line">    node *pre, *p, *preMax, *max;</span><br><span class="line">    preMax = h; max = preMax-&gt;next;</span><br><span class="line">    pre = preMax-&gt;next; p = max-&gt;next;</span><br><span class="line">    for(; p != NULL; p = p-&gt;next, pre = pre-&gt;next) &#123;</span><br><span class="line">        if(p-&gt;data &gt; max-&gt;data) &#123;</span><br><span class="line">            preMax = pre;</span><br><span class="line">            max = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preMax-&gt;next = max-&gt;next;</span><br><span class="line">    pre-&gt;next = max;</span><br><span class="line">    max-&gt;next = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带头指针型单链表及模式匹配算法"><a href="#带头指针型单链表及模式匹配算法" class="headerlink" title="带头指针型单链表及模式匹配算法"></a>带头指针型单链表及模式匹配算法</h3><ul><li>头指针型单链表创建时对于第一个输入单独造头结点，之后与带头结点型单链表相同</li><li>采用递归不断分解直到达最后一个结点输出</li><li>从头开始遍历文本串t，同时不断跟模式串p匹配直到成功或遍历结束匹配失败</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    创建输出头指针型单链表、合并两个升序头指针型单链表为降序、将单链表从尾至首输出</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">node *createList() &#123;</span><br><span class="line">    int x;</span><br><span class="line">    node *h, *p, *tail;</span><br><span class="line">    printf(&quot;输入一串数(以-1结束)：&quot;);</span><br><span class="line">    /* 造头结点 */</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    if(x == -1) return;</span><br><span class="line">    h = (node *)malloc(sizeof(node));</span><br><span class="line">    h-&gt;data = x; h-&gt;next = NULL;</span><br><span class="line">    tail = h;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    while(x != -1) &#123;</span><br><span class="line">            p = (node *)malloc(sizeof(node));</span><br><span class="line">            p-&gt;data = x; p-&gt;next = NULL;</span><br><span class="line">            tail-&gt;next = p;</span><br><span class="line">            tail = p;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printList(node *h) &#123;</span><br><span class="line">    printf(&quot;链表为：&quot;);</span><br><span class="line">    node *p;</span><br><span class="line">    for(p = h; p != NULL; p = p-&gt;next) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node *mergeDoubleDown(node *h1, node *h2, node *h3) &#123;</span><br><span class="line">    node *i, *j, *k;</span><br><span class="line">    i = h1; j = h2;</span><br><span class="line">    while(i != NULL &amp;&amp; j != NULL) &#123;</span><br><span class="line">        if(i-&gt;data &lt; j-&gt;data) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            k-&gt;next = h3;</span><br><span class="line">            h3 = k;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            k = j;</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">            k-&gt;next = h3;</span><br><span class="line">            h3 = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 尾部处理</span><br><span class="line">    while(i != NULL) &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        i = i-&gt;next;</span><br><span class="line">        k-&gt;next = h3;</span><br><span class="line">        h3 = k;</span><br><span class="line">    &#125;</span><br><span class="line">    while(j != NULL) &#123;</span><br><span class="line">        k = j;</span><br><span class="line">        j = j-&gt;next;</span><br><span class="line">        k-&gt;next = h3;</span><br><span class="line">        h3 = k;</span><br><span class="line">    &#125;</span><br><span class="line">    return h3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void revPrintList(node *h) &#123;</span><br><span class="line">    if(h-&gt;next != NULL) &#123;</span><br><span class="line">        revPrintList(h-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d &quot;, h-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    朴素的模式匹配算法</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void creStr(seqString *s) &#123;</span><br><span class="line">    char x; int i = 0;</span><br><span class="line">    while((x = getchar()) != &apos;\n&apos;) &#123;</span><br><span class="line">        s-&gt;str[i] = x;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;len = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int simpleMatch(seqString t, seqString p) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; t.len; i++) &#123;</span><br><span class="line">        if(success(t, p, i)) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int success(seqString t, seqString p, int i) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    for(j = 0; j &lt; p.len; j++) &#123;</span><br><span class="line">        if(t.str[i+j] != p.str[j]) return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稀疏矩阵的转置与递归程序设计"><a href="#稀疏矩阵的转置与递归程序设计" class="headerlink" title="稀疏矩阵的转置与递归程序设计"></a>稀疏矩阵的转置与递归程序设计</h3><ul><li>首先将行列数与非零元数存入第一个三元组，再根据输入将非零元存入对应位置<br>快速转置时需要一遍扫描填入非零元所在的新位置数组，之后一步转置</li><li>递归时传入空格的个数作为参数，将空格作为数字</li><li>递归分解整体成第一个和其余个数为两部分进行比较返回比较结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    稀疏矩阵的创建输出、朴素转置与快速转置</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int r, c, e;</span><br><span class="line">&#125;SYZ;</span><br><span class="line"></span><br><span class="line"> void inputMatrix(SYZ ma[]) &#123;</span><br><span class="line">    int i = 0, m = 0, n = 0, r = 0, c = 0, e = 0;</span><br><span class="line">    printf(&quot;输入行数和列数(m n)：&quot;);</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;m, &amp;n);</span><br><span class="line">    ma[0].r = m; ma[0].c = n;</span><br><span class="line">    printf(&quot;\n输入三元组(格式如3 4 5), 以回车分隔, 输入0 0 0结束：\n&quot;);</span><br><span class="line">    scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e);</span><br><span class="line">    while(r != 0) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        ma[i].r = r;</span><br><span class="line">        ma[i].c = c;</span><br><span class="line">        ma[i].e = e;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e);</span><br><span class="line">    &#125;</span><br><span class="line">    ma[0].e = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printMatrix(SYZ m[]) &#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    int k = 1;</span><br><span class="line">    printf(&quot;\n矩阵为：\n&quot;);</span><br><span class="line">    for(i = 1; i &lt;= m[0].r; i++) &#123;</span><br><span class="line">        for(j = 1; j &lt;= m[0].c; j++) &#123;</span><br><span class="line">            if(k &lt;= m[0].e &amp;&amp; m[k].r == i &amp;&amp; m[k].c == j) &#123; printf(&quot; %d &quot;, m[k].e); k++; &#125;</span><br><span class="line">            else printf(&quot; 0 &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void generalTrans(SYZ ma[], SYZ mb[]) &#123;</span><br><span class="line">    if(ma[0].e == 0) return;</span><br><span class="line">    // 行列维数互换</span><br><span class="line">    mb[0].r = ma[0].c;</span><br><span class="line">    mb[0].c = ma[0].r;</span><br><span class="line">    mb[0].e = ma[0].e;</span><br><span class="line">    // 扫描ma三元组,依次加到mb中</span><br><span class="line">    int k, col, e;</span><br><span class="line">    for(k = 1, col = 1; col &lt;= ma[0].c; col++) &#123;</span><br><span class="line">        for(e = 1; e &lt;= ma[0].e; e++) &#123;</span><br><span class="line">            if(ma[e].c == col) &#123;</span><br><span class="line">                mb[k].r = ma[e].c;</span><br><span class="line">                mb[k].c = ma[e].r;</span><br><span class="line">                mb[k].e = ma[e].e;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fillNum(SYZ m[], int num[]) &#123;</span><br><span class="line">    // 计算不同元素的个数, 存入num[]</span><br><span class="line">    int i, k;</span><br><span class="line">    for(i = 0; i &lt;= m[0].c; i++) num[i] = 0;</span><br><span class="line">    for(i = 0; i &lt;= m[0].e; i++) &#123;</span><br><span class="line">        k = m[i].c;</span><br><span class="line">        num[k]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fillPos(int num[], int pos[], int len) &#123;</span><br><span class="line">    pos[1] = 1;</span><br><span class="line">    int k;  // 从2到原列数</span><br><span class="line">    for(k = 2; k &lt;= len; k++) pos[k] = pos[k-1]+ num[k-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quickTrans(SYZ ma[], SYZ mb[]) &#123;</span><br><span class="line">    // 一遍扫描，获取num[]和pos[]</span><br><span class="line">    int num[20], pos[20];</span><br><span class="line">    fillNum(ma, num);</span><br><span class="line">    fillPos(num, pos, ma[0].c);</span><br><span class="line">    // 一步转置</span><br><span class="line">    int i, k, c;</span><br><span class="line">    mb[0].r = ma[0].c;</span><br><span class="line">    mb[0].c = mb[0].r;</span><br><span class="line">    mb[0].e = mb[0].e;</span><br><span class="line">    for(i = 1; i &lt;= ma[0].e; i++) &#123;</span><br><span class="line">        c = ma[i].c; k = pos[c];</span><br><span class="line">        mb[k].r = ma[i].c;</span><br><span class="line">        mb[k].c = ma[i].r;</span><br><span class="line">        mb[k].e = ma[i].e;</span><br><span class="line">        pos[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    递归打印数字金字塔</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void printTriangle(int j, int n) &#123;</span><br><span class="line">    if(n &lt;= 0) return;</span><br><span class="line">    printTriangle(j+1, n-1);</span><br><span class="line"></span><br><span class="line">    // 打印第n行</span><br><span class="line">    int i;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    for(i = 0; i &lt; j; i++) printf(&quot;   &quot;);</span><br><span class="line">    for(i = 1; i &lt;= n; i++) printf(&quot;%3d&quot;, i);</span><br><span class="line">    for(i = n-1; i &gt;0; i--) printf(&quot;%3d&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    递归查找顺序表元素下标、最大值下标</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int find(List L, int i, int j, int x) &#123;</span><br><span class="line">    if(i &gt; j) return -1;</span><br><span class="line">    if(L.arr[i] == x) return i;</span><br><span class="line">    else return find(L, i+1, j, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findMax(List L, int i, int j) &#123;</span><br><span class="line">    if(i &gt; j) return -1;</span><br><span class="line">    if(i == j) return i;</span><br><span class="line">    int k = findMax(L, i+1, j);</span><br><span class="line">    if(L.arr[i] &gt; L.arr[k]) return i;</span><br><span class="line">    else return k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建二叉树及前中后序遍历输出"><a href="#创建二叉树及前中后序遍历输出" class="headerlink" title="创建二叉树及前中后序遍历输出"></a>创建二叉树及前中后序遍历输出</h3><ul><li>输入字母，#代表NULL，然后先建左子树，再建右子树</li><li>前序递归先输出根的值再遍历左子树，最后遍历右子树；中序递归先遍历左子树，再输出根值，再遍历右子树；后序递归先遍历左、右子树，再输出根值</li><li>前序非递归需要先输出根值，然后保存回溯点，再进入左子树，到底后根据回溯点进入右子树；而后序非递归需要先保存回溯点，进入左子树，然后再输出回溯点值，进入右子树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    创建二叉树</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">typedef struct k&#123;</span><br><span class="line">    char data;</span><br><span class="line">    struct k *L, *R;</span><br><span class="line">&#125;bTree;</span><br><span class="line"></span><br><span class="line">bTree *creaTree() &#123;</span><br><span class="line">    bTree *t;</span><br><span class="line">    char c = getchar();</span><br><span class="line">    if(c == &apos;#&apos;) return NULL;</span><br><span class="line">    t = malloc(sizeof(bTree));</span><br><span class="line">    t-&gt;data = c;</span><br><span class="line">    t-&gt;L = creaTree();</span><br><span class="line">    t-&gt;R = creaTree();</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    前中后序递归算法</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void preTraverse(bTree *t) &#123;</span><br><span class="line">    if(t == NULL) return;</span><br><span class="line">    printf(&quot;%c &quot;, t-&gt;data);</span><br><span class="line">    preTraverse(t-&gt;L);</span><br><span class="line">    preTraverse(t-&gt;R);</span><br><span class="line">&#125;</span><br><span class="line">void midTraverse(bTree *t) &#123;</span><br><span class="line">    if(t == NULL) return;</span><br><span class="line">    midTraverse(t-&gt;L);</span><br><span class="line">    printf(&quot;%c &quot;, t-&gt;data);</span><br><span class="line">    midTraverse(t-&gt;R);</span><br><span class="line">&#125;</span><br><span class="line">void postTraverse(bTree *t) &#123;</span><br><span class="line">    if(t == NULL) return;</span><br><span class="line">    postTraverse(t-&gt;L);</span><br><span class="line">    postTraverse(t-&gt;R);</span><br><span class="line">    printf(&quot;%c &quot;, t-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    前序、中序非递归算法</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    bTree *a[Max];</span><br><span class="line">    int top;</span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line">void initStack(Stack *S) &#123; S-&gt;top = 0; &#125;</span><br><span class="line"></span><br><span class="line">void push(Stack *S, bTree *t) &#123;</span><br><span class="line">    if(t == NULL || S-&gt;top == Max-1) return;</span><br><span class="line">    S-&gt;a[S-&gt;top] = t;</span><br><span class="line">    S-&gt;top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bTree *pop(Stack *S) &#123;</span><br><span class="line">    bTree *t;</span><br><span class="line">    if(S-&gt;top == 0) return NULL;</span><br><span class="line">    S-&gt;top--;</span><br><span class="line">    t = S-&gt;a[S-&gt;top];</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int empty(Stack *S) &#123;</span><br><span class="line">    if(S-&gt;top == 0) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void preDisplay(bTree *t) &#123;</span><br><span class="line">    Stack S; initStack(&amp;S);</span><br><span class="line">    while(t != NULL || !empty(&amp;S)) &#123;</span><br><span class="line">        if(t != NULL) &#123;</span><br><span class="line">            printf(&quot;%c &quot;, t-&gt;data);</span><br><span class="line">            push(&amp;S, t);</span><br><span class="line">            t = t-&gt;L;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            t = pop(&amp;S);</span><br><span class="line">            t = t-&gt;R;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void midDisplay(bTree *t) &#123;</span><br><span class="line">    Stack S; initStack(&amp;S);</span><br><span class="line">    while(t != NULL || !empty(&amp;S)) &#123;</span><br><span class="line">        if(t != NULL) &#123;</span><br><span class="line">            push(&amp;S, t);</span><br><span class="line">            t = t-&gt;L;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            t = pop(&amp;S);</span><br><span class="line">            printf(&quot;%c &quot;, t-&gt;data);</span><br><span class="line">            t = t-&gt;R;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有向网络邻接表的创建及优先遍历"><a href="#有向网络邻接表的创建及优先遍历" class="headerlink" title="有向网络邻接表的创建及优先遍历"></a>有向网络邻接表的创建及优先遍历</h3><ul><li>先初始化结点数和边数，再输入顶点信息初始化顶点表，最后输入两边结点和权值信息利用头插法将新边表结点逐个插入到顶点头部</li><li>出度直接找到对应顶点计算边表结点个数，入度需要通过遍历整个顶点表找到边表结点值为该值的结点计算个数</li><li>从任意结点开始深度优先遍历即访问对应顶点下的未访问过的邻接点，根据邻接点的值访问对应的顶点，直至为空；广度优先遍历类似于二叉树的层次遍历，利用队列操作，默认从0开始，没访问过则访问并将顶点入队，然后顶点出队并依次访问该顶点下的邻接点，邻接点未访问过则访问并入队，直至为空</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    创建有向网络邻接表</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">typedef struct k1 &#123;</span><br><span class="line">    int eData;  // 边点下标</span><br><span class="line">    int weight;</span><br><span class="line">    struct k1 *next;</span><br><span class="line">&#125;eNode;  // 边表结点</span><br><span class="line"></span><br><span class="line">typedef struct k2 &#123;</span><br><span class="line">    int vData;  // 顶点下标</span><br><span class="line">    eNode *first; // 边表头指针</span><br><span class="line">&#125;vNode;  // 顶点表结点</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    vNode adjList[Max];</span><br><span class="line">    int numV, numE;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line">int visited[Max] = &#123;0&#125;;  // 访问状态数组</span><br><span class="line"></span><br><span class="line">void creaALGraph(ALGraph *G) &#123;</span><br><span class="line">    int i, j, vi, vj, weight; eNode *e;</span><br><span class="line">    printf(&quot;请输入结点数n和边数e&lt;n,e&gt;：&quot;);</span><br><span class="line">    scanf(&quot;&lt;%d,%d&gt;&quot;, &amp;G-&gt;numV, &amp;G-&gt;numE);</span><br><span class="line">    // 建立顶点表</span><br><span class="line">    printf(&quot;请连续输入顶点信息&lt;V&gt;：\n&quot;);</span><br><span class="line">    fflush(stdin);</span><br><span class="line">    for(i = 0; i &lt; G-&gt;numV; i++) &#123;</span><br><span class="line">        scanf(&quot;&lt;%d&gt;&quot;, &amp;(G-&gt;adjList[i].vData));</span><br><span class="line">        G-&gt;adjList[i].first = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // 建立边表</span><br><span class="line">    printf(&quot;连续输入两边结点和权值&lt;vi,vj,weight&gt;：\n&quot;);</span><br><span class="line">    fflush(stdin);</span><br><span class="line">    for(j = 0; j &lt; G-&gt;numE; j++) &#123;</span><br><span class="line">        scanf(&quot;&lt;%d,%d,%d&gt;&quot;, &amp;vi, &amp;vj, &amp;weight);</span><br><span class="line">        e = (eNode *)malloc(sizeof(eNode));</span><br><span class="line">        e-&gt;eData = vj;</span><br><span class="line">        e-&gt;weight = weight;</span><br><span class="line">        e-&gt;next = G-&gt;adjList[vi].first;   // 将新边表结点插入到顶点Vi头部</span><br><span class="line">        G-&gt;adjList[vi].first = e;         // 头插法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printALGraph(ALGraph *G) &#123;</span><br><span class="line">    int i, j; eNode *p;</span><br><span class="line">    for(i = 0; i &lt; G-&gt;numV; i++) &#123;</span><br><span class="line">        printf(&quot;%3d-&gt;&quot;, G-&gt;adjList[i].vData);</span><br><span class="line">        p = G-&gt;adjList[i].first;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            printf(&quot;%3d&quot;, p-&gt;eData);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    输出指定结点的入度和出度</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int getInDegree(ALGraph *G, int n) &#123;</span><br><span class="line">    int count = 0, i; eNode *e;</span><br><span class="line">    for(i = 0; i &lt; G-&gt;numV; i++) &#123;</span><br><span class="line">        if(G-&gt;adjList[i].vData != n) &#123;</span><br><span class="line">            e = G-&gt;adjList[i].first;</span><br><span class="line">            while(e != NULL) &#123;</span><br><span class="line">                if(e-&gt;eData == n) count++;</span><br><span class="line">                e = e-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getOutDegree(ALGraph *G, int n) &#123;</span><br><span class="line">    int count = 0, i; eNode *e;</span><br><span class="line">    for(i = 0; i &lt; G-&gt;numV; i++) &#123;</span><br><span class="line">        if(G-&gt;adjList[i].vData == n) &#123;</span><br><span class="line">            e = G-&gt;adjList[i].first;</span><br><span class="line">            while(e != NULL) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                e = e-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    输出深度优先遍历和广度优先遍历结果</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int f, r;</span><br><span class="line">    int a[Max];</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line">void DFS(ALGraph *G, int i) &#123;</span><br><span class="line">    eNode *p;</span><br><span class="line">    if(visited[i]) return;</span><br><span class="line">    printf(&quot;%d &quot;, G-&gt;adjList[i].vData); visited[i] = 1;</span><br><span class="line">    p = G-&gt;adjList[i].first;</span><br><span class="line">    while(p) &#123;</span><br><span class="line">        if(visited[p-&gt;eData] == 0) DFS(G, p-&gt;eData);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void initQueue(Queue *Q) &#123; Q-&gt;f = 0; Q-&gt;r = 0; &#125;</span><br><span class="line"></span><br><span class="line">void inQueue(Queue *Q, int i) &#123;</span><br><span class="line">    if((Q-&gt;r+1)%Max == Q-&gt;f) return;</span><br><span class="line">    Q-&gt;a[Q-&gt;r] = i;</span><br><span class="line">    Q-&gt;r = (Q-&gt;r+1)%Max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int outQueue(Queue *Q) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(Q-&gt;f == Q-&gt;r) return;</span><br><span class="line">    i = Q-&gt;a[Q-&gt;f];</span><br><span class="line">    Q-&gt;f = (Q-&gt;f+1)%Max;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int isEmpty(Queue *Q) &#123;</span><br><span class="line">    if(Q-&gt;f == Q-&gt;r) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS(ALGraph *G) &#123;</span><br><span class="line">    int i; eNode *p; Queue Q;</span><br><span class="line">    for(i = 0; i &lt; G-&gt;numV; i++) visited[i] = 0;  // 初始化访问状态</span><br><span class="line">    initQueue(&amp;Q);</span><br><span class="line">    for(i = 0; i &lt; G-&gt;numV; i++) &#123;                // 默认从0开始遍历</span><br><span class="line">        if(visited[i] == 0) &#123;</span><br><span class="line">            visited[i] = 1;</span><br><span class="line">            printf(&quot;%d &quot;, G-&gt;adjList[i].vData);   // 没访问过则访问并将顶点入队</span><br><span class="line">            inQueue(&amp;Q, i);</span><br><span class="line">            while(!isEmpty(&amp;Q)) &#123;</span><br><span class="line">                int i = outQueue(&amp;Q);</span><br><span class="line">                p = G-&gt;adjList[i].first;          // 顶点出队, 依次访问该顶点下的邻接点</span><br><span class="line">                while(p) &#123;</span><br><span class="line">                    if(visited[p-&gt;eData] == 0) &#123;  // 邻接点未访问过则访问并入队</span><br><span class="line">                        visited[p-&gt;eData] = 1;</span><br><span class="line">                        printf(&quot;%d &quot;, G-&gt;adjList[p-&gt;eData].vData);</span><br><span class="line">                        inQueue(&amp;Q, p-&gt;eData);</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找与二叉排序树"><a href="#二分查找与二叉排序树" class="headerlink" title="二分查找与二叉排序树"></a>二分查找与二叉排序树</h3><ul><li>递归的划分判断对应下标值与key的大小而调整递归对应区间返回结果，非递归的划分通过while循环判断调整区间返回相等时的下标值，基于x:y的划分只是公式特殊一些</li><li>二叉排序树的创建就是不断插入结点的过程，使用递归时需要注意真正插入到子树，删除结点需要分度数：0度结点直接删除，1度结点由孙代子，2度结点找到前驱交换值后再删除1度结点</li><li>分块索引表的前提是数据分块有序，以界限为下标，对应的key为块的最大值，从而可以通过索引表快速查找到值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    递归与非递归实现基于x:y的划分查找</span><br><span class="line"> */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int a[100];</span><br><span class="line">    int len;</span><br><span class="line">&#125;list;</span><br><span class="line"></span><br><span class="line">void inputList(list *L) &#123;</span><br><span class="line">    int x, i = 0;</span><br><span class="line">    printf(&quot;输入一串数(以-1结束)：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    while(x != -1) &#123;</span><br><span class="line">        L-&gt;a[i] = x;</span><br><span class="line">        i++;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;len = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printList(list *L) &#123;</span><br><span class="line">    printf(&quot;\n线性表为：&quot;);</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; L-&gt;len ; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, L-&gt;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int BinSearchCurison(list *L, int Low, int High, int key, int X, int Y) &#123;</span><br><span class="line">    int m;</span><br><span class="line">    if(Low &gt; High) return -1;</span><br><span class="line">    m = Low + (High-Low)*X/(X+Y);   // 按比例划分</span><br><span class="line">    if(L-&gt;a[m] == key) return m;</span><br><span class="line">    if(L-&gt;a[m] &gt; key) return BinSearch(L, Low, m-1, key, X, Y);</span><br><span class="line">    else return BinSearch(L, m+1, High, key, X, Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int BinSearch(list *L, int Low, int High, int key, int X, int Y) &#123;</span><br><span class="line">    int m;</span><br><span class="line">    while(Low &lt;= High) &#123;</span><br><span class="line">        m = Low + (High-Low)*X/(X+Y);</span><br><span class="line">        if(L-&gt;a[m] == key) return m;</span><br><span class="line">        else if(L-&gt;a[m] &gt; key) High = m-1;</span><br><span class="line">        else Low = m+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    创建二叉排序树并对其进行查找、插入和删除，使用中序遍历验证</span><br><span class="line"> */</span><br><span class="line">#define Max 100</span><br><span class="line">typedef struct k&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct k *L, *R;</span><br><span class="line">&#125;bTree;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    bTree *a[Max];</span><br><span class="line">    int top;</span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line">bTree *insertBSTree(bTree *t, int x) &#123;</span><br><span class="line">    bTree *p;</span><br><span class="line">    p = malloc(sizeof(bTree));</span><br><span class="line">    p-&gt;data = x; p-&gt;L = NULL; p-&gt;R = NULL;</span><br><span class="line">    if(t == NULL) return p;</span><br><span class="line">    if(x &lt;= t-&gt;data) t-&gt;L = insertBSTree(t-&gt;L, x);</span><br><span class="line">    else t-&gt;R = insertBSTree(t-&gt;R, x);</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bTree *creaTree() &#123;</span><br><span class="line">    bTree *t; int x;</span><br><span class="line">    t = NULL;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    while(x != -1) &#123;</span><br><span class="line">        t = insertBSTree(t, x);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void midTraverse(bTree *t) &#123;</span><br><span class="line">    if(t == NULL) return;</span><br><span class="line">    midTraverse(t-&gt;L);</span><br><span class="line">    printf(&quot;%d &quot;, t-&gt;data);</span><br><span class="line">    midTraverse(t-&gt;R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bTree *searchBST(bTree *t, int x) &#123;</span><br><span class="line">    if(t == NULL) return NULL;</span><br><span class="line">    if(x == t-&gt;data) return t;</span><br><span class="line">    if(x &lt; t-&gt;data) return searchBST(t-&gt;L, x);</span><br><span class="line">    else return searchBST(t-&gt;R, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FindBST(bTree **t, bTree **pre, bTree **p, int x) &#123;</span><br><span class="line">    *pre = NULL; *p = *t;</span><br><span class="line">    while((*p) != NULL) &#123;  // 查找到对应的结点，p指向它，pre指向p的双亲</span><br><span class="line">        if((*p)-&gt;data == x) break;</span><br><span class="line">        if(x &lt; (*p)-&gt;data) &#123; (*pre) = (*p); (*p) = (*p)-&gt;L; &#125;</span><br><span class="line">        else &#123; (*pre) = (*p); (*p) = (*p)-&gt;R; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void del_0(bTree **pre, bTree **p) &#123;</span><br><span class="line">    if((*pre)-&gt;L == *p) (*pre)-&gt;L = NULL;</span><br><span class="line">    else if((*pre)-&gt;R == *p) (*pre)-&gt;R = NULL;</span><br><span class="line">    free(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void del_1(bTree **pre, bTree **p) &#123;</span><br><span class="line">    if((*pre)-&gt;L == *p) &#123;  // 判断p是左子树还是右子树</span><br><span class="line">        if((*p)-&gt;L != NULL) (*pre)-&gt;L = (*p)-&gt;L;</span><br><span class="line">        else (*pre)-&gt;L = (*p)-&gt;R;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if((*p)-&gt;L != NULL) (*pre)-&gt;R = (*p)-&gt;L;</span><br><span class="line">        else (*pre)-&gt;R = (*p)-&gt;R;</span><br><span class="line">    &#125;</span><br><span class="line">    free(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void del_2(bTree **p) &#123;  // 前驱替换</span><br><span class="line">    bTree *preQ, *q; int temp;</span><br><span class="line">    preQ = (*p); q = (*p)-&gt;L;</span><br><span class="line">    while(q-&gt;R != NULL) &#123; preQ = q; q = q-&gt;R; &#125;;  // 找到p的前驱q, q的双亲preQ</span><br><span class="line">    temp = (*p)-&gt;data;         // p、q值互换</span><br><span class="line">    (*p)-&gt;data = q-&gt;data;</span><br><span class="line">    q-&gt;data = temp;</span><br><span class="line">    if(preQ-&gt;L == q) &#123;   // 删除1度结点q</span><br><span class="line">        if(q-&gt;L != NULL) preQ-&gt;L = q-&gt;L;</span><br><span class="line">        else preQ-&gt;L = q-&gt;R;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if(q-&gt;L != NULL) preQ-&gt;R = q-&gt;L;</span><br><span class="line">        else preQ-&gt;R = q-&gt;R;</span><br><span class="line">    &#125;</span><br><span class="line">    free(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bTree *delBST(bTree *t, int x) &#123;</span><br><span class="line">    bTree *pre, *p;</span><br><span class="line">    if(t == NULL) return NULL;</span><br><span class="line">    FindBST(&amp;t, &amp;pre, &amp;p, x);</span><br><span class="line"></span><br><span class="line">    // 删除0度结点</span><br><span class="line">    if(p-&gt;L == NULL &amp;&amp; p-&gt;R == NULL) del_0(&amp;pre, &amp;p);</span><br><span class="line">    // 删除1度结点</span><br><span class="line">    else if((p-&gt;L == NULL) != (p-&gt;R == NULL)) del_1(&amp;pre, &amp;p);</span><br><span class="line">    // 删除2度结点</span><br><span class="line">    else if(p-&gt;L != NULL &amp;&amp; p-&gt;R != NULL) del_2(&amp;p);</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    创建分块索引表，并进行查找</span><br><span class="line"> */</span><br><span class="line">#define M 30</span><br><span class="line">#define DIS 7</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int a[M];</span><br><span class="line">    int len;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int addr; // 地址</span><br><span class="line">    int key;  // 关键字</span><br><span class="line">&#125;sNode;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    sNode s[M];</span><br><span class="line">    int len;</span><br><span class="line">&#125;sList;</span><br><span class="line"></span><br><span class="line">void creaList(List *L) &#123;</span><br><span class="line">    int x, i = 0;</span><br><span class="line">    printf(&quot;输入一串数(-1结束)：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    while(x != -1) &#123;</span><br><span class="line">        L-&gt;a[i] = x; i++;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;len = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printList(List *L) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; L-&gt;len; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, L-&gt;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void creaSList(sList *S, List *L) &#123;</span><br><span class="line">    int i, j, max, k = 0;</span><br><span class="line">    for(i = 0; i &lt; L-&gt;len; i=i+DIS) &#123;</span><br><span class="line">        max = L-&gt;a[i];</span><br><span class="line">        for(j = i; j &lt; i+DIS &amp;&amp; j &lt; L-&gt;len; j++) &#123;</span><br><span class="line">            if(L-&gt;a[j] &gt; max) max = L-&gt;a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        S-&gt;s[k].addr = i;</span><br><span class="line">        S-&gt;s[k].key  = max;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;len = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printSList(sList *S) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; S-&gt;len; i++) &#123;</span><br><span class="line">        printf(&quot;%d--%d &quot;, S-&gt;s[i].addr, S-&gt;s[i].key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sListFind(sList *S, List *L, int x) &#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    for(i = 0; i &lt; S-&gt;len; i++) &#123;</span><br><span class="line">        if(S-&gt;s[i].key == x) return S-&gt;s[i].addr;</span><br><span class="line">        else if(S-&gt;s[i].key &gt; x) &#123;  // 进入顺序表</span><br><span class="line">            for(j = S-&gt;s[i].addr; j &lt; S-&gt;s[i].addr+DIS &amp;&amp; j &lt; L-&gt;len; j++) &#123;</span><br><span class="line">                if(L-&gt;a[j] == x) return j;</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><ul><li>首先从最后一个双亲开始进行堆调整，然后将堆顶与堆的末尾位置（哨位）交换，之后去掉哨位，重复进行堆调整、交换过程直至排序完成，根据大根堆还是小根堆实现升序或降序排序</li><li>以最开始的元素x为基准，从最后一位开始设标志位，违反大小规则就交换头尾两边，将数据集分成左边小于x和右边大于x两个集合，重复这样的过程直至有序</li><li>从头至尾，归并所有相邻有序段，类似于两个升序表合并，利用辅助的数组保存归并结果，最终一趟归并完成所有归并</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    堆排序</span><br><span class="line"> */</span><br><span class="line">#define M 30</span><br><span class="line">int initArray(int a[]) &#123;</span><br><span class="line">    int x, i;</span><br><span class="line">    i = 0; a[i] = -1; i++;</span><br><span class="line">    printf(&quot;输入关键字(-1结束)：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    while(x != -1) &#123;</span><br><span class="line">        a[i] = x; i++;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    return i-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int minChildPos(int a[], int i, int n) &#123;</span><br><span class="line">    int k = i*2;</span><br><span class="line">    if(k &gt; n) return -1;</span><br><span class="line">    if(k+1 &gt; n || a[k] &lt; a[k+1]) return k;</span><br><span class="line">    return k+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void adjustHeap(int a[], int i, int n) &#123;</span><br><span class="line">    int t, k;</span><br><span class="line">    t = a[i]; k = minChildPos(a, i, n);</span><br><span class="line">    while(k != -1 &amp;&amp; t &gt; a[k]) &#123;</span><br><span class="line">        a[i] = a[k]; i = k;</span><br><span class="line">        k = minChildPos(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heapSort(int a[], int n) &#123;</span><br><span class="line">    int t, i;</span><br><span class="line">    // 第一次堆调整</span><br><span class="line">    for(i = n/2; i &gt;= 1; i--) &#123;</span><br><span class="line">        adjustHeap(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    // 极值交换排序</span><br><span class="line">    for(i = n; i &gt; 1; i--) &#123;</span><br><span class="line">        t = a[i];</span><br><span class="line">        a[i] = a[1];</span><br><span class="line">        a[1] = t;</span><br><span class="line">        adjustHeap(a, 1, i-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    快速排序</span><br><span class="line"> */</span><br><span class="line">#define M 30</span><br><span class="line">int initArray(int a[]) &#123;</span><br><span class="line">    int x, i = 0;</span><br><span class="line">    printf(&quot;输入关键字(-1结束)：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    while(x != -1) &#123;</span><br><span class="line">        a[i] = x; i++;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    return i-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quickSort(int a[], int L, int H) &#123;</span><br><span class="line">    int i, j, t;</span><br><span class="line">    i = L, j = H; t = a[i];</span><br><span class="line">    if(i &gt; j) return;</span><br><span class="line">    while(i &lt; j) &#123;</span><br><span class="line">        while(i &lt; j &amp;&amp; a[j] &gt;= t) j--;</span><br><span class="line">        if(i &lt; j) &#123; a[i] = a[j]; i++; &#125;</span><br><span class="line">        while(i &lt; j &amp;&amp; a[i] &lt;= t) i++;</span><br><span class="line">        if(i &lt; j) &#123; a[j] = a[i]; j--; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = t;</span><br><span class="line">    quickSort(a, L, j-1);</span><br><span class="line">    quickSort(a, i+1, H);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    归并排序</span><br><span class="line"> */</span><br><span class="line">#define M 30</span><br><span class="line">int initArray(int a[]) &#123;</span><br><span class="line">    int x, i = 0;</span><br><span class="line">    printf(&quot;输入关键字(-1结束)：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    while(x != -1) &#123;</span><br><span class="line">        a[i] = x; i++;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    return i-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergeOne(int a[], int b[], int len, int staPos, int step) &#123;</span><br><span class="line">    int i, j, k, endi, endj;</span><br><span class="line">    i = staPos; j = i + step; k = i;</span><br><span class="line">    if(j &gt;= len) &#123; for(j = i; j &lt; len; j++) b[j] = a[j]; return; &#125;</span><br><span class="line">    endi = j-1; endj = (j+step-1&lt;len)?j+step-1:len-1;</span><br><span class="line">    while(i &lt;= endi &amp;&amp; j &lt;= endj) &#123;</span><br><span class="line">        if(a[i] &lt;= a[j]) &#123; b[k] = a[i]; i++; &#125;</span><br><span class="line">        else &#123; b[k] = a[j]; j++; &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt;= endi) &#123; b[k] = a[i]; k++; i++; &#125;</span><br><span class="line">    while(j &lt;= endj) &#123; b[k] = a[j]; k++; j++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergeAll(int a[], int b[], int len, int step) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; len; i=i+2*step) mergeOne(a, b, len, i, step);</span><br><span class="line">    for(i = 0; i &lt; len; i++) a[i] = b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergeSort(int a[], int b[], int len) &#123;</span><br><span class="line">    int step;</span><br><span class="line">    for(step = 1; step &lt; len; step=step*2) mergeAll(a, b, len, step);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;逐步补上之前的数据结构实验代码，之后也会不断完善，仅供参考(&lt;em&gt;^▽^&lt;/em&gt;)&lt;/p&gt;
&lt;h3 id=&quot;顺序表链表的创建输出及两种有序表的合并&quot;&gt;&lt;a href=&quot;#顺序表链表的创建输出及两种有序表的合并&quot; class=&quot;headerlink&quot; title=&quot;顺序表
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://jeremygo.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖与函数节流</title>
    <link href="https://jeremygo.cn/2017/11/23/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    <id>https://jeremygo.cn/2017/11/23/函数防抖与函数节流/</id>
    <published>2017-11-23T11:15:07.000Z</published>
    <updated>2017-11-23T11:20:18.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>► 实际开发中以下场景往往由于事件频繁被触发，从而频繁执行DOM操作、资源加载等行为，导致页面卡顿甚至浏览器崩溃：</p><ol><li><p>window对象的 resize、scroll 事件</p></li><li><p>拖拽时的 mousemove 事件</p></li><li><p>射击游戏中的 mousedown、keydown 事件</p></li><li><p>文字输入、自动完成的 keyup 事件</p></li></ol><p>► 对于 window 的 resize 事件，实际需求一般是停止改变大小n毫秒后执行；而其它事件一般是以一定的频率执行。</p><p>► 针对这两种需求就出现了 debounce (防抖) 和 throttle (节流) 两种解决办法</p><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>► 如果用手一直按住一个弹簧，它将不会弹起直到你松手为止，也就是调用动作n毫秒后才会执行该动作，如果n毫秒内再次调用则重新计算执行时间</p><p>简单实现： debounce 方法接收两个参数，一个是需要防抖动的函数 <strong>fn</strong> ，另一个是延迟时间 <strong>delay</strong></p><p><img src="http://i2.bvimg.com/603805/e072301856d82602.png" alt="Markdown"></p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>► 将水龙头拧到水以水滴的形式流出，每隔一段时间就有一滴水流出，也就是预先设定一个执行周期，调用动作的时刻不小于这个执行周期就执行它</p><p>简单实现：throttle 方法也是接收两个参数，一个是需要节流的函数 <strong>fn</strong> ，另一个是函数执行间隔阈值 <strong>threshhold</strong></p><p><img src="http://i2.bvimg.com/603805/a203d2e6fc4b12f0.png" alt="Markdown"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以参考一下防抖和节流与正常触发的对比效果图：<br><img src="http://i2.bvimg.com/603805/d32393a66dcf73c1.png" alt="Markdown"></p><p>► debounce 可以想象成把很多事件压缩成了一个事件，throttle 可以想象成像阀门一样定时打开调节流量</p><p>► 简单来说，debounce 适合只执行一次的情况，比如 搜索框的自动完成：在停止输入后才提交一次ajax请求； throttle 适合每隔一定时间间隔内执行不超过一次的情况，比如 拖动滚动条、移动鼠标、滚轮事件的处理等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;► 实际开发中以下场景往往由于事件频繁被触发，从而频繁执行DOM操作、资源加载等行为，导致页面卡顿甚至浏览器崩溃：&lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://jeremygo.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础概念</title>
    <link href="https://jeremygo.cn/2017/11/23/ES6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://jeremygo.cn/2017/11/23/ES6基础概念/</id>
    <published>2017-11-23T11:14:24.000Z</published>
    <updated>2017-12-02T05:12:57.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h1><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>► 用来声明变量，类似于 <strong>var</strong>，但只在 <strong>let</strong> 命令所在的代码块内有效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let a = 10;</span><br><span class="line">    var b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a // ReferenceError</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure><p>► 使用 <strong>let</strong> ，声明的变量只在块级作用域内有效，因此 <strong>for</strong> 循环的计数器很适合用 <strong>let</strong> 命令</p><p>► <strong>for</strong> 循环还有一个特别之处，设置循环变量的那部分是一个副作用域，而循环体内部是一个单独的子作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    let i = &apos;abs&apos;;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>► <strong>var</strong> 命令会有变量提升，也就是变量可以在声明之前使用，值为 <strong>undefined</strong></p><p>► <strong>let</strong> 命令改变了这种语法行为，它所声明的变量一定要在声明后使用，否则就报错</p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>► 只要块级作用域内存在 <strong>let</strong> 命令，它所声明的变量就绑定这个区域，不受外部的影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line">if(true) &#123;</span><br><span class="line">    tmp = &apos;abc&apos;;  //ReferenceError</span><br><span class="line">    let temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>► 上述代码中虽然存在全局变量 <strong>tmp</strong>,但是块级作用域内 <strong>let</strong> 又声明了一个局部变量 <strong>tmp</strong>，导致后者绑定了这个块级作用域，所以在 <strong>let</strong> 声明变量之前，对 <strong>tmp</strong> 赋值都会报错</p><p>► ES6 明确规定，区块中如果存在 <strong>let</strong> 和 <strong>const</strong> 命令，在语法上，这个区块就形成了”暂时性死区”</p><p>► 这也意味着 <strong>typeof</strong> 命令不再是一个百分百安全的操作，这样规定暂时性死区和 <strong>let</strong>、<strong>const</strong> 语句不出现变量提升，主要就是为了防止变量在声明前就使用它从而减少错误</p><h3 id="不可重复声明"><a href="#不可重复声明" class="headerlink" title="不可重复声明"></a>不可重复声明</h3><p>► <strong>let</strong> 不允许在相同作用域内，重复声明同一个变量，也即不能在函数内部重新声明参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function func(arg) &#123;</span><br><span class="line">    let arg;  //执行会报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func(arg) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        let arg;  //不会报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h1><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>► 用来声明一个只读的常量，一旦声明，值就不能改变，这也意味着，<strong>const</strong> 一旦声明变量就必须立即初始化，不能留到之后再赋值，其它与 <strong>let</strong> 命令类似</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>► <strong>const</strong> 实际保证的，不是变量的值不能改动，而是变量所指向的内存地址不能改动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//添加属性可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">foo.prop;</span><br><span class="line"></span><br><span class="line">//指向另一个对象就会报错</span><br><span class="line">foo = &#123;&#125;;</span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>► ES6 允许使用“箭头”（=&gt;）定义函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line"></span><br><span class="line">//等同于</span><br><span class="line">var f = function(v) &#123;</span><br><span class="line">    return v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>► 如果箭头函数不需要参数或者需要多个参数，就使用圆括号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; 5;</span><br><span class="line">//等同于</span><br><span class="line">var f = function() &#123;</span><br><span class="line">    return 5;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var sum = (num1,num2) =&gt; num1 + num2;</span><br><span class="line">//等同于</span><br><span class="line">var sum = function(num1,num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>► 代码块多于一条语句的话就要用大括号括起来并且使用 <strong>return</strong> 语句返回</p><p>► 由于大括号被解释为代码块，所以箭头函数返回的是一个对象的话，必须在对象外面加上括号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot;&#125;);</span><br><span class="line">//等同于</span><br><span class="line">var getTempItem = function(id) &#123;</span><br><span class="line">    return &#123; id: id, name: &quot;Temp&quot;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>► 箭头函数使表达式更简洁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const isEven = n =&gt; n % 2 == 0;</span><br><span class="line">const square = n =&gt; n * n;</span><br></pre></td></tr></table></figure></p><p>► 其它用途…</p><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>► 函数体内的 <strong>this</strong> 对象，就是定义时所在的对象，而不是使用时所在的对象</p><p>► 不可以当作构造函数，即不能使用 <strong>new</strong> 命令</p><p>► 没有 <strong>arguments</strong> 对象，需要的话可以用 <strong>rest</strong> 参数代替</p><p>► 不能使用 <strong>yield</strong> 命令，所以箭头函数不能用作 <strong>Generator</strong> 函数</p><p>尤其注意第一点，在箭头函数中 <strong>this</strong> 对象的指向是固定的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;id:&apos;, this.id);</span><br><span class="line">    &#125;,100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);  // id: 42</span><br></pre></td></tr></table></figure><p>► 上例中 <strong>setTimeout</strong> 的参数是一个箭头函数，它的定义生效在  <strong>foo</strong> 函数生成时，真正执行就要等到100ms后，如果是普通函数的话，执行时 <strong>this</strong> 应该指向全局对象 <strong>window</strong> ，即输出 <strong>21</strong> ，但箭头函数导致this总是指向函数定义生效时所在的对象( <strong>{id: 42}</strong> )，所以输出 <strong>42</strong> .</p><p>► <strong>this</strong> 指向的固定化，不是箭头函数内部有这样的机制，而是它没有自己的 <strong>this</strong>，所以它内部的 <strong>this</strong> 就是外层代码块的 <strong>this</strong> ,这也是它不能用作构造函数的原因</p><p>所以箭头函数转换成ES5的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;id: &apos;,this.id);</span><br><span class="line">    &#125;,100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var _this = this;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(&apos;id: &apos;,_this.id);</span><br><span class="line">    &#125;,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h1><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>► ES6 允许按照一定模式，从数组和对象中提取值同时对变量进行赋值，这被称为 <strong>解构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c] = [1,2,3];</span><br></pre></td></tr></table></figure><p>上面的代码中从数组中提取值并按照对应位置对变量赋值</p><p>本质上这种写法属于”模式匹配”, 只要等号两边的模式相同，左边的变量就会被赋予对应的值, 如果不完全解构即左边的模式只匹配一部分的右边的数组，解构也成功</p><p>一些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*完全解构*/</span><br><span class="line">let [ , , third] = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;];</span><br><span class="line">third // &apos;baz&apos;</span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [1,2,3,4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2,3,4]</span><br><span class="line"></span><br><span class="line">/*不完全解构*/</span><br><span class="line">let [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line">let [a, [b], d] = [1, [2, 3], 4]</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure></p><p>事实上，只要某种数据结构具有 <strong>Iterator</strong> 接口，都可以采用数组形式的解构赋值</p><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>► 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名才能正确取到值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let &#123; bar, foo &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;</span><br><span class="line">foo // &quot;aa&quot;</span><br><span class="line">bar // &quot;cc&quot;</span><br><span class="line"></span><br><span class="line">let &#123; baz &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;</span><br><span class="line">baz // undefined</span><br><span class="line"></span><br><span class="line">/*变量名与属性名不一致的写法*/</span><br><span class="line">let &#123; foo: baz &#125; = &#123; foo: &apos;aa&apos;, bar: &apos;cc&apos; &#125;;</span><br><span class="line">baz // &quot;aa&quot;</span><br></pre></td></tr></table></figure><p>变量名与属性名不一致的写法实际上说明，对象的解构赋值是下面形式的简写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aa&quot;, bar: &apos;cc&apos; &#125;;</span><br></pre></td></tr></table></figure><p>即对象的解构赋值是先找到同名属性，再赋给对应的变量。真正被赋值的是后者而不是前者</p><p>► 对象的解构赋值，可以很方便地将现有对象的方法赋值给对应的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123; log, sin, cos &#125; = Math;</span><br></pre></td></tr></table></figure><p>解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*交换变量的值*/</span><br><span class="line">let x = 1;</span><br><span class="line">let y = 2;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*从函数返回多个值*/</span><br><span class="line"></span><br><span class="line">// 返回一个数组</span><br><span class="line">function example() &#123;</span><br><span class="line">    return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">let [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">//返回一个对象</span><br><span class="line">function example() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        foo: 1,</span><br><span class="line">        bar: 2</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*函数参数的定义*/</span><br><span class="line"></span><br><span class="line">// 参数是一组无次序的值时</span><br><span class="line">function f(&#123; x, y, z &#125;) &#123; ... &#125;</span><br><span class="line">f(&#123; z: 3, y: 5, x: 0 &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*提取JSON数据*/</span><br><span class="line">let jsonData = &#123;</span><br><span class="line">    id: 42,</span><br><span class="line">    data: [860, 504]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, data: number &#125; = jsonData;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function(url, &#123;</span><br><span class="line">    async = true,</span><br><span class="line">    beforeSend = function() &#123;&#125;,</span><br><span class="line">    cache = true,</span><br><span class="line">    complete = function() &#123;&#125;,</span><br><span class="line">    crossDomain = false,</span><br><span class="line">    global = true,</span><br><span class="line">    // ... more config</span><br><span class="line">&#125;) &#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* 输入模块的指定方法 */</span><br><span class="line"></span><br><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命令&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;let命令&lt;/h1&gt;&lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://jeremygo.cn/tags/javascript/"/>
    
  </entry>
  
</feed>

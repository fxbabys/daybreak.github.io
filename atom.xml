<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeremy&#39;s blog</title>
  
  <subtitle>Share the technology and life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jeremygo.cn/"/>
  <updated>2018-12-18T16:47:11.914Z</updated>
  <id>https://jeremygo.cn/</id>
  
  <author>
    <name>Day Break</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每周精进(12.19)</title>
    <link href="https://jeremygo.cn/2018/12/19/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-12-19/"/>
    <id>https://jeremygo.cn/2018/12/19/每周精进-12-19/</id>
    <published>2018-12-18T16:15:57.000Z</published>
    <updated>2018-12-18T16:47:11.914Z</updated>
    
    <content type="html"><![CDATA[<p>上一次的周计划已经算是三周前了, 这三周也密密麻麻经历过很多事情, 日志易面试, 理电项目功能修补, java 课设答辩, jsp课设, 六级… 也包括一些不太愉快的人际交往. 面试的结果确实比较出乎我的意料, 我对自己应该有更加自信的定位, HR那边也很积极地在跟我沟通, 在目前期末包括未来方向等等的压力下我确实多了一些纠结性的思考, 但冷静下来以后还是坚定自己最初的想法, 坚持对技术的追求, 必须去大厂见识一下前沿的技术实践, 真正会承受的压力未来还有很多.</p><p>因此决定坚持周计划下去, 毕竟坚持本不易, 在繁忙的生活中适当停下来进行总结思考是非常有必要的, 有更规律性计划性的输出对自己的成长也绝对是更有帮助的, 同时也调整好心态继续进行实习的简历投递.</p><p>话不多说,  12.24 日前计划:</p><ul><li><p>完成好数据库与算法设计的上机考试</p></li><li><p>理电论文项目完成最后的缴费支付部分</p></li><li>Drive Online 分类以及基本操作实现方式敲定, 下周的重点</li><li>框架原理再深入</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一次的周计划已经算是三周前了, 这三周也密密麻麻经历过很多事情, 日志易面试, 理电项目功能修补, java 课设答辩, jsp课设, 六级… 也包括一些不太愉快的人际交往. 面试的结果确实比较出乎我的意料, 我对自己应该有更加自信的定位, HR那边也很积极地在跟我沟通,
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>React入门</title>
    <link href="https://jeremygo.cn/2018/12/07/React%E5%85%A5%E9%97%A8/"/>
    <id>https://jeremygo.cn/2018/12/07/React入门/</id>
    <published>2018-12-07T01:41:59.000Z</published>
    <updated>2018-12-08T05:56:30.718Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会从零开始介绍 React 的核心知识点，以下是参考大纲~</p><ul><li><a href="#react">React</a><ul><li><a href="#react-%E6%98%AF%E4%BB%80%E4%B9%88">React 是什么</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-react">为什么要使用 React</a></li></ul></li><li><a href="#%E9%A1%B9%E7%9B%AE%E9%A2%84%E8%A7%88">项目预览</a></li><li><a href="#jsx">JSX</a></li><li><a href="#styles">Styles</a></li><li><a href="#%E7%BB%84%E4%BB%B6">组件</a><ul><li><a href="#props">props</a></li></ul></li><li><a href="#%E7%B1%BB%E7%BB%84%E4%BB%B6">类组件</a><ul><li><a href="#state">State</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86">事件处理</a></li><li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A">更多</a><ul><li><a href="#%E8%84%9A%E6%89%8B%E6%9E%B6">脚手架</a></li><li><a href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B7%AF%E7%94%B1">状态管理与路由</a></li></ul></li></ul><p>话不多说，直接进入~</p><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="React-是什么"><a href="#React-是什么" class="headerlink" title="React 是什么"></a>React 是什么</h4><blockquote><p>官方定义: 一个用来构建用户界面的 JavaScript 库</p></blockquote><p>从定义中我们要有一个认知: React 本身所做的只是构建用户界面，而大型的 React 项目一般都会紧密结合它的生态圈(路由: React-Router 状态管理库: Redux等等)来实现，这篇文章主要专注的还是 React 的核心知识点</p><h4 id="为什么要使用-React"><a href="#为什么要使用-React" class="headerlink" title="为什么要使用 React"></a>为什么要使用 React</h4><ul><li>虚拟 DOM: 我们都知道 js 频繁操作 dom 的成本是非常昂贵的，而 React 首创的 virtual dom 实现了在 js 层面来操作 dom，极大地提高了应用的效率</li><li>可复用组件: React 的流行带动了组件化的思想，组件化的核心就是在于可复用性，相比于传统的 Web 开发模式也更容易维护，很好地提高了开发效率</li><li>由 Facebook 维护: React 背靠 Facebook 这座大山，其身后有许多优秀的开发者在维护迭代，同时社区也十分的活跃，开发遇到的大部分问题很快都可以得到解决</li><li>现实: 最后一点就是国内的现状，大厂的技术栈基本都是基于 React 的，所以向公司(qian)看齐的话 React 也是必不可少的技能 </li></ul><h3 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h3><p>先看一下最终的项目效果，可以思考一下利用原生 js 如何实现 ? </p><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/deepin-screen-recorder_Select%20area_20181208103016.gif" alt="preview"></p><p>初始的空模板: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>我们首先来看 React 是如何构建界面即渲染元素的: </p><ul><li>React 的语法为 JSX, 即混合了 JavaScript 和 HTML 的语法</li></ul><p>这里我们采用外链引入的方式加入 React 项目最基本的两个链接: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>   // react 核心</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  // react-dom 浏览器(dom)的渲染</span><br></pre></td></tr></table></figure><p>同时为了直接能够使用 JSX 的语法, 我们还需要<strong>引入 babel 的外链</strong>: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// script 标注 type</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">// coding....</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后敲上第一行 React 代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>));</span><br></pre></td></tr></table></figure><p>刷新浏览器:</p><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/DeepinScreenshot_select-area_20181207175719.png" alt="Hello React"></p><p><code>ReactDOM</code> 对象来自 <code>react-dom</code>, 这里我们调用了它的 <code>render</code> 方法, 第一个参数是要渲染的元素, 第二个是实际的 DOM 对象, 这样就成功的将 JSX 元素渲染到了页面上</p><p>我们可以看到 JSX 语法实际上跟 HTML 还是很像的, 那么 CSS 呢 ? </p><h3 id="Styles"><a href="#Styles" class="headerlink" title="Styles"></a>Styles</h3><p>内联样式: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:</span> '<span class="attr">lightblue</span>'&#125;&#125;&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure><p>外部样式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> h1Style = &#123;</span><br><span class="line">    backgroundColor: <span class="string">'lightblue'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;h1Style&#125;</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure><p>PS: 如果是使用了 css 类选择器, 那么 JSX 中的写法是 <strong>className</strong> (为了与 ES6 的 <code>class</code> 区分) </p><p>目前学会这几种写法就足够了</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>我们刚刚在 <code>render</code> 方法中直接写的 JSX , 当你的 JSX 元素变得复杂起来就需要单独定义一个 <code>Component</code>,  我们先来看看 <strong>无状态组件</strong> 的写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello React!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;p&gt;react is so awesome!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure><p>刷新浏览器: </p><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/DeepinScreenshot_select-area_20181207183529.png" alt="awesome"></p><p>这里需要注意的是<strong>返回的组件必须只由一个最大的标签来包含</strong></p><p>接下来让我们敲一些有意思的: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> books = [<span class="string">'dataBase'</span>, <span class="string">'data structure'</span>, <span class="string">'computer network'</span>]</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;My books: <span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;books.map(<span class="function"><span class="params">book</span> =&gt;</span> </span><br><span class="line">          &lt;li&gt;&#123;book&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        )&#125;  </span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;  </span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure><p>我们定义一个 <code>books</code> 数组, 然后在函数组件内部使用 ES6 的 <code>map</code> 方法循环渲染出对应的 <code>book</code> 元素</p><p>刷新浏览器:</p><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/DeepinScreenshot_select-area_20181207190721.png" alt="books"></p><p>首先我们可以看到界面上出现了三个 <code>li</code> , 但是更显眼的是控制台出现了显眼的报错, 这个报错提示很重要, 意即<strong>每一个循环出的元素都需要有一个 <code>key</code></strong> , 这样的话 React 就能在列表变化时识别其中成员的添加 、更改和删除的操作(diff 算法), 会有更好的性能, 因此这里我们使用 <code>map</code> 的第二个参数来加上对应的 <code>key</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> books = [<span class="string">'dataBase'</span>, <span class="string">'data structure'</span>, <span class="string">'computer network'</span>]</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;My books: <span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;books.map(<span class="function">(<span class="params">book, i</span>) =&gt;</span> </span><br><span class="line">          &lt;li key=&#123;i&#125;&gt;&#123;book&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        )&#125;  </span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;  </span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p> 刷新控制台不再报错</p><p>这里我们也可以发现, <code>App</code> 组件内部的循环列表更适合抽出来单独做一个列表组件以实现更好的复用性: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BookList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;books.map(<span class="function">(<span class="params">book, i</span>) =&gt;</span> </span><br><span class="line">        &lt;li key=&#123;i&#125;&gt;&#123;book&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;  </span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;  </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> books = [<span class="string">'dataBase'</span>, <span class="string">'data structure'</span>, <span class="string">'computer network'</span>]</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;My books: <span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">      &lt;BookList /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>但是很明显我们又发现了另一个问题,  <code>books</code> 数组是定义在 <code>App</code> 组件内部的, <strong><code>bookList</code> 组件如何获取到它的值?</strong></p><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>上面的问题即是父子组件如何传递值? 很直接的想法, 我们可以在父组件内部放置子组件时传入一些自定义的参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> books = [<span class="string">'dataBase'</span>, <span class="string">'data structure'</span>, <span class="string">'computer network'</span>]</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;My books: <span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">      &lt;BookList list=&#123;books&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>然后我们在 <code>BookList</code> 子组件内捕捉到传下来的参数: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BookList</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'props: '</span>, props)</span><br><span class="line">  <span class="keyword">const</span> books = props.list</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;books.map(<span class="function">(<span class="params">book, i</span>) =&gt;</span> </span><br><span class="line">        &lt;li key=&#123;i&#125;&gt;&#123;book&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;  </span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;  </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷新浏览器:</p><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/DeepinScreenshot_select-area_20181207194244.png" alt="props"></p><p>OK! 这就是 <code>props</code>, 我们同时在控制台打印了这个对象, 从这就可以看出数据在不同组件间传递的方式.</p><p>现在来思考一个新问题: 目前的数据只是默默地在传递, 不同组件只是单纯地把它显示出来, 如果我们需要添加或者删除这些数据该如何操作, <strong>React 又如何获知这些数据被更改了并及时更新 UI 呢?</strong></p><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>让我们来认识 React 自身给我们提供的另一种组件—类组件</p><p>类组件的来源于 ES6 中 的<code>class</code>, 这里我们看一下将 <code>App</code> 组件改写成类组件的写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      books: [<span class="string">'dataBase'</span>, <span class="string">'data structure'</span>, <span class="string">'computer network'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;My books: <span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">        &lt;BookList list=&#123;<span class="keyword">this</span>.state.books&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>React.Component</code> 是 React 自带的通用类, 它封装了所有 React 类需要的实现细节, 类组件都是通过继承它来实现, 通过重写 <code>render</code> 方法来定义返回的组件元素</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>我们可以看到原来的 <code>books</code> 数组放到了 <code>constructor</code> 构造函数中作为该类组件的内部状态来使用: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">books: [<span class="string">'dataBase'</span>, <span class="string">'data structure'</span>, <span class="string">'computer network'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>state</code> 通过使用 <code>this</code> 绑定在类上, 我们可以在整个组件内访问到 <code>state</code>, 每次修改组件的 <code>state</code>, 组件的 <code>render</code> 方法会再次运行即组件重新渲染, 那我们可以直接修改 <code>state</code> 吗 ?</p><p>React 有两个重要的原则: 一个是单向数据流, 另一个是明确的状态改变.  我们<strong>唯一改变 <code>state</code> 的方式是通过 <code>setState()</code></strong></p><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/DeepinScreenshot_select-area_20181207202840.png" alt="setState"></p><p>组件在 <code>render</code> 中获取最新 <code>state</code> 的信息进行渲染, 在 <code>View</code> 层通过调用 <code>setState</code> 来更新 <code>state</code>, 然后组件再次运行 <code>render</code> 方法并更新界面.</p><p>我们来尝试一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      books: [<span class="string">'database'</span>, <span class="string">'data structure'</span>, <span class="string">'computer network'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;My books: <span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">        &lt;BookList list=&#123;<span class="keyword">this</span>.state.books&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">books</span>: [<span class="string">'Compilation principle'</span>, <span class="string">'operating system'</span>] &#125;)&#125;&gt;Change&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/deepin-screen-recorder_Select%20area_20181207204543.gif" alt="change"></p><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>当 <code>setState</code> 关联的逻辑复杂起来以后, 包括我们需要在不同组件间调用 <code>setState</code> 时, 从复用性与维护性角度上来说, 我们都需要将事件处理抽离成自定义的函数来调用, React 中推荐事件处理函数的前缀都为 <code>handle</code> , 监听函数的前缀都为 <code>on</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      books: [<span class="string">'database'</span>, <span class="string">'data structure'</span>, <span class="string">'computer network'</span>],</span><br><span class="line">      input: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleAddBook = <span class="keyword">this</span>.handleAddBook.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.handleRemoveBook = <span class="keyword">this</span>.handleRemoveBook.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.updateInput = <span class="keyword">this</span>.updateInput.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleAddBook () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">currentState</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        books: currentState.books.concat([<span class="keyword">this</span>.state.input])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleRemoveBook (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">currentState</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        books: currentState.books.filter(<span class="function"><span class="params">book</span> =&gt;</span> book !== name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateInput (e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      input: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;My books: <span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">        &lt;input </span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          placeholder=<span class="string">"new book"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.input&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.updateInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleAddBook&#125;&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;BookList </span></span><br><span class="line"><span class="regexp">          list=&#123;this.state.books&#125;</span></span><br><span class="line"><span class="regexp">          onRemoveBook=&#123;this.handleRemoveBook&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>handleAddBook</code> 和 <code>handleRemoveBook</code> 为新增和修改的操作, 这里还需要特别强调的是构造函数中的这三行代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.handleAddBook = <span class="keyword">this</span>.handleAddBook.bind(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">this</span>.handleRemoveBook = <span class="keyword">this</span>.handleRemoveBook.bind(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">this</span>.updateInput = <span class="keyword">this</span>.updateInput.bind(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>当我们想在自定义的类方法中调用 <code>this.setState</code> 时, 这里的 <code>this</code> 是 <code>undefined</code>, 所以为了类组件的 <code>this</code> 在类方法中可以访问, 我们需要将 <code>this</code> 绑定到类方法上, 而放在构造函数里面的话绑定只会在组件实例化时运行一次, 性能消耗更少.</p><p>OK! 事实上到这里我们已经可以基本完成项目预览所呈现的内容了, 现在请你试着做更多的改进以达到下面的效果:</p><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/deepin-screen-recorder_Select%20area_20181208074535.gif" alt="preview"></p><p>如果你已经完成, 可以参考以下的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActiveBooks</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Reading Books&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.list.map((book, i) =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;i&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span&gt;&#123;book.name&#125;&lt;/</span>span&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; props.onRemoveBook(book.name)&#125;&gt;Remove&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; props.onDeactive(book.name)&#125;&gt;Readed&lt;/</span>button&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function InactiveBooks (props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;Readed Books&lt;/</span>h2&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;props.list.map(<span class="function">(<span class="params">book, i</span>) =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;i&#125;&gt;</span><br><span class="line">            &lt;span&gt;&#123;book.name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; props.onActive(book.name)&#125;&gt;Reading&lt;/</span>button&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor (props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props)</span></span><br><span class="line"><span class="regexp">    this.state = &#123;</span></span><br><span class="line"><span class="regexp">      books: [</span></span><br><span class="line"><span class="regexp">        &#123;</span></span><br><span class="line"><span class="regexp">          name: 'database',</span></span><br><span class="line"><span class="regexp">          active: true</span></span><br><span class="line"><span class="regexp">        &#125;, </span></span><br><span class="line"><span class="regexp">        &#123;</span></span><br><span class="line"><span class="regexp">          name: 'data structure',</span></span><br><span class="line"><span class="regexp">          active: true</span></span><br><span class="line"><span class="regexp">        &#125;, </span></span><br><span class="line"><span class="regexp">        &#123;</span></span><br><span class="line"><span class="regexp">          name: 'computer network',</span></span><br><span class="line"><span class="regexp">          active: true</span></span><br><span class="line"><span class="regexp">        &#125;],</span></span><br><span class="line"><span class="regexp">      input: ''</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    this.handleAddBook = this.handleAddBook.bind(this)</span></span><br><span class="line"><span class="regexp">    this.handleRemoveBook = this.handleRemoveBook.bind(this)</span></span><br><span class="line"><span class="regexp">    this.handleToggleBook = this.handleToggleBook.bind(this)</span></span><br><span class="line"><span class="regexp">    this.updateInput = this.updateInput.bind(this)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleAddBook () &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(currentState =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      return &#123;</span></span><br><span class="line"><span class="regexp">        books: currentState.books.concat([&#123;</span></span><br><span class="line"><span class="regexp">          name: this.state.input,</span></span><br><span class="line"><span class="regexp">          active: true</span></span><br><span class="line"><span class="regexp">        &#125;]),</span></span><br><span class="line"><span class="regexp">        input: ''</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleRemoveBook (name) &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(currentState =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      return &#123;</span></span><br><span class="line"><span class="regexp">        books: currentState.books.filter(book =&gt; book.name !== name)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleToggleBook (name) &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(currentState =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      const book = currentState.books.find(book =&gt; book.name === name)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      return &#123;</span></span><br><span class="line"><span class="regexp">        books: currentState.books.filter(book =&gt; book.name !== name)</span></span><br><span class="line"><span class="regexp">        .concat([&#123;</span></span><br><span class="line"><span class="regexp">          name,</span></span><br><span class="line"><span class="regexp">          active: !book.active</span></span><br><span class="line"><span class="regexp">        &#125;])</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  updateInput (e) &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;</span></span><br><span class="line"><span class="regexp">      input: e.target.value</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h3&gt;My books: &lt;/</span>h3&gt;</span><br><span class="line">        &lt;input </span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          placeholder=<span class="string">"new book"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.input&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.updateInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleAddBook&#125;&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; books: [] &#125;)&#125;&gt; Clear All &lt;/</span>button&gt;</span><br><span class="line">        &lt;ActiveBooks </span><br><span class="line">          list=&#123;<span class="keyword">this</span>.state.books.filter(<span class="function"><span class="params">book</span> =&gt;</span> book.active)&#125;</span><br><span class="line">          onRemoveBook=&#123;<span class="keyword">this</span>.handleRemoveBook&#125;</span><br><span class="line">          onDeactive=&#123;<span class="keyword">this</span>.handleToggleBook&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;InactiveBooks </span><br><span class="line">          list=&#123;<span class="keyword">this</span>.state.books.filter(<span class="function"><span class="params">book</span> =&gt;</span> !book.active)&#125;</span><br><span class="line">          onActive=&#123;<span class="keyword">this</span>.handleToggleBook&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>走到这里, 你已经可以自己再写几个小 demo 熟悉一下了, 那么让我们再来思考最后一个问题: </p><ul><li>项目中很多时候的数据都是要与后台交互的, 也就是会有<strong>异步的操作</strong>, 在数据还未请求到时我们希望显示加载样式, 请求到以后再更新界面, <strong>这样的逻辑应该放在哪里</strong>?</li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>对于上面的问题, 我们实际希望的是当组件被挂载到 DOM 上以后再来渲染界面, 同时对于有很多组件的应用, 当组件销毁时, 我们也需要释放它所占用的资源, 这就是 React <strong>生命周期</strong> 当中很重要的两个函数: <code>componentDidMount</code>和 <code>componentWillUnmout</code></p><p>让我们整体感觉一下生命周期函数执行的过程: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--constructor--'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--componentDidMount--'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--componentDidUpdate--'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmout () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--componentWillUnmout--'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--render--'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      ......</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/deepin-screen-recorder_Select%20area_20181208090707.gif" alt="life-cycle"></p><p>我们可以看出, 组件整个的生命周期是从 <code>constructor</code> –&gt; <code>render</code> –&gt; <code>componentDidMount</code>, 然后组件更新再次 <code>render</code> –&gt; <code>componentDidUpdate</code> , 组件销毁前则会调用 <code>componentWillUnmout</code></p><p>接下来我们将会深入使用这几个函数:</p><p>让我们先手动模拟一个 API:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.API = &#123;</span><br><span class="line">  fetchBooks () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> books =  [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">'database'</span>,</span><br><span class="line">          active: <span class="literal">true</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">'data structure'</span>,</span><br><span class="line">          active: <span class="literal">true</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">'computer network'</span>,</span><br><span class="line">          active: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> res(books), <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>componentDidMount</code> 函数中调用它:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'--componentDidMount--'</span>)</span><br><span class="line">  </span><br><span class="line">  API.fetchBooks()</span><br><span class="line">    .then(<span class="function"><span class="params">books</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        books</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/deepin-screen-recorder_Select%20area_20181208093956.gif" alt="API"></p><p>我们可以看到在 <code>componentDidMount</code> 之后再去请求数据, 然后 <code>render</code> 重新渲染再执行了 <code>componentDidUpdate</code></p><p>让我们再来提升一下用户体验加上 Loading 的逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      books: [],</span><br><span class="line">      loading: <span class="literal">true</span>,</span><br><span class="line">      input: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--constructor--'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--componentDidMount--'</span>)</span><br><span class="line">    </span><br><span class="line">    API.fetchBooks()</span><br><span class="line">      .then(<span class="function"><span class="params">books</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          books,</span><br><span class="line">          loading: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--componentDidUpdate--'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmout () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--componentWillUnmout--'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--render--'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.loading === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      ......</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://jeremy-bucket.oss-cn-shenzhen.aliyuncs.com/%E5%9B%BE%E5%BA%8A/deepin-screen-recorder_Select%20area_20181208094435.gif" alt="Loading"></p><p>OK! 现在我们整个的 React 入门历程已经结束了, 当然并没有完全实现预览的效果, 鼓励你进一步独立封装一个 <code>Loading</code> 组件, 最后让我们简单谈一下更进一步的开发操作</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><h4 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h4><p>我们的入门教程是用传统的外链引入方式来使用 React 的, 并且为了使用 JSX  我们还需要再引入 babel , 现代化的 Web 开发流程都是基于 <a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a> 的模块化构建与部署过程, 对于实际成型的项目来说, 一般都推荐使用官方的脚手架 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> 来一步构建, 简化依赖安装与环境部署的流程, 更多地专注在代码逻辑的编写上</p><h4 id="状态管理与路由"><a href="#状态管理与路由" class="headerlink" title="状态管理与路由"></a>状态管理与路由</h4><p>还记得 React 的定义吗? 它只是专注在用户界面的构建上面, 虽然我们通过类组件可以管理一定的内部状态, 但是当项目复杂到一定程度以后, 避免不了是要引入外部的状态管理库, 这里推荐使用跟 React 理念相合的 <a href="https://redux.js.org/" target="_blank" rel="noopener">Redux</a> ; 目前的单页面应用都需要用到路由管理, 推荐使用 <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">React-Router</a> </p><p>最后我想说, 前端的技术表面是发展得很快的, 但是内部的原理基本都是万变不离其宗, React 带来的是一种新的变革的开发方式, 希望你以此为起点, 结合 React 的设计理念去深入它更多的特性.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将会从零开始介绍 React 的核心知识点，以下是参考大纲~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#react&quot;&gt;React&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#react-%E6%98%AF%E4%BB%80%E4%B9%88&quot;&gt;React 是什么&lt;/
      
    
    </summary>
    
    
      <category term="React" scheme="https://jeremygo.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>从原型到class</title>
    <link href="https://jeremygo.cn/2018/11/30/%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0class/"/>
    <id>https://jeremygo.cn/2018/11/30/从原型到class/</id>
    <published>2018-11-30T12:18:54.000Z</published>
    <updated>2018-11-30T14:21:40.226Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会从原型介绍到原型实现继承与 ES6 的 <code>class</code> 实现继承并进行对比~</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>JavaScript 并不是一门纯面向对象的语言，而是一门基于原型的动态类型语言．</p><ul><li>每一个 js 对象都有一个特殊的内置 [[Prototype]] 属性，这个属性我们不能直接访问到，需要借助另一个 <code>__proto__</code> 属性，这个属性即指向了原型，而原型也是一个对象，这个对象当中定义了很多函数可以让我们使用(类似超类)</li><li>在原型对象中还有一个 <code>constructor</code> 属性，也就是构造函数，而这个构造函数又通过 <code>prototype</code> 属性指回原型（除了 <code>Function.prototype.bind()</code>，因为这个对象是由引擎创建出来的）</li><li>多个对象通过 <code>__proto__</code> 属性连接起来就形成了原型链</li></ul><p>这里把经典的图放上来对照着理解：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671d387e4189ec8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="原型与原型链"></p><p>总结：</p><ul><li><code>Object</code> 是所有对象的祖先，即所有对象都可以通过 <code>__proto__</code> 找到它</li><li><code>Function</code> 是所有函数的祖先，即所有函数都可以通过 <code>__proto__</code> 找到它</li><li>对象都是通过 <code>Function</code>  (构造器)创建的，即有 <code>Object.__proto__ === Function.prototype</code></li><li>函数也是由 <code>Function</code> 创建的，自然也有 <code>Fucntion.__proto__ === Function.prototype</code></li><li>除了 <code>Function.prototype</code> 和 <code>Object.prototype</code> 由引擎创建，其余都是通过 <code>Function</code> new 出来的</li><li><code>__proto__</code> 将对象和原型连接起来形成了原型链，原型链最终为 <code>null</code></li></ul><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>调用 <code>new</code> 的过程中会发生四件事情：</p><ul><li>新生成一个中间对象</li><li>将这个中间对象链接到原型</li><li>绑定这个对象的 this 到构造函数上</li><li>返回该中间对象</li></ul><p>实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    obj.__proto__ = Con.prototype</span><br><span class="line">    <span class="keyword">let</span> res = Con.call(obj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> ? res : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出两点：</p><ul><li><p>通过 <code>new</code> 生成的对象 this 是永久绑定到对应构造函数的</p></li><li><p>创建对象最好使用字面量的方式，使用 <code>new Obejct()</code> 需要通过作用域链一层层向上找到 <code>Object</code> 并且可读性也不好 (内部都是通过 <code>new Object()</code> 方式，但是如果我们自己采用 <code>new Object()</code> ，引擎就会认为可能存在同名的构造函数而选择通过作用域链一层一层找至全局)</p></li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 可以正确的判断对象的类型，内部机制是通过判断该对象的原型链中是否能找到类型的 <code>prototype</code></p><p>实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span> (<span class="params">obj, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = type.prototype</span><br><span class="line">    obj = obj.__proto__</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (prototype === obj) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        obj = obj.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS： <code>instanceof</code> 可不可以直接被用来判断基本类型？（自定义 <code>instanceof</code> 行为）</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><h5 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5><p>在子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后再改变子类的原型为继承父类的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br></pre></td></tr></table></figure><p>这种继承的优点在于构造函数可以传参，不会与父类的引用属性共享，因此可以复用父类的函数，但是也有一个缺点就是继承父类函数时通过 <code>new</code> 调用了父类构造函数，导致子类的原型上多出了不需要的父类属性</p><h5 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h5><p>组合继承的优化版，即继承父类函数时不通过调用构造函数的方式，而是将父类的原型赋值给子类并将构造函数设置成子类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Child,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="class-继承"><a href="#class-继承" class="headerlink" title="class 继承"></a>class 继承</h4><p><code>class</code> 实际上只是语法糖，本质上还是函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span></span><br></pre></td></tr></table></figure><p>通过 <code>class</code> 实现的继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = value</span><br><span class="line">    &#125;</span><br><span class="line">    getValue () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">        <span class="keyword">super</span>(value)  <span class="comment">// 等同于 Parent.call(this.value)</span></span><br><span class="line">        <span class="keyword">this</span>.val = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：</p><ol><li><a href="https://yuchengkai.cn/docs/zh/frontend/#%E5%8E%9F%E5%9E%8B" target="_blank" rel="noopener">https://yuchengkai.cn/docs/zh/frontend/#%E5%8E%9F%E5%9E%8B</a></li><li><a href="https://github.com/amandakelake/blog/issues/39" target="_blank" rel="noopener">https://github.com/amandakelake/blog/issues/39</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将会从原型介绍到原型实现继承与 ES6 的 &lt;code&gt;class&lt;/code&gt; 实现继承并进行对比~&lt;/p&gt;
&lt;h3 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h3&gt;&lt;p&gt;JavaScrip
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://jeremygo.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(11.26)</title>
    <link href="https://jeremygo.cn/2018/11/26/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-26/"/>
    <id>https://jeremygo.cn/2018/11/26/每周精进-11-26/</id>
    <published>2018-11-26T04:34:55.000Z</published>
    <updated>2018-11-26T04:50:13.274Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jeremygo.cn/2018/11/19/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-18/">11.18</a> 第八周计划总结～</p><ul><li style="list-style: none"><input type="checkbox" checked> 完善 jsp 大作业的整体模板</li><li style="list-style: none"><input type="checkbox"> 完成 Speedest 功能的基本扩展(doing)</li><li style="list-style: none"><input type="checkbox"> Algorithm-JS 的完善(doing)</li></ul><p>本周推进最多的应该是 jsp 的大作业了，到现在的阶段基本的构造以及计划都已经成型，我是不打算写 jsp 的，最终思路还是进行前后端分离的实践，做一个类似 Google Drive 的文件存储云平台，后端采用 java ，数据库的选择上一方面项目有很重要的一个逻辑就是文件的分类，即一个分类对应多个文件，另一方面也想尝试一下新东西，所以选择了 MongoDB，目前后端的接口基础已经打好了，接下来这一周会结合数据库的设计逐渐完善，另一个 java 的课设实现多线程下载与断点续传比较难啃，接下里的重心会放在这两个上面</p><p>12.2日前计划:</p><ul><li>继续完善 Drive Online （后端接口设计）</li><li>Speedest-downloader 实现</li><li>Algorithm-JS 的完善</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jeremygo.cn/2018/11/19/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-18/&quot;&gt;11.18&lt;/a&gt; 第八周计划总结～&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: n
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(11.18)</title>
    <link href="https://jeremygo.cn/2018/11/19/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-18/"/>
    <id>https://jeremygo.cn/2018/11/19/每周精进-11-18/</id>
    <published>2018-11-19T15:23:53.000Z</published>
    <updated>2018-11-19T15:41:38.213Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jeremygo.cn/2018/11/10/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-10/">11.10</a>第七周计划总结~</p><ul><li style="list-style: none"><input type="checkbox" checked> 实践 jeem 结合 react-router 的使用规范 <a href="https://github.com/fxbabys/jeem/tree/master/examples/jeem-antd" target="_blank" rel="noopener">戳我</a></li><li style="list-style: none"><input type="checkbox" checked> 专栏进度跟进</li><li style="list-style: none"><input type="checkbox" checked> 熟悉网络与算法相关的基础面试题</li></ul><p>这周重新改造了 jeem-demo 的目录结构，结合 react-router 的语法设计了一个demo增强版的模板，可以直接基于这个模板进行成型项目的开发部署，同时结合专栏完善了基本数据结构的项目并开放出来，之后会依据已有目录更新完善更多的 JS 版本的代码～，接下来的重心觉得应该放一部分精力回各类大作业上了(~~)</p><p>11.25日前计划: </p><ul><li>完善 jsp 大作业的整体模板 (jeem subscription的扩展)</li><li>完成 Speedest 功能的基本扩展</li><li>Algorithm-JS 的完善</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jeremygo.cn/2018/11/10/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-10/&quot;&gt;11.10&lt;/a&gt;第七周计划总结~&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: no
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(11.10)</title>
    <link href="https://jeremygo.cn/2018/11/10/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-10/"/>
    <id>https://jeremygo.cn/2018/11/10/每周精进-11-10/</id>
    <published>2018-11-10T00:09:55.000Z</published>
    <updated>2018-11-10T00:27:08.877Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jeremygo.cn/2018/10/30/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-30/">10.30</a> 第六周计划总结~</p><ul><li style="list-style: none"><input type="checkbox"> react深入学习(Test方面)(continuing)</li><li style="list-style: none"><input type="checkbox"> 专栏的跟进(continuing)</li><li style="list-style: none"><input type="checkbox" checked> 读完&lt;&lt;跃迁&gt;&gt;</li></ul><p>关于 Test 这方面目前能深入的并不多，大部分时间还是在完成业务逻辑，两篇专栏的进度会更加重视跟进，最大的收获就是读完跃迁了，对硅谷的相关体系有了更深的了解，同时也对我之后想走的方向有一定的指导性</p><p>这个月开始来年春招的消息越来越多了，也有争取寒假实习的打算，接下来的重点结束好手上的项目以后会放在面试上，每周精进这部分之后会固定在周末的时间进行回顾，下一周的目标会更细致地考虑而定，保证立下的 flag 能好好实现</p><p>11.17日前计划：</p><ul><li>实践 jeem 结合 react-router 的使用规范</li><li>专栏进度持续跟进</li><li>熟悉网络与算法相关的基础与面试题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jeremygo.cn/2018/10/30/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-30/&quot;&gt;10.30&lt;/a&gt; 第六周计划总结~&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: n
      
    
    </summary>
    
    
      <category term="每周精进" scheme="https://jeremygo.cn/tags/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(10.30)</title>
    <link href="https://jeremygo.cn/2018/10/30/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-30/"/>
    <id>https://jeremygo.cn/2018/10/30/每周精进-10-30/</id>
    <published>2018-10-30T02:19:12.000Z</published>
    <updated>2018-10-30T02:43:02.584Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jeremygo.cn/2018/10/22/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-22/">10.22</a> 第五周计划总结~</p><ul><li style="list-style: none"><input type="checkbox"> 理电项目测试上线(nearly end)</li><li style="list-style: none"><input type="checkbox"> react体系深入(接下来的重点)</li><li style="list-style: none"><input type="checkbox"> 专栏训练营进度跟进(同上)</li><li style="list-style: none"><input type="checkbox" checked> 本月完成webpack配置细节博客</li></ul><p>这周得到最大的bonus应该就是 autosub 的完美使用了，算是为之后的学习道路解决了一个比较大的障碍，同时1024拼单买到了很喜欢的两本书，也会是接下来几周的阅读重点，不考虑内容对于现在的实际收获，仅仅很久没有感受到的读纸质书时内心的平静与满足就足够了，也算是作为我未来发展方向的启蒙读物吧～</p><p>11.4日前完成：</p><ul><li>react 深入学习(Test 方面)</li><li>专栏(数据结构与算法之美 网络协议)专栏的跟进</li><li>读完&lt;&lt;跃迁&gt;&gt;</li></ul><p>More：结合 jeem 考虑好 web应用技术大作业的实现  基于 Taro 编写小程序应用架构</p><p>近期书单：跃迁 从零开始学架构</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jeremygo.cn/2018/10/22/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-22/&quot;&gt;10.22&lt;/a&gt; 第五周计划总结~&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: n
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置介绍</title>
    <link href="https://jeremygo.cn/2018/10/28/webpack%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/"/>
    <id>https://jeremygo.cn/2018/10/28/webpack配置介绍/</id>
    <published>2018-10-28T06:53:22.000Z</published>
    <updated>2018-11-10T00:02:04.452Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍 jeem webpack(4.0)相关的配置，不会针对webpack作过多的详解，算是webpack最佳配置的一个总结，会不断更新~</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，它处理应用程序时会递归地构建一个依赖关系图，其中包含应用程序所需的各个模块，然后将所有这些模块打包成一个或多个bundle</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>结合四个核心概念介绍目前所需的依赖：</p><ul><li>entry: 入口起点指示 webpack 应该使用哪个模块开始，默认:  <code>./src</code></li><li>output: 出口属性告诉 webpack 在哪里输出它所创建的bundles及如何命名这些文件，默认: <code>./dist</code></li><li>loader: 让 webpack 能够处理非 JavaScript 文件(将所有类型的文件转换为 webpack 能够处理的有效模块)<ul><li>babel-loader:  ES6语法转化<ul><li>这里一并介绍下跟 babel 相关的技术生态: <ul><li>babel-preset-env: babel配置文件中使用, 包含 ES6+ 等版本的语法转化规则</li><li>babel-polyfill: ES6 内置方法和函数转化</li><li>babel-plugin-transform-runtime: 避免 polyfill 污染全局变量</li></ul></li><li>babel-loader 负责的是语法转化，babel-polyfill 负责内置的方法和函数</li></ul></li><li>style-loader: 从 js 字符串中生成 style 节点</li><li>css-loader: 将 css 转化成 commonJS 模块</li><li>less-loader: 将 less 编译成 css</li><li>url-loader: 图片处理</li></ul></li><li>plugins: 用于执行范围更广(从打包优化压缩到重新定义环境中的变量)的任务<ul><li>html-webpack-plugin: 自动生成 html 文件并自动插入静态资源 js脚本</li><li>mini-css-extract-plugin: css提取压缩</li><li>clean-webpack-plugin: 重新打包时先清除 dist 目录下的文件</li></ul></li></ul><p><strong>mode设置：</strong>webpack4 开始通过设置 mode 为 development 或 production 就可以启用相应模式下 webpack 内置的优化</p><h3 id="实战配置"><a href="#实战配置" class="headerlink" title="实战配置"></a>实战配置</h3><h4 id="公用配置"><a href="#公用配置" class="headerlink" title="公用配置"></a>公用配置</h4><p>基于 jeem 推荐的语法，公用配置重点在针对 es6+ 和 less 的处理：</p><ul><li><p>es6+：babel7 转译 es6+ 的依赖是 @babel/polyfill</p><ul><li><p>为什么不用不会污染全局变量的 babel-plugin-transform-runtime？</p><p>jeem 定位是一个框架，针对于提供最良好的使用体验，因此对于api的使用需求会比较高，而babel-plugin-tranform-runtime 不能够转码实例方法(如 repeat includes等)，因此选择支持更多特性的babel-polyfill</p></li></ul></li><li><p>less: less-loader + css-loader + style-loader</p></li></ul><p>先看babel相关的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"babel"</span>: &#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">    <span class="string">"@babel/preset-react"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"import"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"antd"</span>,</span><br><span class="line">        <span class="string">"libraryDirectory"</span>: <span class="string">"es"</span>,</span><br><span class="line">        <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>接下来直接结合配置注释理解吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modeConfig = <span class="function"><span class="params">env</span> =&gt;</span> <span class="built_in">require</span>(<span class="string">`./build/webpack.<span class="subst">$&#123;env&#125;</span>`</span>)(env);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">&#123; mode &#125; = &#123; mode: <span class="string">'development'</span>, presets: [] &#125;</span>) =&gt;</span> webpackMerge(</span><br><span class="line">  &#123;</span><br><span class="line">    mode,</span><br><span class="line">    entry: [<span class="string">'@babel/polyfill'</span>, <span class="string">'./src/index.js'</span>],</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">      filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        <span class="string">'@'</span>: path.join(__dirname, <span class="string">'.'</span>, <span class="string">'src'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(js)$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          use: &#123;</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          use: [<span class="string">'babel-loader'</span>, <span class="string">'eslint-loader'</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(less)$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          use: [&#123;</span><br><span class="line">            loader: mode === <span class="string">'development'</span> ? <span class="string">'style-loader'</span> : MiniCssExtractPlugin.loader, <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>, <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">              modules: <span class="literal">true</span>,</span><br><span class="line">              localIdentName: <span class="string">'[name]__[local]__[hash:base64:5]'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: <span class="string">'less-loader'</span>, <span class="comment">// compiles Less to CSS</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(less)$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/src/</span>,</span><br><span class="line">          use: [&#123;</span><br><span class="line">            loader: mode === <span class="string">'development'</span> ? <span class="string">'style-loader'</span> : MiniCssExtractPlugin.loader, <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>, <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: <span class="string">'less-loader'</span>, <span class="comment">// compiles Less to CSS</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(jpe?g|png|gif)$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'url-loader'</span>,</span><br><span class="line">              options: &#123;</span><br><span class="line">                name: <span class="string">'[name]-[hash:5].min.[ext]'</span>,</span><br><span class="line">                limit: <span class="number">20000</span>,</span><br><span class="line">                publicPath: <span class="string">'static/'</span>,</span><br><span class="line">                outputPath: <span class="string">'static/'</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> webpack.ProgressPlugin(),</span><br><span class="line">      <span class="keyword">new</span> MiniCssExtractPlugin(),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  modeConfig(mode),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="开发配置"><a href="#开发配置" class="headerlink" title="开发配置"></a>开发配置</h4><p>开发配置主要需要的是热更新以及调试直接定位源码（结合webpack4 development模式内置优化）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/webpack.development.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  devtool: <span class="string">'source-map'</span>, <span class="comment">//方便调试</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>,    <span class="comment">// 结合下面的plugin开启热更新</span></span><br><span class="line">    overlay: <span class="literal">true</span> <span class="comment">// 报错网页遮罩提示</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="生产配置"><a href="#生产配置" class="headerlink" title="生产配置"></a>生产配置</h4><p>webpack4 production 模式已经内置了针对压缩打包方面的优化，这里目前解决的是多次重复打包dist目录下会出现冗余的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/webpack.production.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>], &#123;</span><br><span class="line">      root: path.resolve(__dirname, <span class="string">'../'</span>),　　<span class="comment">// webpack根目录的绝对路径</span></span><br><span class="line">      verbose: <span class="literal">true</span> <span class="comment">// 写入日志调试</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上就是 jeem 目前 webpack 相关的配置，后续 jeem 进一步开发需要支持的也会越多 (如 file image等处理)，届时会同步更新~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要介绍 jeem webpack(4.0)相关的配置，不会针对webpack作过多的详解，算是webpack最佳配置的一个总结，会不断更新~&lt;/p&gt;
&lt;h3 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://jeremygo.cn/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(10.22)</title>
    <link href="https://jeremygo.cn/2018/10/22/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-22/"/>
    <id>https://jeremygo.cn/2018/10/22/每周精进-10-22/</id>
    <published>2018-10-22T14:51:50.000Z</published>
    <updated>2018-10-22T15:32:29.836Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jeremygo.cn/2018/10/15/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-15/">10.15</a> 第四周计划总结~</p><ul><li style="list-style: none"><input type="checkbox"> 理电学院项目的基本结尾(continuing)</li><li style="list-style: none"><input type="checkbox"> 心理学院项目初步(老师那边说暂时不做了…)</li><li style="list-style: none"><input type="checkbox"> 细读&lt;你不知道的js&gt;(中卷) 回调 Promise 生成器 章节(continuing)</li><li style="list-style: none"><input type="checkbox" checked> &lt;数据结构与算法之美&gt;专栏与训练营进度的跟进</li><li style="list-style: none"><input type="checkbox"> 至少完成&lt;网络协议&gt;专栏两篇文章的阅读(Hmm)</li></ul><p>这周的good parts应该就是 jeem 关于webpack配置部分做好了基础, 分离了开发和生产环境的配置, 为之后做了一个铺垫, 同时自己对于webpack整体的理解使用也有了一定的体会, 有空可以撰写博客出来啦, 其它部分… 项目上结尾进行中, 读书上感觉略微有点难啃了但是我会坚持进行下去的, keep forward!</p><p>10.28日前完成:</p><ul><li>理电项目测试上线</li><li>react 体系深入(结合视频开始)</li><li>专栏与训练营进度跟进, &lt;网络协议&gt; 至少完成两篇!</li></ul><p>More: 争取本月内完成 webpack 配置细节的博客, and jeem is forwarding now~</p><p>近期书单:  你不知道的JavaScript</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jeremygo.cn/2018/10/15/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-15/&quot;&gt;10.15&lt;/a&gt; 第四周计划总结~&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: n
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(10.15)</title>
    <link href="https://jeremygo.cn/2018/10/15/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-15/"/>
    <id>https://jeremygo.cn/2018/10/15/每周精进-10-15/</id>
    <published>2018-10-15T14:22:40.000Z</published>
    <updated>2018-10-15T14:41:07.230Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jeremygo.cn/2018/10/07/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-7/">10.7</a> 第三周计划总结~</p><ul><li style="list-style: none"><input type="checkbox"> 实现 jeem model 数据订阅相关功能，尝试 npm 自动构建流程</li><li style="list-style: none"><input type="checkbox"> 撰写与 jeem 相关知识的一篇博客</li><li style="list-style: none"><input type="checkbox"> 多阅读&lt; 你不知道的js &gt;（下卷）关键内容</li><li style="list-style: none"><input type="checkbox" checked> 专栏与训练营进度的持续跟进</li></ul><p>这周计划的完成度实在不忍看（捂脸），没有什么借口好找，假期结束后在平时事务与前端学习之间应该更好地掌握其中的节奏，接下来一周重点会放在16项目的结尾与17新开发的项目上，这也是 jeem 第一次亮剑，也希望能结合这个新项目更好地完善 jeem ，读书方面具体读到下卷的异步与性能之后发现中卷相关的回调 Promise 生成器等底层的理解与起源还是应该细读一遍，所以也会重读中卷的相关细节</p><p>10.21日前完成:</p><ul><li>理电学院项目的基本结尾</li><li>心理学院项目的开发初期领步并暨此完善 jeem 已知的不足（开发与生产模式配置 前后端联调配置）</li><li>细读&lt; 你不知道的js &gt; (中卷) 回调 Promise 生成器章节，回归下卷的阅读</li><li>&lt; 数据结构与算法之美 &gt; 专栏进度与训练营的跟进</li><li>至少完成&lt;网络协议&gt;专栏两篇文章的阅读</li></ul><p>近期书单：你不知道的JavaScript</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jeremygo.cn/2018/10/07/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-7/&quot;&gt;10.7&lt;/a&gt; 第三周计划总结~&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: non
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(10.7)</title>
    <link href="https://jeremygo.cn/2018/10/07/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-7/"/>
    <id>https://jeremygo.cn/2018/10/07/每周精进-10-7/</id>
    <published>2018-10-07T12:30:24.000Z</published>
    <updated>2018-10-07T12:51:35.536Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jeremygo.cn/2018/09/29/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-9-30/">9.30</a> 第二周计划总结～</p><ul><li style="list-style: none"><input type="checkbox" checked> 基于dva &amp; umi &amp; deef 尝试开始造自己的Framework</li><li style="list-style: none"><input type="checkbox" checked> 将已经实现的轮子至少选一个作好博客说明 <a href="https://jeremygo.cn/2018/09/30/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAMVVM/">戳我</a></li><li style="list-style: none"><input type="checkbox" checked> 跟上＜数据结构与算法之美＞专栏的进度</li><li style="list-style: none"><input type="checkbox" checked> 至少完成＜你不知道的js＞(中卷)关键部分的阅读</li><li style="list-style: none"><input type="checkbox" checked> 完成本周六级训练营的基本任务</li><li style="list-style: none"><input type="checkbox"> 10月内完成＜趣谈网络协议＞专栏的阅读</li></ul><p><a href="https://github.com/fxbabys/jeem" target="_blank" rel="noopener">jeem</a> 成型主要理念参考是来自 <a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">dva</a> 和 <a href="https://github.com/rematch/rematch" target="_blank" rel="noopener">rematch</a>，在这个过程中对于 Redux 的理念与局限有了更深的理解，同时 jeem 的核心也是完全自己来实现的，收获很多，但是开始接触 npm 模块发布流程后也碰了不少壁，感觉十分的麻烦，也说明自己对前端模块化工程这方面的理解还不够，希望在持续完善 jeem 的过程中能补充好相关知识并且多思考前端架构选型的原则，有些坑还是越早踩越好(==)</p><p>10.14日前完成: </p><ul><li>实现 jeem model 数据订阅相关功能，尝试利用好 npm 自动构建流程</li><li>撰写与 jeem 相关知识 (redux 模块化…) 的一篇博客</li><li>尽量多阅读&lt; 你不知道的js &gt; (下卷) 关键部分内容</li><li>专栏与训练营的进度持续跟进 </li></ul><p>近期书单：你不知道的JavaScript</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jeremygo.cn/2018/09/29/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-9-30/&quot;&gt;9.30&lt;/a&gt; 第二周计划总结～&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: non
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>从零实现一个MVVM</title>
    <link href="https://jeremygo.cn/2018/09/30/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAMVVM/"/>
    <id>https://jeremygo.cn/2018/09/30/从零实现一个MVVM/</id>
    <published>2018-09-30T10:08:01.000Z</published>
    <updated>2018-10-01T01:19:12.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>MVVM 由以下三个内容组成:</p><ul><li>Model: 数据模型</li><li>View: 界面</li><li>ViewModal: 沟通 View 和 Model</li></ul><p>MVVM 的思想是数据驱动视图，相比于 jQuery 操作 DOM 的时代，数据逻辑与页面实现了解耦，数据改变&lt;=&gt;UI改变，数据与业务的处理都放在 ViewModel 中并且可以复用</p><p>MVVM 中最核心的就是数据双向绑定，如 Angluar 的脏数据检测，Vue 中的数据劫持</p><p>接下来就详细解析实现基于数据劫持的双向绑定，功能上参考 v-model 还会完善一下编译的过程</p><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>首先是 DOM 元素以及类的实例化使用: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>             </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">&#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> MVVM(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">'Hello Jeremy!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里实例化了一个 MVVM 类，我们来实现它的初始结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVVM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$el = options.el</span><br><span class="line">        <span class="keyword">this</span>.$data = options.data</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.$el) &#123;</span><br><span class="line">            <span class="keyword">new</span> Observer(<span class="keyword">this</span>.$el, <span class="keyword">this</span>) <span class="comment">// 数据劫持</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是 Observer 类:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observe(data) <span class="comment">// 劫持函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    observe (data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(data, key, datat[key])</span><br><span class="line">            <span class="keyword">this</span>.observe(data[key]) <span class="comment">// 递归劫持 -&gt;　针对嵌套对象</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    defineReactive (data, key, value) &#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()　<span class="comment">// Observer 与 Watcher 解耦</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(data, key, &#123;  <span class="comment">// 双向绑定关键</span></span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            get () &#123;</span><br><span class="line">                Dep.target &amp;&amp; dep.subscribe(Dep.target) <span class="comment">// 订阅 Watcher 对象</span></span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            &#125;,</span><br><span class="line">            set () &#123;</span><br><span class="line">                <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">                    value = newValue</span><br><span class="line">                    _this.observe(newValue) <span class="comment">// 赋值也劫持</span></span><br><span class="line">                    dep.notify()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dep 类:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    subscribe (watcher) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> watcher.update())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是 Watcher 类:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (vm, expr, cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm</span><br><span class="line">        <span class="keyword">this</span>.expr = expr</span><br><span class="line">        <span class="keyword">this</span>.cb = cb</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() <span class="comment">// 初始化时保存当前值</span></span><br><span class="line">    &#125;</span><br><span class="line">    getVal (vm, expr) &#123;  <span class="comment">// 兼容嵌套对象的取值</span></span><br><span class="line">        <span class="keyword">const</span> attrs = expr.split(<span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">return</span> attrs.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> prev[next]</span><br><span class="line">        &#125;, vm.$data)</span><br><span class="line">    &#125;</span><br><span class="line">    get () &#123;</span><br><span class="line">        Dep.target = <span class="keyword">this</span>  <span class="comment">// 将 target 指向自己</span></span><br><span class="line">        <span class="keyword">const</span> value = <span class="keyword">this</span>.getVal(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.expr)　<span class="comment">// 触发 getter 监听</span></span><br><span class="line">        Dep.target = <span class="literal">null</span>  <span class="comment">// 置空</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    update () &#123;</span><br><span class="line">        <span class="keyword">const</span> newValue = <span class="keyword">this</span>.getVal(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.expr)</span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (newValue !== oldValue) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb(newValue) <span class="comment">// 对应 watcher 的更新回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三个类就是关于数据劫持的核心代码，new MVVM 时将 data 传入 observe 类中进行劫持，通过 <code>Object.defineProperty</code> 属性设置 getter 与 setter，在 new Watcher 类时构造函数调用 get 方法，触发 getter 监听并将对应 watcher 实例保存在 dep 对象数组中，修改数据值时 触发 setter 调用 notify 方法，遍历所有 watcher 实例，值修改了的实例就更新</p><p>那么 new Watcher 在哪里会调用呢？．．．</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>数据劫持完之后便是对节点的编译:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVVM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.$el) &#123;</span><br><span class="line">            <span class="keyword">new</span> Observer(<span class="keyword">this</span>.$data) <span class="comment">// 数据劫持</span></span><br><span class="line">            <span class="keyword">new</span> Compile(<span class="keyword">this</span>.$el, <span class="keyword">this</span>) <span class="comment">// 节点编译</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后我们要来实现 Compile 类:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (el, vm) &#123;</span><br><span class="line">        <span class="keyword">this</span>.el = isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el)</span><br><span class="line">        <span class="keyword">this</span>.vm = vm</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.el) &#123;</span><br><span class="line">            <span class="keyword">const</span> fragment = <span class="keyword">this</span>.nodeToFragment(<span class="keyword">this</span>.el) <span class="comment">// 将真实DOM移入内存中</span></span><br><span class="line">            <span class="keyword">this</span>.compile(fragment)　　　　　　　　　　　　　　<span class="comment">// 编译 v-model 和 &#123;&#123;&#125;&#125; 节点</span></span><br><span class="line">            <span class="keyword">this</span>.el.appendChild(fragment)                <span class="comment">// 重新塞回页面中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isElementNode (el) &#123;</span><br><span class="line">        <span class="keyword">return</span> el.nodeType === <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    isDirective (attr) &#123;</span><br><span class="line">        <span class="keyword">return</span> attr.inculdes(<span class="string">'v-'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    nodeToFragment (el) &#123;</span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line">        <span class="keyword">let</span> firstChild</span><br><span class="line">        <span class="keyword">while</span> (firstChild = el.firstChild) &#123;</span><br><span class="line">            fragment.appendChild(firstChild)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment</span><br><span class="line">    &#125;</span><br><span class="line">    compile (fragment) &#123;</span><br><span class="line">        <span class="keyword">const</span> nodes = fragment.childNodes</span><br><span class="line">        <span class="built_in">Array</span>.from(nodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isElementNode(node)) &#123; <span class="comment">// 判断元素节点与文本节点</span></span><br><span class="line">                <span class="keyword">this</span>.compileElement(node)</span><br><span class="line">                <span class="keyword">this</span>.compile(node) <span class="comment">// 元素节点需要递归判断</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.compileText(node)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    compileElement (node) &#123;</span><br><span class="line">        <span class="keyword">const</span> attrs = node.attributes</span><br><span class="line">        <span class="built_in">Array</span>.from(attrs).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isDirective(attr)) &#123;</span><br><span class="line">                <span class="keyword">const</span> [, type] = attr.split(<span class="string">'-'</span>)  <span class="comment">// 现在这里 type 就是 model</span></span><br><span class="line">                CompileUtil[type](node, <span class="keyword">this</span>.vm, attr.value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    compileText (node) &#123;</span><br><span class="line">        <span class="keyword">const</span> expr = node.textContent</span><br><span class="line">        <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g</span>  <span class="comment">// &#123;&#123; message &#125;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (reg.test(expr)) &#123;</span><br><span class="line">            CompileUtil[<span class="string">'text'</span>](node, <span class="keyword">this</span>.vm, expr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到对于元素或者文本节点的具体处理我们封装了一个 CompileUtil 对象，来实现它: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">CompileUtil = &#123;</span><br><span class="line">    text (node, vm, expr) &#123;</span><br><span class="line">        <span class="keyword">const</span> updateFn = <span class="keyword">this</span>.updater[<span class="string">'textUpdater'</span>]</span><br><span class="line">        expr.replace(<span class="regexp">/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g</span>, (...arguments) =&gt; &#123;</span><br><span class="line">            <span class="comment">// Boom~, new Watcher 在这</span></span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, <span class="built_in">arguments</span>[<span class="number">1</span>].trim(), newValue =&gt; &#123;</span><br><span class="line">                updateFn &amp;&amp; updateFn(node, <span class="keyword">this</span>.getTextVal(vm, expr)) <span class="comment">// 数据变化时文本节点需要重新获取依赖属性更新文本内容</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn &amp;&amp; updateFn(node, thie.getTextVal(vm, expr)) <span class="comment">// 初始编译</span></span><br><span class="line">    &#125;,</span><br><span class="line">    model (node, vm, expr) &#123;</span><br><span class="line">        <span class="keyword">const</span> udpateFn = <span class="keyword">this</span>.updater[<span class="string">'modelUpdater'</span>]</span><br><span class="line">        <span class="keyword">new</span> Watcher(vm, expr, newValue =&gt; &#123;</span><br><span class="line">            updateFn &amp;&amp; updateFn(node, newValue)</span><br><span class="line">        &#125;)</span><br><span class="line">        node.addEventListener(<span class="string">'input'</span>, e =&gt; &#123; <span class="comment">// 监听 input 事件</span></span><br><span class="line">            <span class="keyword">const</span> newValue = e.target.value</span><br><span class="line">            <span class="keyword">this</span>.setVal(vm, expr, newValue)</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn &amp;&amp; updateFn(node, <span class="keyword">this</span>.getVal(vm, expr))</span><br><span class="line">    &#125;,</span><br><span class="line">    updater: &#123;</span><br><span class="line">        textUpdater (node, value) &#123;</span><br><span class="line">            node.textContent = value <span class="comment">// 文本节点赋值</span></span><br><span class="line">        &#125;,</span><br><span class="line">        modelUpdater (node, value) &#123;</span><br><span class="line">            node.value = value <span class="comment">// 元素节点赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getVal (vm, expr) &#123; <span class="comment">// 对嵌套对象值的获取</span></span><br><span class="line">        <span class="keyword">const</span> attrs = expr.split(<span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">return</span> attrs.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> prev[next]</span><br><span class="line">        &#125;, vm.$data)</span><br><span class="line">    &#125;,</span><br><span class="line">    getTextVal (vm, expr) &#123;</span><br><span class="line">        <span class="keyword">return</span> expr.replace(<span class="regexp">/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g</span>, (...arguemnts) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getVal(vm, <span class="built_in">arguments</span>[<span class="number">1</span>].trim())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    setVal (vm, expr, value) &#123;</span><br><span class="line">        <span class="keyword">const</span> attrs = expr.split(<span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">return</span> attrs.reduce(<span class="function">(<span class="params">prev, next, currentIndex</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentIndex === attrs.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> prev[next] = value <span class="comment">// 对最后的非对象赋值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> prev[next]</span><br><span class="line">        &#125;, vm.$data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时首先将真实DOM节点放入内存中编译 v-model 与 {　{ }　} 两类节点，对于元素节点与文本节点分别以不同的回调函数实例化 Watcher 类，并且完善了对于多层嵌套对象的处理，至此，在编译的过程了关联了对应的 watcher 实例，重新塞回页面后更改属性值便会触发 setter 进而更新页面</p><h3 id="扩展-Proxy"><a href="#扩展-Proxy" class="headerlink" title="扩展: Proxy"></a>扩展: Proxy</h3><p><code>Object.defineProperty</code> 目前实现的双向绑定的缺陷:</p><ul><li>只能对属性进行数据劫持，所以需要深度遍历整个对象</li><li>不能监听到数组数据的变化</li></ul><p>而对于 Vue 来说，它本身做了一定的 hack 可以检测到数组数据的变化:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/array.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">    <span class="string">'push'</span>,</span><br><span class="line">    <span class="string">'pop'</span>,</span><br><span class="line">    <span class="string">'shift'</span>,</span><br><span class="line">    <span class="string">'unshift'</span>,</span><br><span class="line">    <span class="string">'splice'</span>,</span><br><span class="line">    <span class="string">'sort'</span>,</span><br><span class="line">    <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截变异方法并且触发事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得原生函数</span></span><br><span class="line">    <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">    def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = original.call(<span class="keyword">this</span>, args) <span class="comment">// 先调用原生函数</span></span><br><span class="line">        <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">        <span class="keyword">let</span> inserted</span><br><span class="line">        <span class="keyword">switch</span> (method) &#123;  <span class="comment">//　获取到插入的值</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">                inserted = args</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">            inserted = args.splice(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">        <span class="comment">// 触发更新</span></span><br><span class="line">        ob.dep.notify()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过对原生函数的 hack， Vue 可以检测到数据数组的变化，但是还是有局限性：</p><ul><li>不能检测到以下变动的数组<ul><li>利用索引直接设置一个项时，如：<code>vm.items[indexOfItem] = newValue</code></li><li>修改数组的长度时，如：<code>vm.items.length = newLength</code></li></ul></li></ul><p>什么是<a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">Proxy</a>?  原生支持监听数组变化并且可以直接对整个对象进行拦截</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = &#123;</span><br><span class="line">        get(target, property, receiver) &#123;</span><br><span class="line">        getLogger(target, property)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">        set(target, property, value) &#123;</span><br><span class="line">            setBind(value)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> value</span><br><span class="line"><span class="keyword">const</span> pObj = onWatch(obj, v =&gt; &#123; value = v &#125;, (target, property) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get '<span class="subst">$&#123;property&#125;</span>' = <span class="subst">$&#123;target[property]&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">pObj.a.b = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> pArr = onWatch(obj, v =&gt; &#123; value = v &#125;, (target, property) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get '<span class="subst">$&#123;property&#125;</span>' = <span class="subst">$&#123;target[property]&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">pArr[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如今 Proxy 已经基本被各大浏览器都支持，Vue3.0 的计划中就有基于Proxy实现全语言覆盖的变动侦测</p><p>参考链接:</p><ol><li><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/questions.html" target="_blank" rel="noopener">Vue.js技术揭秘：检测变化的注意事项</a></li><li><a href="https://yuchengkai.cn/docs/zh/frontend/framework.html#proxy-%E4%B8%8E-object-defineproperty-%E5%AF%B9%E6%AF%94" target="_blank" rel="noopener">面试图谱：Proxy 与 Object.defineProperty 对比</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;MVVM 由以下三个内容组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Model: 数据模型&lt;/li&gt;
&lt;li&gt;View: 界面&lt;/li&gt;
&lt;li&gt;Vi
      
    
    </summary>
    
    
      <category term="Wheels" scheme="https://jeremygo.cn/tags/Wheels/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(9.30)</title>
    <link href="https://jeremygo.cn/2018/09/29/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-9-30/"/>
    <id>https://jeremygo.cn/2018/09/29/每周精进-9-30/</id>
    <published>2018-09-29T13:10:02.000Z</published>
    <updated>2018-09-29T23:59:27.478Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jeremygo.cn/2018/09/23/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-9-23/">9.23</a>第一周计划总结~</p><ul><li style="list-style: none"><input type="checkbox" checked> 学习实现Promise发布到轮子项目上，并作博客说明　<a href="https://jeremygo.cn/2018/09/28/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise/">戳我</a></li><li style="list-style: none"><input type="checkbox" checked> 基于umi重构react-hackernews　<a href="https://github.com/fxbabys/hackernews-react/tree/master/umi-dva" target="_blank" rel="noopener">戳我</a></li><li style="list-style: none"><input type="checkbox"> 精听六级听力一篇，完成六级作文一篇  Hmmm…</li></ul><p>对于六级实在是有些无奈…</p><p>因此决定报了某贝的六级训练营，只要自己挤时间出来完全跟着老师走就行，不过还能退款~</p><p>同时在这周的学习中发现自己还是更应该多专注在基础知识上，并且贴合周计划安排了更多的循序渐进的学习过程</p><p>10.7日前完成:</p><ul><li>基于 dva &amp; umi &amp; deef 的依赖技术栈尝试开始造自己的Framework</li><li>将已经实现的轮子至少选一个作好博客说明</li><li>跟上＜数据结构与算法之美＞专栏的进度</li><li>至少完成＜你不知道的js＞(中卷)关键部分的阅读</li><li>完成本周六级训练营的基本任务</li><li>10月内完成＜趣谈网络协议＞专栏的阅读</li></ul><p>近期书单：你不知道的JavaScript</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jeremygo.cn/2018/09/23/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-9-23/&quot;&gt;9.23&lt;/a&gt;第一周计划总结~&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;list-style: none
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>从零实现一个Promise</title>
    <link href="https://jeremygo.cn/2018/09/28/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise/"/>
    <id>https://jeremygo.cn/2018/09/28/从零实现一个Promise/</id>
    <published>2018-09-28T01:01:38.000Z</published>
    <updated>2018-09-28T04:40:09.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从暑假开始开发Vue项目，其中使用最频繁的库就是官方推荐的<a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a>，基于Promise的HTTP库，这里参考了几篇优秀的解读文章尝试实现自己的Promise~</p><p>Promise 是 ES6 新增的语法，解决了回调地狱的问题</p></blockquote><p>本文将根据 <a href="https://promisesaplus.com" target="_blank" rel="noopener">Promise A+ 规范</a> 解读并从零实现一个Promise，通过 <a href="https://github.com/promises-aplus/promises-tests#promisesa-compliance-test-suite" target="_blank" rel="noopener">promises-aplus/promises-tests</a> 所有测试</p><h3 id="Promise-标准解读"><a href="#Promise-标准解读" class="headerlink" title="Promise 标准解读"></a>Promise 标准解读</h3><p>Promise 表示一个异步操作的最终结果，主要通过 <code>then</code> 方法与之进行交互，该方法注册了两个回调函数，用来接收 Promise resolve 的终值或者 Promise reject 被拒绝的原因</p><h4 id="Promises-States"><a href="#Promises-States" class="headerlink" title="Promises States"></a>Promises States</h4><p>一个 Promise 必须是以下三个状态之一: </p><ul><li>pending</li><li>fulfilled (resolved)</li><li>rejected</li></ul><p>初始状态为 pending, 一旦转为 fulfilled 或 rejected, 就不能再次转为其它状态, 状态确定的过程叫做 settle</p><h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a><code>then</code> 方法</h4><ul><li>一个 Promise 必须提供一个 <code>then</code>方法，并且接收两个参数，返回的也是一个Promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><h4 id="The-Promise-Resolution-Procedure"><a href="#The-Promise-Resolution-Procedure" class="headerlink" title="The Promise Resolution Procedure"></a>The Promise Resolution Procedure</h4><p>不同实现的 Promise 之间可以无缝地相互调用, 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// MyPromise 表示自己实现的Promise库</span></span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">2</span>)　　　　　<span class="comment">// ES6 Promise</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h3><h4 id="基本构造函数"><a href="#基本构造函数" class="headerlink" title="基本构造函数"></a>基本构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  _this.currentState = PENDING <span class="comment">// Promise当前状态</span></span><br><span class="line">  _this.value = <span class="literal">undefined</span>      <span class="comment">// Promise的值</span></span><br><span class="line"></span><br><span class="line">  _this.resolvedCallbacks = [] <span class="comment">// 用于状态为 pending 时保存 then　中的回调</span></span><br><span class="line">  _this.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123; <span class="comment">// 若 value 是一个 Promise　则递归执行</span></span><br><span class="line">      <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 标准3.1: 异步执行</span></span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = RESOLVED</span><br><span class="line">        _this.value = value</span><br><span class="line">        _this.resolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = REJECTED</span><br><span class="line">        _this.value = reason</span><br><span class="line">        _this.rejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;  <span class="comment">// 考虑到执行fn时可能出错, 所以这里try/catch一下, 并将catch到的值reject回去</span></span><br><span class="line">    fn(_this.resolve, _this.reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    _this.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="then-方法-1"><a href="#then-方法-1" class="headerlink" title="then 方法"></a><code>then</code> 方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 规范 2.2.7: then 必须返回一个新的Promise</span></span><br><span class="line">  <span class="keyword">let</span> promise2</span><br><span class="line">  <span class="comment">// 规范 2.2: onResolved 和 onRejected 为可选参数 如果类型不是函数需要忽略并且实现了透传</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="params">v</span> =&gt;</span> v</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> &#123; <span class="keyword">throw</span> r &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === RESOLVED) &#123;</span><br><span class="line">    <span class="comment">// promise1(this/self)的状态已经确定并且为resolved, 调用onResolved</span></span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 规范 2.2.4: 保证 onFulfilled onRjected 异步执行</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onResolved(self.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(self.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === PENDING) &#123;</span><br><span class="line">    <span class="comment">// 当前Promise还处于pending状态不能确定调用onResolved还是onRejected</span></span><br><span class="line">    <span class="comment">// 所以需要将 两种情况的判断处理逻辑 作为callback 放入当前Promise对象的回调数组里</span></span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.resolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onResolved(self.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.rejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> x = onRejected(self.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同Promise间的交互"><a href="#不同Promise间的交互" class="headerlink" title="不同Promise间的交互"></a>不同Promise间的交互</h4><p><code>then</code> 方法返回 <code>x</code> 可能是一个Promise对象(thenable)，为了确保调用成功，需要实现标准2.3的内容，这样即使实现方式不同，但遵循同样的标准不同的Promise之间也可以无缝地相互调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规范2.3: 针对不同的Promise实现交互</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span> (<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 规范2.3.1: x与promise2不能相同, 避免循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaing cycle detected for promise'</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 规范2.3.2: x是一个Promise 状态为pending则需要继续等待 否则执行</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">      x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">      &#125;, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.3.3.3: resolve或reject其中一个执行过则忽略其它的</span></span><br><span class="line">  <span class="keyword">let</span> thenCalledOrThrow = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123; <span class="comment">// 规范2.3.3</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2.3.3.1: x.then可能是getter（函数）, 如果是函数就执行</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.3.3.3</span></span><br><span class="line">        then.call(</span><br><span class="line">          x, </span><br><span class="line">          y =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>  <span class="comment">// 2.3.3.3.3 三处谁执行就以谁的为准</span></span><br><span class="line">            thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">            resolutionProcedure(promise2, y, resolve, reject)  <span class="comment">// 2.3.3.3.1</span></span><br><span class="line">          &#125;,</span><br><span class="line">          r =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>  <span class="comment">// 2.3.3.3.3 三处谁执行就以谁的为准</span></span><br><span class="line">            thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">            reject(r)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span></span><br><span class="line">      thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.3.4</span></span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在上述完整代码最后加入测试的脚本:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dfd = &#123;&#125;</span><br><span class="line">  dfd.promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    dfd.resolve = resolve</span><br><span class="line">    dfd.reject = reject</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = MyPromise</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后安装 <code>promises-aplus-tests</code>  执行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g promises-aplus-tests</span><br><span class="line">promises-aplus-tests Promise.js</span><br></pre></td></tr></table></figure><p>Success !</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1fvp1uj1rk3j20kt09cjsa.jpg" alt=""></p><p>参考链接：</p><p><a href="https://yuchengkai.cn/docs/zh/frontend/#promise-%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">面试图谱: Promise实现</a></p><p><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="noopener">剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;从暑假开始开发Vue项目，其中使用最频繁的库就是官方推荐的&lt;a href=&quot;https://github.com/axios/axios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;axios&lt;/a&gt;，基于Promise的HTT
      
    
    </summary>
    
    
      <category term="Wheels" scheme="https://jeremygo.cn/tags/Wheels/"/>
    
  </entry>
  
  <entry>
    <title>每周精进(9.23)</title>
    <link href="https://jeremygo.cn/2018/09/23/%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-9-23/"/>
    <id>https://jeremygo.cn/2018/09/23/每周精进-9-23/</id>
    <published>2018-09-23T00:31:04.000Z</published>
    <updated>2018-09-24T16:28:10.079Z</updated>
    
    <content type="html"><![CDATA[<p>从暑假结束到现在近一个月, 大部分的时间都在忙课程和组织迎新, 整体的学习感觉并不好, 博客和github都一直在闲置,  趁着放假的机会好好整理一下思绪, 还是希望能利用好最后一个学期上课的时间多做明年春招的准备,争取进入大厂去见识更广阔的世界~</p><p>因此决定坚持开始一个每周有所精进的阶段, 每周日定好下一周的小目标, 下一周最先开始说明目标完成情况,以此督促自己~</p><p>9.30日前完成: </p><ul><li>学习实现Promise发布到轮子项目上, 尽量能作博客说明</li><li>基于umi重构react-hackernews</li><li>精听六级听力一篇. 完成六级作文一篇</li></ul><p>近期书单:  Node.js: 来一打C++扩展</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从暑假结束到现在近一个月, 大部分的时间都在忙课程和组织迎新, 整体的学习感觉并不好, 博客和github都一直在闲置,  趁着放假的机会好好整理一下思绪, 还是希望能利用好最后一个学期上课的时间多做明年春招的准备,争取进入大厂去见识更广阔的世界~&lt;/p&gt;
&lt;p&gt;因此决定坚
      
    
    </summary>
    
    
      <category term="周计划" scheme="https://jeremygo.cn/tags/%E5%91%A8%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>移动端页面开发总结</title>
    <link href="https://jeremygo.cn/2018/08/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>https://jeremygo.cn/2018/08/04/移动端页面开发总结/</id>
    <published>2018-08-04T15:35:28.000Z</published>
    <updated>2018-08-04T16:46:06.869Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工作室暑期集训在带17级成员做官网，这里主要总结一些移动端页面开发的基本知识~</p></blockquote><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><ul><li>概念：一个像素就是计算机屏幕所能显示一种特定颜色的最小区域</li><li>web前端开发中：<ul><li>设备像素：设备屏幕的物理像素，对任何设备来说物理像素的数量是固定的</li><li>CSS像素：抽象的像素概念，专为web开发者创造<ul><li>比如：给一个元素设置 <code>width: 200px</code> 即这个元素的宽度跨越了200个CSS像素</li><li>跨越的设备像素：取决于<strong>手机屏幕</strong>和<strong>用户的缩放</strong><ul><li>iPhone的像素密度是普通屏幕的2倍此时<code>200px</code> 跨越了400个设备像素</li><li>用户缩小页面到一定程度时，一个CSS像素会明显小于一个设备像素，用户缩放页面就是在缩放CSS像素，设备像素大小数量都是固定的</li></ul></li></ul></li></ul></li></ul><h3 id="移动端的视口"><a href="#移动端的视口" class="headerlink" title="移动端的视口"></a>移动端的视口</h3><ul><li><p>视口是html的父元素，也称为初始包含块，即<strong>html元素的百分比是基于视口的</strong></p></li><li><p>布局视口：移动端CSS布局的依据视口</p><ul><li><p>PC浏览器中，视口的宽度 = 浏览器窗口的宽度</p></li><li><p>移动端中CSS布局会依据布局视口来计算</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1fty3uhhse3j208c0anq4l.jpg" alt=""></p></li><li><p>获取布局视口的宽高：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight</span><br></pre></td></tr></table></figure></li></ul></li><li><p>视觉视口：用户所看见的网站区域</p></li><li><p>理想视口：理想的布局视口：</p><ul><li><p>将布局视口设为理想视口</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name="viewport" content="width=device-width" /&gt;</span><br></pre></td></tr></table></figure><p>width指布局视口的宽度、device-width指理想视口的宽度</p></li></ul></li></ul><h3 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h3><ul><li><p>Device Pixel Ratio（DPR），计算公式：</p><ul><li>前提（缩放比例为1）：DPR = 设备像素个数 / 理想视口CSS像素个数（device-width）</li><li>浏览器手机预览模式显示的是<strong>理想视口宽高</strong></li></ul></li><li><p>缩放页面：缩小放大的是CSS像素</p></li><li><p>meta 标签：</p><ul><li><p>让布局视口和理想视口的宽度匹配，常用属性：</p><blockquote><ol><li>width: 设置布局视口的宽</li><li>init-scale：设置页面的初始缩放程度</li><li>minimum-scale：设置页面的最小缩放程度</li><li>maximum-scale：设置页面的最大缩放程度</li><li>user-scalable：是否允许用户对页面进行缩放</li></ol></blockquote></li><li><p>常用实例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span><br></pre></td></tr></table></figure></li></ul></li><li><p>媒体查询：</p><ul><li><p>响应式设计的基础：</p><ul><li>检测媒体类型，如 screen、tv等</li><li>检测布局视口的特性，如视口的宽高分辨率等</li><li>特性相关查询，如检测浏览器是否支持某某特性</li></ul></li><li><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> 媒体类型 and (视口特性阈值) &#123;</span><br><span class="line">    // css code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="从设计图到页面开发"><a href="#从设计图到页面开发" class="headerlink" title="从设计图到页面开发"></a>从设计图到页面开发</h3><ul><li><p>起因：设计图依据设备像素进行设计，而CSS布局依据布局视口的尺寸进行计算</p></li><li><p>解决方案一：</p><ul><li><p>将布局视口的尺寸设置为和设备像素尺寸相等，在设置meta标签后即需要设置理想视口尺寸</p><ul><li><p>CSS缩放值 = 设备像素比的倒数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>).setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width, initial-scale='</span> + scale + <span class="string">', maximum-scale='</span> + scale + <span class="string">', minimum-scale='</span> + scale + <span class="string">', user-scalable=no'</span></span><br></pre></td></tr></table></figure><p>无论任何设备，布局视口的宽度总是等于设备像素</p></li></ul></li><li><p>元素跟着设备变化而等比缩放</p><ul><li><p>rem：<strong>相对于html标签字体大小的单位</strong></p></li><li><p>动态设置html字体大小：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = <span class="built_in">document</span>.documentElemet.clientWidth / <span class="number">10</span> + <span class="string">'px'</span></span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>文字字体大小还是用px</strong></p></li></ul></li><li><p>思路：通过js动态修改meta标签使布局视口尺寸等于设计图尺寸（设备像素尺寸），再用rem代替px使得页面在不同设备中等比缩放</p></li></ul></li><li><p>解决方案二：</p><ul><li><p>不修改meta标签，正常使用缩放为1:1的meta标签</p></li><li><p>将页面的总宽度设置为以rem为单位的定值，如750px总宽取100px的font-size即7.5rem</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">7.5</span> + <span class="string">'px'</span></span><br></pre></td></tr></table></figure></li><li><p>开发页面时通过设计图尺寸/100得到rem尺寸</p></li></ul></li><li><p>文字字体大小设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">321px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">16px</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">321px</span>) and (max-width: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">17px</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">19px</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新的思路</p><ul><li><p>沿用rem布局方案，所有布局元素与属性采用rem做单位</p></li><li><p><strong>html设置font-size使用vw视口单位</strong></p><p>​</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;工作室暑期集训在带17级成员做官网，这里主要总结一些移动端页面开发的基本知识~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;像素&quot;&gt;&lt;a href=&quot;#像素&quot; class=&quot;headerlink&quot; title=&quot;像素&quot;&gt;&lt;/a&gt;像素&lt;/h3
      
    
    </summary>
    
    
      <category term="CSS" scheme="https://jeremygo.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vuex核心</title>
    <link href="https://jeremygo.cn/2018/07/13/Vuex%E6%A0%B8%E5%BF%83/"/>
    <id>https://jeremygo.cn/2018/07/13/Vuex核心/</id>
    <published>2018-07-13T12:54:54.000Z</published>
    <updated>2018-08-02T12:11:47.587Z</updated>
    
    <content type="html"><![CDATA[<p>在封装<a href="https://github.com/fxbabys/hy-vue-admin" target="_blank" rel="noopener">Hy-Vue-Admin</a> 的登录逻辑时，对于登录状态的管理设计刚开始利用很直观的全局cookie保存状态，写起来感觉很别扭而且麻烦，参考了成熟的后台管理模板登录的逻辑以后决定使用Vue官方推荐的Vuex进行全局状态的管理：</p><blockquote><p>Vuex 是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。  —— 官方定义</p></blockquote><h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><ul><li>使用Vue开发单页应用时，经常需要操作一些组件间共享的数据或状态：<ul><li>应用规模较小时，可以使用 props、事件等常用的父子组件的组件间通信方法，单向数据流</li><li>应用规模较大时，即多个组件共享状态时，单向数据流的简洁性很容易被破坏：<ul><li>多个视图依赖于同一状态</li><li>不同视图的行为需要变更同一状态</li></ul></li></ul></li><li>传统解决方式存在的问题：<ul><li>对问题一：传参的方法在多层嵌套的组件下将会变得十分繁琐并且无法处理兄弟组件间状态传递的情况</li><li>对问题二：经常采用父子组件直接引用或者通过事件来变更和同步多个组件间状态的多份拷贝，这种模式非常低效，很容易导致无法维护的代码</li></ul></li><li>新的思路：<ul><li>将组件的共享状态抽取出来，以一个全局单例模式管理</li><li>不管在组件树的哪个位置，任何组件都能直接获取状态或者触发行为</li><li>通过定义和隔离状态管理中的各种概念并且强制遵守一定的规则，代码会更结构化且易维护</li></ul></li></ul><p>先放一张官方图~~</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1ft8jrzhbghj20jh0fb0ta.jpg" alt=""></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>单一状态树理念，每个应用只包含一个 store 实例</p><ul><li><p>Vuex 通过 store 选项将状态从根组件注入到每一个子组件中（<code>Vue.use(Vuex)</code>）:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    store, <span class="comment">// 把 store 对象提供给 store 选项</span></span><br><span class="line">    components: &#123; Counter &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Vue 组件中获取 Vuex 状态：子组件通过 <code>this.$store</code> 访问到 store 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123; Count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapState 辅助函数 与 对象展开运算符</p></li><li>组件仍然保有局部状态<ul><li>使用 Vuex 并不是一定需要将所有的状态放入Vuex</li><li>如果有的状态严格属于单个组件，最好还是作为组件的局部状态</li></ul></li></ul><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 中的 store 中的状态的唯一方法是提交 mutation：</p><ul><li>每个 mutation 都有一个字符串的 事件类型（type） 和一个 回调函数（handler）。回调函数就是我们实际进行状态更改的地方，并且它会默认接受 state 作为第一个参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>不能直接调用一个 mutation handler，要以事件注册的理念：当触发一个类型为 <code>increment</code> 的mutation时，调用此函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><ul><li>提交载荷：可以向 <code>store.commit</code> 传入额外的参数</li><li>Mutation 必须是同步函数：任何由 mutation 事件类型导致的状态变更都应在此刻完成</li></ul><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>类似于 mutation ，区别：</p><ul><li>Action 提交的是 mutation，不是直接变更状态</li><li>Action 可以包含任意异步操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        increment (context) &#123;</span><br><span class="line">            context.commit(<span class="string">'increment'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，即可以通过 <code>context.commit</code> 提交一个mutation</p><ul><li><p>Action 通过 <code>store.dispatch</code> 方法触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>使用单一状态树，应用的所有状态将会集中到一个很大的对象，store对象容易变得臃肿</p><p>因此，Vuex允许我们将store分割成模块，每个模块拥有自己的 state、mutation、action甚至是嵌套子模块</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>src 目录下写全局状态管理的代码，其中包含了 user 的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">|—— api</span><br><span class="line">  |—— login.js      # user login api接口</span><br><span class="line">|—— ……</span><br><span class="line">|—— ……</span><br><span class="line">|—— store</span><br><span class="line">  |—— modules</span><br><span class="line">  |—— user.js     # store中的user module</span><br><span class="line">  |—— getters.js</span><br><span class="line">  |—— index.js</span><br><span class="line">|—— utils</span><br><span class="line">  |—— auth.js       # 对user token的相关操作</span><br><span class="line">  |—— request.js    # axios 登录请求的拦截器</span><br></pre></td></tr></table></figure><p>store 中的user module：</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1ft95ctmkx1j20g50l8405.jpg" alt=""></p><p>Login.vue 中 点击登录分发 Action Login：</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1ft95ewfxw6j20cs0a4q3o.jpg" alt=""></p><p>user模块中actions首先调用登录接口，成功返回token后提交commit设置state token并且使用cookie保存token：</p><p><img src="http://ww1.sinaimg.cn/large/e4336439gy1ft95holq1uj20ho06j0t8.jpg" alt=""></p><p>至此登录保存token状态的整体逻辑完成</p><p>退出的逻辑也与这个类似，点击退出分发action，调用退出接口返回成功状态码后提交commit设置state token为空并删除cookie，可自行阅读实现代码~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在封装&lt;a href=&quot;https://github.com/fxbabys/hy-vue-admin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hy-Vue-Admin&lt;/a&gt; 的登录逻辑时，对于登录状态的管理设计刚开始利用很直观的全局cookie保
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://jeremygo.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习</title>
    <link href="https://jeremygo.cn/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <id>https://jeremygo.cn/2018/06/29/计算机网络复习/</id>
    <published>2018-06-29T12:23:06.000Z</published>
    <updated>2018-06-30T03:40:30.562Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络相关知识的复习整理~</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="单工、半双工、双工、串行和并行通信"><a href="#单工、半双工、双工、串行和并行通信" class="headerlink" title="单工、半双工、双工、串行和并行通信"></a>单工、半双工、双工、串行和并行通信</h4><ul><li>单工：只有一个信道，传输方向只能单向</li><li>半双工：只有一个信道，传输方向为双向，但同一时刻只能单向传输</li><li>全双工：双信道，同时可以双向数据传输</li><li>串行通信：一组数据在一条线路上一位一位的传送</li><li>并行通信：一组数据在多条线路上同时传送</li></ul><h4 id="协议的三要素"><a href="#协议的三要素" class="headerlink" title="协议的三要素"></a>协议的三要素</h4><ul><li>语法</li><li>语义</li><li>同步</li></ul><h4 id="比较电路交换、分组交换、报文交换"><a href="#比较电路交换、分组交换、报文交换" class="headerlink" title="比较电路交换、分组交换、报文交换"></a>比较电路交换、分组交换、报文交换</h4><table><thead><tr><th>交换方式</th><th>优点（本质/核心思想）</th><th>缺点</th></tr></thead><tbody><tr><td>电路交换</td><td>（1）资源独占 （2）提供面向连接的服务 （3）通信相对可靠</td><td>（1）成本高 （2）资源利用率低</td></tr><tr><td>分组交换</td><td>（1）分组 （2）存储转发 （3）资源共享 （4）灵活性高，适合计算机之间的通信</td><td>（1）可靠性不高 （2）可能出现延迟和堵塞</td></tr><tr><td>报文交换</td><td>不分组的分组交换</td></tr></tbody></table><h4 id="比较数据报网络和虚电路网络"><a href="#比较数据报网络和虚电路网络" class="headerlink" title="比较数据报网络和虚电路网络"></a>比较数据报网络和虚电路网络</h4><table><thead><tr><th style="text-align:center">分组交换方式</th><th style="text-align:center">数据报网络</th><th style="text-align:center">虚电路网络</th></tr></thead><tbody><tr><td style="text-align:center">路由模式</td><td style="text-align:center">源端向目的端发送分组，远端仅根据目标端选择下一条路，分组会在下一结点选择最优的下一条路，同一文件的不同分组可能沿不同的路传输</td><td style="text-align:center">远端与目的端首先建立一条虚拟电路，结点根据分组标签确定所走的虚电路，同一文件的不同分组沿同一条虚电路传输</td></tr><tr><td style="text-align:center">可靠性</td><td style="text-align:center">不强，可能形成环路</td><td style="text-align:center">较好</td></tr><tr><td style="text-align:center">路由器工作量</td><td style="text-align:center">相对较小</td><td style="text-align:center">较高，需要维护每条虚电路的状态</td></tr><tr><td style="text-align:center">QoS</td><td style="text-align:center">不易实现</td><td style="text-align:center">容易实现</td></tr><tr><td style="text-align:center">使用范围</td><td style="text-align:center">因特网</td><td style="text-align:center">ATM、帧中继网络</td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center">灵活、简单</td><td style="text-align:center">复杂</td></tr></tbody></table><h4 id="比较面向连接和无连接服务"><a href="#比较面向连接和无连接服务" class="headerlink" title="比较面向连接和无连接服务"></a>比较面向连接和无连接服务</h4><table><thead><tr><th>服务方式</th><th>面向连接</th><th>无连接</th></tr></thead><tbody><tr><td>数据传输</td><td>建立连接、数据通信、释放连接</td><td>无需连接、直接通信</td></tr><tr><td>可靠性</td><td>可靠</td><td>不可靠，但速度快（尽最大努力服务）</td></tr><tr><td>传输层相应协议</td><td>TCP，电路交换，虚电路</td><td>UDP，IP，Ethernet</td></tr></tbody></table><h4 id="比较带宽、吞吐量和传播速度"><a href="#比较带宽、吞吐量和传播速度" class="headerlink" title="比较带宽、吞吐量和传播速度"></a>比较带宽、吞吐量和传播速度</h4><ul><li>带宽：网络可通过的最高数据传输速率（bit/s）</li><li>吞吐量：网络实际通过的数据传输速率</li><li>传播速度：信号在介质上的传播速率（m/s）</li></ul><h4 id="详细说明分组交换网的延迟有哪些及造成的原因"><a href="#详细说明分组交换网的延迟有哪些及造成的原因" class="headerlink" title="详细说明分组交换网的延迟有哪些及造成的原因"></a>详细说明分组交换网的延迟有哪些及造成的原因</h4><table><thead><tr><th style="text-align:center">延迟类型</th><th style="text-align:center">定义</th><th style="text-align:center">原因</th></tr></thead><tbody><tr><td style="text-align:center">传输延迟</td><td style="text-align:center">数据从结点发送到链路上所消耗的时间</td><td style="text-align:center">网络带宽，数据大小，链路特性，网络特性</td></tr><tr><td style="text-align:center">传播延迟</td><td style="text-align:center">信号从一个结点发送到另一个结点在链路上所消耗的时间</td><td style="text-align:center">传播介质，链路长度</td></tr><tr><td style="text-align:center">结点处理延迟（排队延迟和处理延迟）</td><td style="text-align:center">路由器上排队等待、数据处理和转发至输出链路等所消耗的时间</td><td style="text-align:center">网络拥塞程度，转发表规模，路由器性能</td></tr></tbody></table><h4 id="ping、tracert、ipconfig、nslookup、netstat-的作用"><a href="#ping、tracert、ipconfig、nslookup、netstat-的作用" class="headerlink" title="ping、tracert、ipconfig、nslookup、netstat 的作用"></a>ping、tracert、ipconfig、nslookup、netstat 的作用</h4><ul><li>ping和tracert均用以验证简单TCP/IP网络的连通性</li><li>ping：默认测试4次，发送ICMP请求数据包，并等待接收方的ICMP应答包，显示RTT（Round-trip time，往返时延）和TTL（Time to live，生存时间）</li><li>tracert：通过TTL的递增对路由进行跟踪，测试并显示每个结点的往返时延3次</li></ul><h4 id="什么是互联网"><a href="#什么是互联网" class="headerlink" title="什么是互联网"></a>什么是互联网</h4><ul><li>互联网是网络的网络，它是将全球异构的网络互联起来的网络。互联网由许多终端设备、通信介质和中间设备组成，在TCP/IP协议簇的基础上通过各种应用程序进行通信</li></ul><h4 id="双绞线的制作方法（T568B和T568A）"><a href="#双绞线的制作方法（T568B和T568A）" class="headerlink" title="双绞线的制作方法（T568B和T568A）"></a>双绞线的制作方法（T568B和T568A）</h4><ul><li>T568B：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕</li><li>T568A：白绿，绿，白橙，蓝，白蓝，橙白棕，棕</li></ul><h4 id="直通线和交叉线的应用"><a href="#直通线和交叉线的应用" class="headerlink" title="直通线和交叉线的应用"></a>直通线和交叉线的应用</h4><ul><li>直通线：两端均为T568B，一般用于不同类设备之间</li><li>交叉线：一端为T568B、一端为T568A，一般用于相同或相近设备之间</li></ul><h4 id="网络为什么要分层，如何分层，分层之后如何发送和接收数据以及分层的理解"><a href="#网络为什么要分层，如何分层，分层之后如何发送和接收数据以及分层的理解" class="headerlink" title="网络为什么要分层，如何分层，分层之后如何发送和接收数据以及分层的理解"></a>网络为什么要分层，如何分层，分层之后如何发送和接收数据以及分层的理解</h4><ul><li>分层原因：简单、容易学习与讨论。模块化的设计便于讨论，同时也简化了维护和升级。具体表现在某个层次的服务对系统的其他层次透明，且某个层次的改变只需改变与其相邻层次的接口</li></ul><table><thead><tr><th>OSI体系结构</th><th>TCP/IP 体系结构</th><th>各分层作用</th><th>PDU（协议数据单元）</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>负责各种网络应用、进程与进程之间的通信</td><td>消息</td></tr><tr><td>表示层</td><td></td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>负责端到端数据的传输控制</td><td>报文段</td></tr><tr><td>网络层</td><td>网络层（网际层）</td><td>负责选路和不同网段数据的转发</td><td>分组</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>数据在一段链路上相邻结点间的传输</td><td>帧</td></tr><tr><td>物理层</td><td>物理层</td><td>负责信号物理通信的规则</td><td>比特流</td></tr></tbody></table><p>  数据的发送与接收：发送端将数据进行层层封装（应用层、传输层、网络层和数据链路层均在上一层的基础上加一首部，同时数据链路层在分组最后加一CRC冗余校验码尾部），接收端则按层次结构由下向上层层解封，获得原始数据</p><ul><li>协议分层：协议是对两个对等实体进行通信的规则的集合，其下层为上层提供服务且对上层透明，对某层协议而言，收发双方使用的协议是相同即水平的；而各层协议间下层对上层提供的服务的接口的服务是垂直的</li></ul><h4 id="计算机网络通信的分层模型包含哪些地址信息？"><a href="#计算机网络通信的分层模型包含哪些地址信息？" class="headerlink" title="计算机网络通信的分层模型包含哪些地址信息？"></a>计算机网络通信的分层模型包含哪些地址信息？</h4><table><thead><tr><th>地址</th><th>作用</th><th>所在分层</th></tr></thead><tbody><tr><td>端口（源端口、目的端口）</td><td>传输层向应用层提供的地址，以区分不同应用程序的数据</td><td>传输层</td></tr><tr><td>IP地址（源IP地址、目的IP地址）</td><td>网络层提供的地址，以区分不同网络间的收发双方</td><td>网络层</td></tr><tr><td>MAC地址（源MAC地址、目的MAC地址）</td><td>数据链路层的地址，以区分同一网络内的收发双方</td><td>数据链路层</td></tr></tbody></table><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="网络应用的两种模式"><a href="#网络应用的两种模式" class="headerlink" title="网络应用的两种模式"></a>网络应用的两种模式</h4><ul><li>C/S：客户端-服务器模式，客户向服务器发送请求，服务器响应并提供服务，双方IP地址不能随意改变</li><li>P2P：对等模式，任意的主机既是客户端，又是服务器</li></ul><h4 id="套接字的概念"><a href="#套接字的概念" class="headerlink" title="套接字的概念"></a>套接字的概念</h4><ul><li>套接字=IP地址+端口号，用以唯一确定某台主机的某个进程</li><li>IP地址：IPv4为32位、IPv6为128位，用以唯一确定某台主机在因特网上的位置</li><li>端口号：16位，用以唯一确定某台主机的某个通信进程</li></ul><h4 id="常见网络应用的端口号"><a href="#常见网络应用的端口号" class="headerlink" title="常见网络应用的端口号"></a>常见网络应用的端口号</h4><p>（C:\Windows\System32\drivers\etc\services）</p><table><thead><tr><th>协议</th><th>端口号</th><th>传输层</th><th>定义</th></tr></thead><tbody><tr><td>ftp-data</td><td>20</td><td>tcp</td><td>FTP，data</td></tr><tr><td>ftp</td><td>21</td><td>tcp</td><td>FTP，control</td></tr><tr><td></td><td>22</td><td>tcp</td><td>SSH Remote Login Protocol</td></tr><tr><td>telnet</td><td>23</td><td>tcp</td><td></td></tr><tr><td>smtp</td><td>25</td><td>tcp</td><td>Simple Mail Transfer</td></tr><tr><td>DNS</td><td>53</td><td>tcp、udp</td><td>Domain Name Server</td></tr><tr><td>http</td><td>80</td><td>tcp</td><td>World Wide Web</td></tr><tr><td>pop3</td><td>110</td><td>tcp</td><td>Post Office protocol Version3</td></tr><tr><td>https</td><td>443</td><td>tcp、udp</td><td>HTTP over TLS/SSL</td></tr></tbody></table><h4 id="DNS的查询方式"><a href="#DNS的查询方式" class="headerlink" title="DNS的查询方式"></a>DNS的查询方式</h4><table><thead><tr><th>查询方式</th><th>查询模式</th><th>区别</th></tr></thead><tbody><tr><td>递归查询</td><td>正向查询</td><td>当根域名服务器不能解析时，其会直接向目标域名的授权域名服务器查询，并将结果返回给发送器请求的本地域名服务器</td></tr><tr><td>迭代查询</td><td>正向查询</td><td>当根域名服务器不能解析时，其会直接返回目标域名的授权域名服务器地址给发送请求的本地域名服务器，让请求方自行查询</td></tr><tr><td>反向查询</td><td>反向查询</td><td>通过IP地址获得相应的域名地址</td></tr></tbody></table><h4 id="URL的概念"><a href="#URL的概念" class="headerlink" title="URL的概念"></a>URL的概念</h4><ul><li>URL，统一资源定位符，用以在整个因特网内唯一标记网上的各种文档和对象</li></ul><h4 id="HTTP协议概述，比较HTTP1-0和HTTP1-1"><a href="#HTTP协议概述，比较HTTP1-0和HTTP1-1" class="headerlink" title="HTTP协议概述，比较HTTP1.0和HTTP1.1"></a>HTTP协议概述，比较HTTP1.0和HTTP1.1</h4><ul><li>HTTP：超文本传送协议，应用层协议之一，因特网中最重要的协议之一，通常用于进行web页面的传输，采用C/S模式工作，使用TCP作为传输层协议，默认使用80端口，具体包括HTTP1.0和HTTP1.1两类</li><li>HTTP1.0：非持续连接，使用多条TCP连接获取对象，在完整收到每个对象后才发送下一个对象的请求</li><li>HTTP1.1：持续连接，在同一条TCP连接上同时发送多个页面链接的请求，并依次接收</li></ul><h4 id="FTP的基本概念"><a href="#FTP的基本概念" class="headerlink" title="FTP的基本概念"></a>FTP的基本概念</h4><ul><li>FTP，文件传输协议，应用层协议之一，采用C/S模式工作，使用TCP作为传输层协议，FTP属于维护状态的协议，默认使用数据端口为20，控制端口为21。使用两条连接的好处在于使FTP的控制更容易，编程更方便，且使整个传输过程中连接都不断开，更有助于状态的维护。同时当FTP传输一个文件结束后，控制连接并不断开，如果要重新下一个新文件，仅需控制连接重新协商建立新的数据连接</li></ul><h4 id="了解电子邮件相关的协议：smtp，pop，mime，imap"><a href="#了解电子邮件相关的协议：smtp，pop，mime，imap" class="headerlink" title="了解电子邮件相关的协议：smtp，pop，mime，imap"></a>了解电子邮件相关的协议：smtp，pop，mime，imap</h4><h4 id="DNS中RR的类型"><a href="#DNS中RR的类型" class="headerlink" title="DNS中RR的类型"></a>DNS中RR的类型</h4><table><thead><tr><th>type</th><th>value</th></tr></thead><tbody><tr><td>A</td><td>域名对应的IP地址</td></tr><tr><td>NS</td><td>域名对应的权威域名服务器名称</td></tr><tr><td>CNAME</td><td>域名对应的别名</td></tr><tr><td>MX</td><td>域名对应的邮件服务器名称</td></tr><tr><td>PTR</td><td>Name对应的名字（反向查询）</td></tr></tbody></table><h4 id="电子邮件系统的组成"><a href="#电子邮件系统的组成" class="headerlink" title="电子邮件系统的组成"></a>电子邮件系统的组成</h4><ul><li>用户代理：电子邮件客户端软件</li><li>邮件服务器：提供邮件服务的主机</li><li>邮件发送和接收协议</li></ul><h4 id="常用cmd命令"><a href="#常用cmd命令" class="headerlink" title="常用cmd命令"></a>常用cmd命令</h4><ul><li>nslookup：域名查询，查询internet域名信息</li><li>ftp：传送文件</li><li>telnet：远程控制</li><li>ping：可以检查网络是否连通</li><li>tracert：用于确定IP数据包访问目标所采取的路径</li><li>netstat：查看在内核中访问网络及相关信息的程序</li><li>ipconfig：可用于显示当前的TCP/IP配置的设置值</li><li>arp：可查看局域网内IP与MAC地址的对应，静态配置记录，情况记录等</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="比较传输层和网络层"><a href="#比较传输层和网络层" class="headerlink" title="比较传输层和网络层"></a>比较传输层和网络层</h4><ul><li>传输层负责端到端之间的数据传输的控制。传输层依赖于网络层的服务，传输层向应用层提供服务。网络层主要为主机之间如何选路而到达目的端提供服务，而传输层加强了网络层的服务，在数据能到达对方的前提下，对数据传输进行控制，为进程间的通信提供服务</li></ul><h4 id="比较UDP和TCP"><a href="#比较UDP和TCP" class="headerlink" title="比较UDP和TCP"></a>比较UDP和TCP</h4><table><thead><tr><th>传输服务</th><th style="text-align:center">可靠性</th><th style="text-align:center">设计理念</th><th style="text-align:center">面向连接</th><th style="text-align:center">流量控制</th><th style="text-align:center">拥塞控制</th><th style="text-align:center">三次握手</th><th style="text-align:center">协议首部</th></tr></thead><tbody><tr><td>UDP</td><td style="text-align:center">不可靠</td><td style="text-align:center">尽力而为，可以乱序甚至丢失</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center"></td></tr><tr><td>TCP</td><td style="text-align:center">可靠</td><td style="text-align:center">必须保证数据正确、按序到达接收端。采用：序号机制、确认机制、缓存机制、重传机制、滑动窗口机制</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr></tbody></table><h4 id="停止等待协议的实现机制"><a href="#停止等待协议的实现机制" class="headerlink" title="停止等待协议的实现机制"></a>停止等待协议的实现机制</h4><ul><li>停止等待协议：SW，发送方每发送一个报文，必须等待接收方确认后才能发送下一个报文</li><li>rdt1.0：在信道完全可靠地前提下（数据不会出错和乱序），无需做其它处理即可实现停等协议</li><li>rdt2.0：在信道可能出错的前提下（数据乱序但不会丢失），使用ACK/NAK机制，发送方建有数据缓存，当收到ACK后发送下一分组，收到NAK则重传</li><li>rdt2.1：在信道可能出错的前提下做了进一步的改进，发送方对每个分组0/1循环编号，接收方将对每个收到的分组进行确认，回复数据所编的序号；如遇到重复分组，接收方丢弃并对分组再次确认（仍回复所编序号即可）；如遇到数据错误，则回复上一次正确的确认序号</li><li>rdt3.0：在信道中数据可能乱序甚至出错的前提下，发送方在rdt2.1的基础上，进一步通过“超时”机制发现数据丢失（超时不一定数据丢失，此时编号机制仍能控制传输）</li></ul><h4 id="比较GBN和SR"><a href="#比较GBN和SR" class="headerlink" title="比较GBN和SR"></a>比较GBN和SR</h4><ul><li>GBN和SR都属于滑动窗口协议</li><li>滑动窗口协议允许发送方在没有收到接收方的ACK的前提下发送多个数据包，因此有以下三点改变<ul><li>发送方需要使用发送窗口来限制没有收到ACK情况下最多发送的数据量</li><li>发送方和接收方均增加缓存</li><li>分组序号必须增大</li></ul></li></ul><table><thead><tr><th style="text-align:center">发送类型</th><th style="text-align:center">发送方</th><th style="text-align:center">接收方</th><th style="text-align:center">累计确认</th><th style="text-align:center">窗口大小</th></tr></thead><tbody><tr><td style="text-align:center">GBN</td><td style="text-align:center">连续发送至窗口满，然后等待，收到接收方确认后窗口向后移动。某个分组出错或丢失则重传该分组即其后面所有已发送但未收到确认的分组</td><td style="text-align:center">对按序到达的分组确认，对乱序或错误的分组丢弃，并发送最后一次正确收到的分组的确认</td><td style="text-align:center">某一分组的确认意味着之前所有分组均正确</td><td style="text-align:center">序号个数-1</td></tr><tr><td style="text-align:center">SR</td><td style="text-align:center">某个分组出错或丢失仅重传该分组</td><td style="text-align:center">增加接收缓存（接收窗口），若收到的分组乱序则缓存该分组，等到按序后再一起提交整个缓存（因此接收缓存一般等于发送窗口大小）</td><td style="text-align:center">不同上</td><td style="text-align:center">序号个数/2</td></tr></tbody></table><h4 id="掌握TCP的首部字段"><a href="#掌握TCP的首部字段" class="headerlink" title="掌握TCP的首部字段"></a>掌握TCP的首部字段</h4><ul><li>源端口号、目的端口号：各占2字节，端口是传输层向应用层提供服务的接口</li><li>序号：占4字节，TCP连接下数据流中的每一个字节都编上一个号，序号字段的值指的是本报文段所发送的数据的第一个字节的编号</li><li>确认号：占4个字节，是期望收到对方的写一个报文段的第一个字节的序号（下一报文段序号字段），当有数据发送给对方时顺便确认，当没有数据发送给对方时单独发一确认报文</li><li>首部长度：占4位，表示TCP首部的字节数，该字段限制了TCP首部最大值为60字节</li><li>保留：占6位，保留为今后扩展使用，目前全部置为0</li><li>特殊标记：各占1位<ul><li>URG：紧急标志，值为1时有效，通知本报文段有紧急数据，应尽快传送</li><li>ACK：确认标记，值为1时有效，正常情况下只有第一次握手时为0</li><li>PSH：推送字段，值为1时，接收方在收到该报文段的数据就尽快将其交付给应用进程，而不再等到整个缓存填满</li><li>RST：复位标记，值为1时，表明TCP连接中出现严重差错（主机崩溃等），必须强行释放连接，属于单方面强行断开连接</li><li>SYN：同步标记，值为1时，表示是一个连接请求报文，正常情况下只有第一次握手和第二次握手时SYN=1，其余均=0</li><li>FIN：终止标记，值为1时，表示发送方的报文段数据已发送完毕，请求对方释放该连接，当接收方确认后，发送方将释放发送缓存</li></ul></li><li>窗口：占2字节，窗口字段是流量控制的关键，用来控制对方发送窗口的大小（单位为字节），接收方根据自身的窗口大小确定自己的接收窗口大小，然后通知发送方以确定对方窗口大小的上限</li><li>检验和：占2字节，检验范围包括首部和数据两个部分，在计算检验和时，要在报文段前加12个字节的伪首部</li><li>紧急指针</li><li>选项</li><li>填充</li></ul><h4 id="掌握TCP的序号和确认机制"><a href="#掌握TCP的序号和确认机制" class="headerlink" title="掌握TCP的序号和确认机制"></a>掌握TCP的序号和确认机制</h4><ul><li>序号：TCP首部的序号基于字节。建立连接之初，发送方随机生成初始序号，之后收发双方的每个字节都对应一个编号，而TCP首部中的序号是该报文段第一个字节的编号</li><li>确认：TCP首部的确认号是期望对方发送的下一个数据的第一个字节的编号，即对方下一个报文段的序号。如果某个报文段没有携带数据，对方不需要确认即对方确认号不变，但对于特殊报文，如SYN=1的报文（建立连接），FIN=0的报文（断开连接），对方必须做确认</li><li>TCP属于累积确认，乱序到达数据会缓存</li></ul><h4 id="掌握TCP三次握手和断开连接的详细过程"><a href="#掌握TCP三次握手和断开连接的详细过程" class="headerlink" title="掌握TCP三次握手和断开连接的详细过程"></a>掌握TCP三次握手和断开连接的详细过程</h4><ul><li>三次握手：<ul><li>A-&gt;B，第一次：A随机初始化自己的序号SN（A），确认号置0，初始化窗口大小，SYN=1请求建立连接</li><li>B-&gt;A，第二次：B随机初始化自己的序号SN（B），确认号为SN（A）+1，初始化窗口大小，ACK=1表示B对A的确认，SYN=1请求建立连接</li><li>A-&gt;B，第三次：确认号为SN（B）+1，ACK=1表示A对B的确认，SYN=0</li></ul></li><li>四次挥手：<ul><li>正常断开<ul><li>A-&gt;B，第一次：A：确认号为SN。（B）‘+1，ACK=1，FIN=1请求断开连接</li><li>B-&gt;A，第二次：B：确认号为SN（A）’+1，ACK=1</li><li>B-&gt;A，第三次：B：序号和序列号均与上一次相同，ACK=1，FIN=1请求断开连接</li><li>A-&gt;B，第四次：A：确认号为SN（B）‘+1，ACK=1</li></ul></li><li>异常断开<ul><li>A-&gt;B，第一次：A：确认号为SN。（B）’+1，ACK=1，RST=1请求异常中断</li><li>B-&gt;A，第二次：B：确认号为SN（A）‘+1，ACK=1</li></ul></li></ul></li></ul><h4 id="TCP的流量控制方法"><a href="#TCP的流量控制方法" class="headerlink" title="TCP的流量控制方法"></a>TCP的流量控制方法</h4><ul><li>首部定义了窗口大小：接收方明确通过首部窗口字段发送接收窗口大小，从而限制发送方发送窗口的最大值，而发送方保证发送窗口大小不超过对方发送的接收窗口的大小</li></ul><h4 id="掌握TCP的拥塞控制思想"><a href="#掌握TCP的拥塞控制思想" class="headerlink" title="掌握TCP的拥塞控制思想"></a>掌握TCP的拥塞控制思想</h4><ul><li>五个特征<ul><li>使用拥塞控制窗口cwnd控制发送窗口大小，发送窗口上限值=MIN（rwnd，cwnd）</li><li>分组超时则认为拥塞，反之收到确认则认为网络未拥塞</li><li>拥塞则少发（cwnd减少），未拥塞则多发（cwnd增大）</li><li>网络未知的情况下，cwnd从最小开始，收到确认后cwnd逐渐增大</li><li>为提高效率，开始增加速度快，到了一定阶段后增速变慢</li></ul></li><li>慢启动阶段：窗口初始值（假设为1）指数规律增长，至慢开始门限ssthrest（假设为16），当指数增长结果大于ssthrest时，增长至ssthrest</li><li>拥塞避免阶段：从ssthrest（16）起，以线性规律增长N，直至发生超时（重回慢启动）</li><li>重回慢启动：重回窗口初始值，慢开始门限ssthrest为N值减半（N/2）</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="网络层的作用"><a href="#网络层的作用" class="headerlink" title="网络层的作用"></a>网络层的作用</h4><ul><li>负责将各种不同的网络互联，负责将数据段封装成数据包，关注于分组从一个节点到另一个节点的选路</li></ul><h4 id="数据报网络与虚电路网络的特点与比较"><a href="#数据报网络与虚电路网络的特点与比较" class="headerlink" title="数据报网络与虚电路网络的特点与比较"></a>数据报网络与虚电路网络的特点与比较</h4><table><thead><tr><th></th><th>数据报网络（因特网模型）</th><th>虚电路网络</th></tr></thead><tbody><tr><td>是否先建立连接</td><td>在网络层无连接建立</td><td>发送分组前建立一条虚拟电路</td></tr><tr><td>选路</td><td>一般分组使用目标IP进行路由选择</td><td>每个分组携有标签，由标签决定下一跳</td></tr><tr><td></td><td>同一文件的不同分组可能走不同路径</td><td>在建立连接阶段确定固定路由，所有数据走同一路径</td></tr><tr><td>优点</td><td>灵活，适应性强，网络成本低</td><td>可靠，容易提供QoS，转发速度快</td></tr></tbody></table><h4 id="IP地址的发展"><a href="#IP地址的发展" class="headerlink" title="IP地址的发展"></a>IP地址的发展</h4><p>全分类IP地址-&gt;子网掩码-&gt;无类别域间路由</p><h4 id="全分类的IP地址"><a href="#全分类的IP地址" class="headerlink" title="全分类的IP地址"></a>全分类的IP地址</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">网络号位数</th><th style="text-align:center">主机号位数</th><th style="text-align:center">网络个数</th><th style="text-align:center">主机个数</th><th style="text-align:center">地址范围</th></tr></thead><tbody><tr><td style="text-align:center">A类</td><td style="text-align:center">8</td><td style="text-align:center">24</td><td style="text-align:center">2^7-1</td><td style="text-align:center">2^24-1</td><td style="text-align:center">1.0.0.0-126.255.255.255</td></tr><tr><td style="text-align:center">B类</td><td style="text-align:center">16</td><td style="text-align:center">16</td><td style="text-align:center">2^14</td><td style="text-align:center">2^16-1</td><td style="text-align:center">128.0.0.0-191.255.255.255</td></tr><tr><td style="text-align:center">C类</td><td style="text-align:center">32</td><td style="text-align:center">8</td><td style="text-align:center">2^21</td><td style="text-align:center">2^8-1</td><td style="text-align:center">192.0.0.0-223.255.255.255</td></tr><tr><td style="text-align:center">D类</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">224.0.0.0-239.255.255.255</td></tr></tbody></table><h4 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h4><ul><li>广播地址：主机号全1的地址</li><li>网络地址：主机号全0的地址</li><li>内网地址（私有地址）：10.0.0.0-10.255.255.255，172.16.0.0-172.31.255.255，192.168.0.0-192.168.255.255</li><li>链路本地地址：169.254.0.0-169.254.255.255（无IP地址时由操作系统临时分配的IP地址）</li><li>本地环回地址：127.0.0.0-127.255.255.255</li><li>本地链路广播地址：255.255.255.255</li></ul><h4 id="IP网络和物理网络的概念"><a href="#IP网络和物理网络的概念" class="headerlink" title="IP网络和物理网络的概念"></a>IP网络和物理网络的概念</h4><ul><li>IP网络：IP地址分为网络部分和主机部分，网络部分相同的地址属于同一个IP网络</li><li>物理网络：不经过路由器就可以直接到达的主机唯一同一个物理网络。位于同一物理网络的主机可以直接根据链路层的物理地址寻址</li><li>IP地址和物理网络的关系是多对一的，即多个IP网络可以用于同一物理网络，但同一个IP网络不可以用于多个物理网络。路由器用于转发不同IP网络的分组</li></ul><h4 id="定长掩码的划分和vlsm的划分"><a href="#定长掩码的划分和vlsm的划分" class="headerlink" title="定长掩码的划分和vlsm的划分"></a>定长掩码的划分和vlsm的划分</h4><ul><li>子网掩码的作用：划分子网，便于管理，提高IP地址利用率</li><li>定长掩码（FLSM）：一连串长度不变的数字，通过子网划分确定一个本地区域网路的边界<ul><li>确定子网数</li><li>确定每个子网的IP数</li><li>确定子网掩码</li><li>确定每个子网的IP</li></ul></li><li>由于子网定长，而子网内主机数较少，造成IP地址的浪费，当子网数过多或者单个子网内所需IP数过多时，甚至无法完成子网的划分</li><li>变长掩码（VLSM）：根据不同网段中不同的主机数使用不同长度的子网掩码，即可在某一子网（如/27）中进一步划分出若干个子网（如/30）来</li><li>注意：子网之间通信需要路由器，子网是主机号中划分的，若出现多条路由同时匹配时采用掩码最长前缀匹配原则选择路径</li></ul><h4 id="CIDR地址的表示和路由汇总"><a href="#CIDR地址的表示和路由汇总" class="headerlink" title="CIDR地址的表示和路由汇总"></a>CIDR地址的表示和路由汇总</h4><ul><li>CIDR（无类别域间选路）：取消IP地址的分类限制，以改善IP地址的分配方式，缓解IP地址的危机。CIDR利用层次网络和路由汇总减小路由器中路由表的规模，提高转发速度</li><li>CIDR地址的IP地址由前缀和掩码决定，如10.12.1.1/12其网络号为255.240.0.0，CIDR地址进行路由匹配时采用最长前缀匹配原则</li><li>路由汇总：将连续的多个网络地址汇总为一个网络地址，与层次物理网络结合，能极大的减少路由器上路由表的规模，将多个网络汇总成一个CIDR地址块，形成“超网”，属于不精确汇总（所有属于汇总后的地址块都属于汇总前的地址块称为精确汇总，否则称不精确汇总），不精确汇总可能导致错误的路由</li></ul><h4 id="掌握IP协议的首部"><a href="#掌握IP协议的首部" class="headerlink" title="掌握IP协议的首部"></a>掌握IP协议的首部</h4><ul><li>IP协议是无连接、不可靠的协议，包括IPv4和IPv6两个版本。IPv4包括20个字节的固定首部和长度可变的可选首部</li><li>版本：占4位，表示IP协议版本，IPv4版本值为4</li><li>首部长度：占4位，表示首部的单位长度（每单位4字节），故首部最大长度为60字节</li><li>总长度：占2字节，表示首部和数据的总长度（单位为字节），故数据报的最大分组长度为65535字节（含IP首部），最大数据长度为65515字节（假设首部20字节），但总长度不允许超过MTU（最大传送单元），否则将其分片</li><li>标识：占2字节，分组超过MTU时会进行分片，同一分组的不同分片标识相同</li><li>标志：占3位，包括DF、MF两个标志。DF=1表示该分组不允许分片，MF=1表示该分组后面还有分片</li><li>片偏移：占15位，指出该分片在原分组的位置，以8个字节为单位</li><li>生存时间：占1字节，TTL，表示数据报在网络中的寿命，其单位为秒（实际单位为跳），分组每经过一个路由器TTL就减一，当路由器收到TTL=0的分组时会将其丢弃，TTL能有效的避免该分组在网络上无限循环的转发</li><li>协议：占1字节，指出数据报携带的数据使用上层的何种协议，从而帮助目的主机的网络层将数据部分上交给哪个处理过程</li><li>首部校验和：占2字节，字段只检验数据报的首部，不包括数据部分</li><li>源地址、目的地址：各占4字节，表示发送接收方的IP地址，一般路由器不会改变分组的源IP地址和目的IP地址</li><li>可选字段</li><li>填充</li></ul><h4 id="ICMP的基本工作原理"><a href="#ICMP的基本工作原理" class="headerlink" title="ICMP的基本工作原理"></a>ICMP的基本工作原理</h4><ul><li>ICMP：Internet控制报文协议，用于因特网的传输控制和拆差错报告，主要用于分组传输过程中的异常报告，包括：<ul><li>目标地址不可达</li><li>网络拥塞</li><li>TTL到期</li><li>IP分组检验和失败</li></ul></li><li>注意：<ul><li>对出错的ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对某一分片后的分组，仅发送第一个分片的ICMP差错报告报文，后续分片不再发送</li><li>组播地址数据不发送ICMP差错报告报文</li><li>对特殊地址（如127.0.0.0或0.0.0.0）的数据不发送ICMP差错报告报文</li><li>ping使用了ICMP的回送请求与回送响应报文</li><li>tracert使用了ICMP的控制协议与TTL</li></ul></li></ul><h4 id="NAT的分类和作用"><a href="#NAT的分类和作用" class="headerlink" title="NAT的分类和作用"></a>NAT的分类和作用</h4><ul><li>NAT：网络地址转换，用于IP地址的转换</li></ul><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">定义</th><th style="text-align:center">缺点</th><th style="text-align:center">比较</th></tr></thead><tbody><tr><td style="text-align:center">静态NAT</td><td style="text-align:center">将内网数据报的源IP地址一对一的转换成外网的IP地址</td><td style="text-align:center">无法缓解IP地址危机</td><td style="text-align:center">静态NAT内网IP与外网IP是一一对应的，而动态NAT的地址转换是临时的</td></tr><tr><td style="text-align:center">动态NAT池</td><td style="text-align:center">将外网合法的IP地址形成可用的NAT池。内网IP需要上网时，从NAT中取一个可用的IP地址</td><td style="text-align:center">无法使内网IP同时上网</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">端口NAT（PAT）</td><td style="text-align:center">服务器根据TCP/UDP端口号映射</td><td style="text-align:center"></td></tr></tbody></table><p>  作用：</p><ul><li>解决多个用户使用一个公网IP上网的问题，缓解了IP地址危机</li><li>实现内部IP地址隐藏及服务器负载均衡</li></ul><h4 id="DHCP的基本工作原理"><a href="#DHCP的基本工作原理" class="headerlink" title="DHCP的基本工作原理"></a>DHCP的基本工作原理</h4><ul><li>DHCP：动态主机设置协议，采用C/S模式，使用UDP协议工作，服务器端口号为67，客户端端口号为68，用于主机自动获得IP地址、子网掩码、网关地址、DNS服务器地址、租用期的相关信息</li><li>工作过程<ul><li>服务器被动打开UDP端口67，等待客户端发来的报文</li><li>客户通过UDP端口68广播DHCP发现报文</li><li>服务器发送广播报文声明可以提供IP地址</li><li>客户广播请求IP地址</li><li>服务器广播发送IP地址、网关等，客户允许租用期内使用IP</li><li>租用期即将到期，发送续约请求。如果服务器同意则继续使用该IP，否则返回第2步重新申请</li></ul></li><li>DHCP中继代理：广播DCHPREQUEST请求，中继代理单播向其他网络的DHCP服务器，获取IP地址</li></ul><h4 id="路由的概念及分类"><a href="#路由的概念及分类" class="headerlink" title="路由的概念及分类"></a>路由的概念及分类</h4><ul><li>概念：根据目标网络选择最“好”路径</li><li>分类：从路由获取方式可分为：直连路由、静态路由、动态路由</li><li>从路由匹配数量可分为：目标路由、特定主机路由、默认路由</li></ul><h4 id="比较距离向量路由算法和链路状态路由算法"><a href="#比较距离向量路由算法和链路状态路由算法" class="headerlink" title="比较距离向量路由算法和链路状态路由算法"></a>比较距离向量路由算法和链路状态路由算法</h4><ul><li>距离向量路由算法和链路状态路由算法均属于动态路由协议（让路由器通过交换信息自动获得路由信息）</li></ul><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">原理</th><th style="text-align:center">特点</th><th style="text-align:center">范围</th><th style="text-align:center">收敛时间</th><th style="text-align:center">健壮性</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">距离向量算法（DV）</td><td style="text-align:center">（1）周期性向邻居通告自己的路由信息 （2）根据邻居通告使用加法更新自己的距离向量表 （3）路由表改变时，继续通告邻居 （4） 网络中所有路由表没有改变时，算法终止</td><td style="text-align:center">好消息传的快，坏消息传的慢（形成路由环路）</td><td style="text-align:center">邻居之间</td><td style="text-align:center">不稳定</td><td style="text-align:center">不好</td><td style="text-align:center">RIP、BGP</td></tr><tr><td style="text-align:center">链路状态路由算法（LS）</td><td style="text-align:center">（1）将自己的链路状态洪泛到网络上的所有路由器 （2）每个路由器最终会知道整个网络的拓扑结构 （3）使用Dijstra最短路径算法计算自己与其他路由器最短路径，更新路由表</td><td style="text-align:center">可能产生路由震荡</td><td style="text-align:center">整个网络</td><td style="text-align:center">稳定</td><td style="text-align:center">好</td><td style="text-align:center">OSPF</td></tr></tbody></table><h4 id="掌握rip的工作原理与配置方法"><a href="#掌握rip的工作原理与配置方法" class="headerlink" title="掌握rip的工作原理与配置方法"></a>掌握rip的工作原理与配置方法</h4><ul><li>RIP使用距离向量路由算法：<ul><li>使用UDP（端口520）进行传输，按固定的时间间隔交换路由信息（30s）</li><li>RIP将距离定义为“跳数”，每经过一个路由器跳数加1，规定最大值为15（16即相当于不可达）</li><li>使用毒性逆转（即向某条路由对应的出接口通告该路由为无穷大路由）等方法缓解环路影响</li></ul></li><li>RIP包括RIP1和RIP2：<ul><li>RIP1通过广播通告路由信息，不支持验证和CIDR</li><li>RIP2通过组播通告路由信息，支持验证和CIDR</li></ul></li></ul><h4 id="IGP和EGP"><a href="#IGP和EGP" class="headerlink" title="IGP和EGP"></a>IGP和EGP</h4><ul><li>为解决路由信息过多，更新缓慢的问题，使用自治系统（AS，由一个管理部门管理的具有相同路由策略的网络系统）管理网络系统。同一AS内的路由器使用相同的路由协议称IGP（内部网关协议），如RIP，OSPF；AS之间的路由器使用的路由协议称为EGP（外部网关协议），如BGP。网关路由器同时运行IGP和EGP</li></ul><h4 id="OSPF路由协议"><a href="#OSPF路由协议" class="headerlink" title="OSPF路由协议"></a>OSPF路由协议</h4><ul><li>使用链路状态路由算法，无路由自环，支持区域划分适用于大规模网络，支持CIDR、VLSM，支持验证，使用组播方式发送协议报文，基于IP，为停等协议，自身可实现可靠传输，收敛速度快，链路代价为10^8/网络带宽</li><li>OSPF使用路由器标识（32位无符号整数，整个自治系统唯一）唯一确定OSPF路由器</li><li>OSPF划分区域来减少洪泛范围，其中ABR负责区域之间的信息传递，它使用距离矢量算法</li><li>OSPF支持的网络拓扑结构：广播式多点接入网络、点到点网络、点到多点网络等</li><li>在全连通网络中，选取DR（村长）和BDR，DR负责通告路由</li></ul><h4 id="IPv6的基本概念"><a href="#IPv6的基本概念" class="headerlink" title="IPv6的基本概念"></a>IPv6的基本概念</h4><ul><li>版本：占4位，指明协议版本号</li><li>通信量类：占1字节，区分不同IPv6数据报或类别</li><li>流标号</li><li>有效载荷长度：占2字节，除首部外的数据长度（包括扩展首部），故最大长度为64KB</li><li>下一个首部：占1字节，相当于IPv4中的协议字段</li><li>跳数限制：占1字节，远端在数据发出时设置跳数限制，路由器每转发一次跳数减1，跳数为1时将被丢弃</li><li>源地址、目的地址：各占4字节</li></ul><h4 id="IPv6针对IPv4的改进"><a href="#IPv6针对IPv4的改进" class="headerlink" title="IPv6针对IPv4的改进"></a>IPv6针对IPv4的改进</h4><ul><li>增加IP地址范围</li><li>尽可能减少路由器的额外工作</li><li>提高路由器转发分组的速度</li><li>更好的实现路由汇总</li><li>更好实现QoS提高协议的灵活性，增加了移动性和安全性</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="比较数据链路层和传输层"><a href="#比较数据链路层和传输层" class="headerlink" title="比较数据链路层和传输层"></a>比较数据链路层和传输层</h4><ul><li>数据链路层：负责一段链路的两端之间的通信，由网卡负责数据链路层的协议</li></ul><table><thead><tr><th style="text-align:center">服务层</th><th style="text-align:center">通信</th><th style="text-align:center">范围</th><th style="text-align:center">服务对象</th></tr></thead><tbody><tr><td style="text-align:center">传输层</td><td style="text-align:center">收发双方主机到主机</td><td style="text-align:center">整个网络</td><td style="text-align:center">应用层，端口</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:center">一段链路端到端</td><td style="text-align:center">同一局域网内</td><td style="text-align:center">物理层、MAC地址</td></tr></tbody></table><h4 id="网卡的作用"><a href="#网卡的作用" class="headerlink" title="网卡的作用"></a>网卡的作用</h4><ul><li>数据的封装与解封：<ul><li>发送时将收到的上层分组加上首部和尾部形成以太网的帧并通过物理层发出</li><li>接收时则将收到的分组剥去首部和尾部形成分组并送交上层</li></ul></li><li>链路管理<ul><li>实现CSMA/CD：带冲突检测的载波监听多路访问</li><li>编码与译码：实现曼彻斯特编码与译码</li></ul></li></ul><h4 id="比较IP地址和MAC地址"><a href="#比较IP地址和MAC地址" class="headerlink" title="比较IP地址和MAC地址"></a>比较IP地址和MAC地址</h4><table><thead><tr><th style="text-align:center">地址类型</th><th style="text-align:center">定义</th><th style="text-align:center">目的</th><th style="text-align:center">长度</th><th style="text-align:center">范围</th><th style="text-align:center">所在TCP层</th><th style="text-align:center">获取对方地址方式</th></tr></thead><tbody><tr><td style="text-align:center">IP地址</td><td style="text-align:center">因特网上不同网络间能够通信的唯一地址</td><td style="text-align:center">不同网段间的通信</td><td style="text-align:center">IPv4：32位，IPv6：128位</td><td style="text-align:center">广域网</td><td style="text-align:center">网络层</td><td style="text-align:center">DNS</td></tr><tr><td style="text-align:center">MAC地址</td><td style="text-align:center">局域网中固化在硬件上的地址</td><td style="text-align:center">同一网段内结点间通信</td><td style="text-align:center">48位</td><td style="text-align:center">局域网</td><td style="text-align:center">数据链路层</td><td style="text-align:center">ARP</td></tr></tbody></table><h4 id="CRC冗余检验的计算方法以及奇偶校验"><a href="#CRC冗余检验的计算方法以及奇偶校验" class="headerlink" title="CRC冗余检验的计算方法以及奇偶校验"></a>CRC冗余检验的计算方法以及奇偶校验</h4><ul><li>CRC冗余检验：<ul><li>待校验数据除以一个约定好的除数，若能除尽则校验正确，否则出错</li><li>差错率高，能纠错</li></ul></li><li>具体做法：<ul><li>数据比特流看出二进制数据作为被除数D</li><li>选择一个n位的二进制数作为除数G</li><li>发送方采用异或方式D除以G得到余数R，即为CRC冗余校验码</li></ul></li><li>奇偶校验：通过在数据后添加1位，保证新的数据中1有奇数个<ul><li>一维奇偶校验能查错</li><li>二维奇偶校验能纠错（1位）</li></ul></li></ul><h4 id="FDMA、TDMA、CDMA"><a href="#FDMA、TDMA、CDMA" class="headerlink" title="FDMA、TDMA、CDMA"></a>FDMA、TDMA、CDMA</h4><ul><li>均属于信道分割技术</li><li>FDMA：频分复用<ul><li>信道按频率分割成若干频段，每个站点分得固定的频段，该站点不用时相应频段被闲置浪费</li></ul></li><li>TDMA：时分复用<ul><li>信道根据时间分成多个固定长度的时间片，每个用户允许在不同的时间片上传输信息，某个时间片上无用户传送信息则导致信道浪费</li></ul></li><li>CDMA：码分复用<ul><li>大部分用于无线通信场合，用户共享相同频道，每个用户用自己的码片序列对数据编码，允许多用户共存和发送信号，对相互的干扰极小</li></ul></li></ul><h4 id="CSMA-CD的工作原理"><a href="#CSMA-CD的工作原理" class="headerlink" title="CSMA/CD的工作原理"></a>CSMA/CD的工作原理</h4><ul><li>CSMA/CD，带冲突检测的载波监听多路访问，核心思想包括：<ul><li>先听后讲：信道空闲则讲，否则等待</li><li>边听边讲：发送信号时不断检测是否碰撞</li><li>碰撞即停</li><li>退避重传：二进制指数退避算法重传</li><li>多次碰撞，放弃发送：最多16次</li></ul></li><li>二进制退避算法：<ul><li>确定基本退避时间，一般为争用期2τ（端到端的往返时延）</li><li>定义重传次数k（k&lt;=10）</li><li>从整数集合{0,1，……，2^k-1}中随机取一数记为r，则重传退避时延为r*2τ</li><li>重传16次仍不成功则丢弃该帧，并向高层报告</li></ul></li></ul><h4 id="ARP的工作原理"><a href="#ARP的工作原理" class="headerlink" title="ARP的工作原理"></a>ARP的工作原理</h4><ul><li>ARP：通过IP地址获得MAC地址</li><li>工作原理：<ul><li>发送方A向接收方B发送数据前，查看本地的ARP缓存表，若没有则广播发送ARP请求包</li><li>局域网内主机和网关均将A的MAC地址记入ARP缓存表，但不响应</li><li>接收方若在局域网内，B收到广播请求后向A单播发送响应ARP报文</li><li>接收方若不在局域网内，则向网关获取B的MAC地址，网关ARP缓存表中有则直接回复响应，没有则继续发送ARP请求报文</li></ul></li></ul><h4 id="最短帧长的作用和计算方法"><a href="#最短帧长的作用和计算方法" class="headerlink" title="最短帧长的作用和计算方法"></a>最短帧长的作用和计算方法</h4><ul><li>传统的以太网的最短帧长为64字节，从而确保碰撞帧的检测，小于64字节的帧被认为是碰撞帧，因此实际发送数据小于64字节时会被自动填充</li></ul><h4 id="碰撞域和广播域的判断"><a href="#碰撞域和广播域的判断" class="headerlink" title="碰撞域和广播域的判断"></a>碰撞域和广播域的判断</h4><ul><li>一个CSMA/CD网络即是一个碰撞域，基于物理层。网络设备中中继器（Repeater）和集线器（Hub）不能隔离碰撞域，网桥、二层交换机、路由器和三层交换机可以隔离碰撞域</li><li>广播域是指网段上收听送往所在网段的所有广播的所有设备的集合，基于数据链路层。只有路由器和三层交换机可以隔离广播域</li><li>交换机上有多少个端口连到了网络，就有多少个碰撞域；路由器上有多少个端口连到了网络，就有多少个广播域</li></ul><h4 id="MAC地址的基本特点"><a href="#MAC地址的基本特点" class="headerlink" title="MAC地址的基本特点"></a>MAC地址的基本特点</h4><ul><li>单播MAC地址：固化在网卡上<ul><li>十六进制表示：AC-DE-48-D0-00-80</li><li>二进制表示：第八位必须为0</li></ul></li><li>广播MAC地址：FF-FF-FF-FF-FF-FF</li><li>组播MAC地址：组播MAC地址通过组播IP地址后23位映射而成</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;计算机网络相关知识的复习整理~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;h4 id=&quot;单工、半双工、双工、串行和并行
      
    
    </summary>
    
    
      <category term="Courses" scheme="https://jeremygo.cn/tags/Courses/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习</title>
    <link href="https://jeremygo.cn/2018/06/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <id>https://jeremygo.cn/2018/06/24/操作系统复习/</id>
    <published>2018-06-24T01:10:05.000Z</published>
    <updated>2018-06-27T13:32:59.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大二下即将结束，这里将操作系统的重点概念整理一下方便复习~</p></blockquote><h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><h4 id="何谓多道程序设计？叙述它的主要特征和优点"><a href="#何谓多道程序设计？叙述它的主要特征和优点" class="headerlink" title="何谓多道程序设计？叙述它的主要特征和优点"></a>何谓多道程序设计？叙述它的主要特征和优点</h4><ul><li>多道程序设计是一种软件技术。该技术使同时进入计算机主存的几个相互独立的程序在管理程序控制之下相互交替执行。当某道程序因某种原因不能继续运行下去时，管理程序便将另一道程序投入运行。这样可以使中央处理器及各外部设备尽量处于忙碌状态，从而大大提高计算机的使用效率</li><li>单处理器系统中，多道程序运行特征：<ul><li>多道：即计算机主存中同时存放几道相互独立的程序</li><li>宏观上并行：同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行但都未运行完毕</li><li>微观上串行：微观上主存中多道程序轮流或分时地占用处理器，即多道程序交替执行</li></ul></li><li>多道程序设计的优点：<ul><li>可提高CPU的利用率</li><li>可提高主存和I/O设备利用率</li><li>可增加系统吞吐量</li></ul></li></ul><h4 id="操作系统具有哪几大特征？"><a href="#操作系统具有哪几大特征？" class="headerlink" title="操作系统具有哪几大特征？"></a>操作系统具有哪几大特征？</h4><ul><li>不同的操作系统都具有四个基本特征：<ul><li>并发：并发性是指两个或多个事件在同一时间间隔内发生。多道程序环境下，并发性指宏观上一段时间内多道程序在同时运行；单处理器系统中，每一时刻只能执行一道程序即微观上交替执行</li><li>共享：共享是指系统中的资源可供主存中多个并发执行的进程共同使用</li><li>虚拟：指通过某种技术把一个物理实体变成若干个逻辑上的对应物</li><li>异步性：多道程序环境下允许多个进程并发执行，但由于资源等因素限制，进程是以异步方式允许的。只要运行环境相同，作业经多次运行都会获得完全相同的结果，因此异步运行是允许的</li></ul></li></ul><h4 id="在交互性、及时性和可靠性方面比较分时系统与实时系统"><a href="#在交互性、及时性和可靠性方面比较分时系统与实时系统" class="headerlink" title="在交互性、及时性和可靠性方面比较分时系统与实时系统"></a>在交互性、及时性和可靠性方面比较分时系统与实时系统</h4><ul><li>交互性：分时系统交互性强，实时系统交互性弱。因为交互性强不能满足实时系统响应速度快和高可靠性的要求</li><li>及时性：实时系统要求快速响应而及时性强，分时系统相比较弱</li><li>可靠性：实时系统要求高可靠性而可靠性强，分时系统相比较弱</li></ul><h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><h4 id="何谓进程？它有哪些基本状态？列举使进程状态发生变化的事件"><a href="#何谓进程？它有哪些基本状态？列举使进程状态发生变化的事件" class="headerlink" title="何谓进程？它有哪些基本状态？列举使进程状态发生变化的事件"></a>何谓进程？它有哪些基本状态？列举使进程状态发生变化的事件</h4><ul><li>进程是可并发执行的程序在一个数据集上的一次执行过程，是系统进行资源分配的基本单位</li><li>进程有就绪、执行、等待三个基本状态</li><li>状态变化事件<ul><li>就绪 -&gt; 执行：进程调度程序分配CPU</li><li>执行 -&gt; 等待：正在执行的进程因访问I/O设备而无法继续执行时</li><li>等待 -&gt; 就绪：因访问I/O设备正在等待的进程在访问I/O设备结束后<ul><li>执行 -&gt; 就绪：正在执行的进程如因时间片用完而被暂停执行时  吧  </li></ul></li></ul></li></ul><h4 id="比较进程和程序的区别"><a href="#比较进程和程序的区别" class="headerlink" title="比较进程和程序的区别"></a>比较进程和程序的区别</h4><ul><li>程序是指令的有序集合，是一个在时间上按严格次序前后相继的操作序列，是一个静态的概念</li><li>进程是可并发执行的程序在一个数据集上的一次执行过程，是系统进行资源分配的基本单位，它具有以下五个基本特征：<ul><li>动态性：进程最基本的特性，表现为：“它由创建而产生，由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡”</li><li>并发性：多个进程实体同存于主存中，能在一段时间内同时运行；它是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的正是为了使程序能和其它进程的程序并发执行，而程序不能并发执行</li><li>独立性：进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。未建立进程的程序都不能作为一个独立的单位参加运行。进程与程序并非是一一对应的，一个程序运行在不同的数据集上就构成不同的进程</li><li>异步性：进程按各自独立的、不可预知的速度向前推进即进程按异步方式运行。这一特征导致程序执行的不可再现性，因此在操作系统中必须采取某种措施来保证各程序之间能协调运行</li><li>结构特征：进程实体在结构上由程序段、数据段、及进程控制块三部分组成，有人统称这三部分为“进程映像”</li></ul></li></ul><h4 id="进程调度的功能有哪些？"><a href="#进程调度的功能有哪些？" class="headerlink" title="进程调度的功能有哪些？"></a>进程调度的功能有哪些？</h4><ul><li>记录系统中所有进程的执行情况</li><li>选择占有处理器的进程</li><li>把处理器分配给进程，即进行进程上下文切换</li><li>收回处理器</li></ul><h4 id="进程调度的时机有哪几种？"><a href="#进程调度的时机有哪几种？" class="headerlink" title="进程调度的时机有哪几种？"></a>进程调度的时机有哪几种？</h4><ul><li>正在执行的进程执行完毕</li><li>执行中的进程自己调用阻塞原语将自己阻塞起来进入等待状态</li><li>执行中的进程调用了P原语操作从而因资源不足而被阻塞或调用了V原语操作激活了等待资源的进程队列</li><li>执行中的进程提出I/O请求后被阻塞</li><li>在分时系统中时间片已经用完</li><li>在执行完系统调用等系统程序后返回用户进程即系统进程执行完毕时</li><li>在可剥夺CPU执行方式时就绪队列中某进程优先级高于当前执行进程的优先级</li></ul><h4 id="在信号量s上作PV操作时，s-gt-0、s-0、s-lt-0时的物理意义是什么？"><a href="#在信号量s上作PV操作时，s-gt-0、s-0、s-lt-0时的物理意义是什么？" class="headerlink" title="在信号量s上作PV操作时，s&gt;0、s=0、s&lt;0时的物理意义是什么？"></a>在信号量s上作PV操作时，s&gt;0、s=0、s&lt;0时的物理意义是什么？</h4><ul><li>s &gt; 0：还有s个可用资源</li><li>s = 0：已无可用资源</li><li>s &lt; 0：已无可用资源并且还有|s|个进程在等待使用资源</li></ul><h4 id="若系统有同类资源m个，被n个进程共享，问：m-gt-n-和-m-lt-n-时每个进程最多可以请求多少个这类资源使系统一定不会发生死锁？"><a href="#若系统有同类资源m个，被n个进程共享，问：m-gt-n-和-m-lt-n-时每个进程最多可以请求多少个这类资源使系统一定不会发生死锁？" class="headerlink" title="若系统有同类资源m个，被n个进程共享，问：m &gt; n 和 m &lt;= n 时每个进程最多可以请求多少个这类资源使系统一定不会发生死锁？"></a>若系统有同类资源m个，被n个进程共享，问：m &gt; n 和 m &lt;= n 时每个进程最多可以请求多少个这类资源使系统一定不会发生死锁？</h4><ul><li>m &gt; n：m / n （向上取整）</li><li>m &lt;= n：1</li></ul><h4 id="何谓死锁？产生死锁的原因和必要条件是什么？"><a href="#何谓死锁？产生死锁的原因和必要条件是什么？" class="headerlink" title="何谓死锁？产生死锁的原因和必要条件是什么？"></a>何谓死锁？产生死锁的原因和必要条件是什么？</h4><ul><li>在系统中存在一组进程（两个以上），每一个进程都占用了某种资源而又都在永久等待其中另一进程所占用的进程所占用的资源</li><li>产生原因：<ul><li>竞争资源：系统中供多个进程所共享的资源不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁</li><li>进程推进顺序非法：进程在运行过程中，请求和释放资源的顺序不当导致进程死锁</li></ul></li><li>四个必要条件：<ul><li>互斥条件：进程应互斥使用资源，任意时刻一个资源仅为一个进程独占，若另一个进程请求一个已被占用的资源时，它被置为等待状态直到占用者释放资源</li><li>占有且等待条件：一个进程请求资源得不到满足而等待时，不释放已占有的资源</li><li>不剥夺条件：任一进程不能从另一进程那抢夺资源，即已被占用的资源只能由占用进程自己来释放</li><li>循环等待条件：存在一个循环等待链，每一个进程分别等待另一个进程所持有的资源，造成永久等待</li></ul></li></ul><h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><h4 id="解释作业和作业步"><a href="#解释作业和作业步" class="headerlink" title="解释作业和作业步"></a>解释作业和作业步</h4><ul><li>把用户在一次解题过程中要求计算机所做工作的集合称为一个作业</li><li>任何一个作业都要经过若干加工步骤才能得到结果，每一个加工步骤称为一个“作业步”</li></ul><h4 id="作业的状态分成哪几种？各种状态之间是如何转换的"><a href="#作业的状态分成哪几种？各种状态之间是如何转换的" class="headerlink" title="作业的状态分成哪几种？各种状态之间是如何转换的"></a>作业的状态分成哪几种？各种状态之间是如何转换的</h4><ul><li>通常作业分成四种状态：<ul><li>提交状态：一个作业在用户手中经过输入设备进入到外存输入井，系统为其建立作业控制块</li><li>后备状态：对于已进入输入井的作业，系统将它插入到输入井后备队列中，等待作业调度程序的调度运行</li><li>运行状态：一个处于后备状态的作业，一旦被作业调度程序选中装入主存，系统就为它分配必要的软硬件资源并建立相应的进程插入到进程就绪队列中</li><li>完成状态：作业完成其全部运行过程并释放其所占全部资源而正常结束或异常终止时</li></ul></li></ul><h4 id="叙述作业、进程和程序三者的关系"><a href="#叙述作业、进程和程序三者的关系" class="headerlink" title="叙述作业、进程和程序三者的关系"></a>叙述作业、进程和程序三者的关系</h4><ul><li>执行作业调度之前的作业是静态的，基本以文件形式存储在外部存储介质中</li><li>当作业经过作业调度的高级阶段调度后，其状态即从静态转变为动态执行状态，并为此创建了相应的作业进程，进程在经过若干次状态变更后即可完成作业功能并结束运行撤销</li><li>程序作为作业的主体部分，也是以文件形式存储在外部存储介质当中</li></ul><h4 id="作业调度的性能指标"><a href="#作业调度的性能指标" class="headerlink" title="作业调度的性能指标"></a>作业调度的性能指标</h4><ul><li>CPU利用率：CPU有效运行时间与总运行时间之比</li><li>吞吐能力：单位时间内完成作业数量</li><li>周转时间：从作业被提交进入输入井开始到作业执行完成的这段时间间隔</li><li>平均周转时间：所有作业周转时间的平均值</li><li>平均带权周转时间：带权周转时间即作业的周转时间与作业的运行时间之比</li></ul><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><h4 id="分页式存储管理和分段式存储管理有何区别？"><a href="#分页式存储管理和分段式存储管理有何区别？" class="headerlink" title="分页式存储管理和分段式存储管理有何区别？"></a>分页式存储管理和分段式存储管理有何区别？</h4><ul><li>分页和分段都采用离散分配主存方式，需要通过地址映射机构来实现地址变换</li><li>区别：<ul><li>页是信息的物理单位，是系统管理的需要而不是用户的需要；而段则是信息的逻辑单位，含有一组意义相对完整的信息，分段是为了更好地满足用户的需要</li><li>页的大小固定且由系统决定，即一个系统只能有一种大小的页面；而段的长度却不固定，由用户所编写的程序决定，通常由编译程序对源程序进行编译时根据信息的性质来划分</li><li>分页式作业的地址空间是一维的，页间的逻辑地址是连续的；而分段式作业的地址空间则是二维的，段间的逻辑地址是不连续的</li></ul></li></ul><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><h4 id="简述采用通道技术时，I-O操作的全过程"><a href="#简述采用通道技术时，I-O操作的全过程" class="headerlink" title="简述采用通道技术时，I/O操作的全过程"></a>简述采用通道技术时，I/O操作的全过程</h4><ul><li>采用通道技术当进程提出I/O请求后：<ul><li>系统首先分配通道和外设</li><li>然后按照I/O请求编制通道程序并存入主存，将其起始地址送入通道地址寄存器（CAW）</li><li>然后CPU发出“启动I/O”指令启动通道工作</li><li>启动成功后通道逐条执行通道程序中的通道指令，控制设备实现I/O操作</li></ul></li></ul><h4 id="叙述引入缓冲的主要原因，其实现的基本思想是什么？"><a href="#叙述引入缓冲的主要原因，其实现的基本思想是什么？" class="headerlink" title="叙述引入缓冲的主要原因，其实现的基本思想是什么？"></a>叙述引入缓冲的主要原因，其实现的基本思想是什么？</h4><ul><li>主要原因：<ul><li>缓和CPU与I/O设备间速度不匹配的矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li><li>提高CPU和I/O设备之间的并行性</li></ul></li><li>实现方法：<ul><li>采用专用硬件缓冲器</li><li>划分具有n个单元的主存缓冲区</li></ul></li></ul><h4 id="何谓虚拟设备？简述虚拟设备的设计思想"><a href="#何谓虚拟设备？简述虚拟设备的设计思想" class="headerlink" title="何谓虚拟设备？简述虚拟设备的设计思想"></a>何谓虚拟设备？简述虚拟设备的设计思想</h4><ul><li>虚拟设备是指采用相应的技术和方法将独占型设备变换为若干台对应的逻辑设备</li><li>其设计思想是将独占型设备改造为共享型设备。宏观上虽然十多个进程在同时使用一台独占型设备，但为每一个进程而言，它们都认为自己独占了一个设备</li></ul><h4 id="SPOOLing系统由哪些部分组成？简述它们的功能"><a href="#SPOOLing系统由哪些部分组成？简述它们的功能" class="headerlink" title="SPOOLing系统由哪些部分组成？简述它们的功能"></a>SPOOLing系统由哪些部分组成？简述它们的功能</h4><ul><li>预输入程序：把一批作业组织在一起形成作业流，由预输入程序把作业流中每个作业的初始信息由输入设备输入到输入井保存，并填写好输入表以便在作业执行中要求输入信息时可以随时找到它们的存放位置以备作业调度</li><li>井管理程序<ul><li>井管理读程序：当作业请求从输入机上读文件信息时就把任务转交给井管理读程序，从输入井读出信息供用户使用</li><li>井管理写程序：当作业请求从打印机上输出结果时就把任务转交给井管理写程序，把产生的结果保存到输出井中</li></ul></li><li>缓输出程序：缓输出程序负责查看输出井中是否有等待输出的结果信息，如果有则启动打印机把作业的结果文件打印输出，当一个作业的文件信息输出完毕后，将它占用的井区回收以供其它作业使用</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="文件系统应具有哪些功能？"><a href="#文件系统应具有哪些功能？" class="headerlink" title="文件系统应具有哪些功能？"></a>文件系统应具有哪些功能？</h4><ul><li>目录管理</li><li>文件的组织</li><li>文件存储空间的管理</li><li>文件操作</li><li>文件的共享、保护和保密</li></ul><h4 id="简述文件的结构和组织方式"><a href="#简述文件的结构和组织方式" class="headerlink" title="简述文件的结构和组织方式"></a>简述文件的结构和组织方式</h4><ul><li>逻辑结构：用户所观察到的文件组织形式，是用户可以直接处理的数据及结构，独立于物理特性构造而成。由用户构造的文件称文件的逻辑结构<ul><li>无结构的流式文件</li><li>有结构的记录式文件</li></ul></li><li>物理结构：文件在辅存上的存储组织形式，与存储介质的存储性能有关<ul><li>顺序结构</li><li>链接结构</li><li>索引结构</li></ul></li></ul><h4 id="文件的存取方式"><a href="#文件的存取方式" class="headerlink" title="文件的存取方式"></a>文件的存取方式</h4><ul><li>顺序存取：严格按照文件中的逻辑信息单位排列的逻辑地址顺序依次读取</li><li>随机存取：按任意次序随机读写文件中的信息</li><li>按键存取：用于复杂文件系统、特别是数据库管理系统中的存取方法</li></ul><h4 id="链接法共享文件主要采取哪几种实现技术？比较每种实现技术的特点"><a href="#链接法共享文件主要采取哪几种实现技术？比较每种实现技术的特点" class="headerlink" title="链接法共享文件主要采取哪几种实现技术？比较每种实现技术的特点"></a>链接法共享文件主要采取哪几种实现技术？比较每种实现技术的特点</h4><ul><li>目录链接技术：将共享文件的存储地址、长度等文件信息记录在文件目录项中，但链接后的目录结构变成了网状结构，使管理更复杂同时会导致删除异常和更新异常</li><li>基于索引结点的链接技术：将共享文件的存储地址、长度等文件信息记录在索引结点中，大大减少了删除异常和更新异常，但也会导致指针悬空及共享文件所有者为等待其他用户完成而付出高昂的代价</li><li>符号链接技术：通过调用系统过程“link”来创建一个LINK型新文件登记被链接的文件的路径名，优点主要体现在避免了指针悬空和实现网络环境下任意文件的共享两方面</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;大二下即将结束，这里将操作系统的重点概念整理一下方便复习~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引论&quot;&gt;&lt;a href=&quot;#引论&quot; class=&quot;headerlink&quot; title=&quot;引论&quot;&gt;&lt;/a&gt;引论&lt;/h3&gt;&lt;h4 id=&quot;何
      
    
    </summary>
    
    
      <category term="Courses" scheme="https://jeremygo.cn/tags/Courses/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Nginx</title>
    <link href="https://jeremygo.cn/2018/05/29/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANginx/"/>
    <id>https://jeremygo.cn/2018/05/29/深入浅出Nginx/</id>
    <published>2018-05-29T11:31:26.000Z</published>
    <updated>2018-05-29T15:46:46.384Z</updated>
    
    <content type="html"><![CDATA[<p>之前在自己的阿里云服务器上部署了Nginx服务主要用作node服务的代理，这里看到一篇不错的文章简记一下~</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Nginx是一款轻量级的Web服务器及反向代理服务器，因为内存中占用少、启动极快、高并发能力强的原因，在互联网项目中广泛应用<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1frsgjbi5aej20j40e2aax.jpg" alt=""></p><blockquote><p>当下流行的技术架构，nginx有点像入口网关</p></blockquote><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><ul><li>平时我们使用梯子访问谷歌就是一个简单的正向代理的例子，正向代理“代理”的是客户端，客户端是知道目标的，但是目标不知道客户端是通过梯子访问的</li></ul><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ul><li>我们在外网访问百度时会进行一个转发代理到内网既是反向代理，反向代理“代理”的是服务器端，这一个过程对于客户端是透明的</li></ul><h3 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h3><p>启动Nginx后，就是在80端口启动了Socket服务进行监听，Nginx涉及Mater进程和Worker进程<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1frsg790v3mj20m503uaad.jpg" alt=""></p><h4 id="Mater进程作用"><a href="#Mater进程作用" class="headerlink" title="Mater进程作用"></a>Mater进程作用</h4><ul><li>读取并验证配置文件nginx.conf，管理worker进程</li></ul><h4 id="Worker进程作用"><a href="#Worker进程作用" class="headerlink" title="Worker进程作用"></a>Worker进程作用</h4><ul><li>Worker进程作用：每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数有关（有利于进程切换）</li></ul><h4 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h4><ul><li>热部署：配置文件nginx.conf修改以后不需要stop nginx中断请求，就能让配置文件生效<br>结合worker进程负责处理具体的请求：<ul><li>方案一：修改nginx.conf后，主进程master负责推送给worker进程更新配置信息，worker进程收到信息后更新进程内部的线程信息</li><li>方案二：修改nginx.conf后，重新生成新的worker进程，以新的配置进行处理请求，老的woker进程等它们的请求处理完毕后kill掉即可<br>nginx采用方案二实现热部署</li></ul></li></ul><h4 id="如何做到高并发下的高效处理"><a href="#如何做到高并发下的高效处理" class="headerlink" title="如何做到高并发下的高效处理"></a>如何做到高并发下的高效处理</h4><ul><li>上文已经提及nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，的确有助于效率但是不够。同时处理那么多请求的问题在于，有的请求需要发生IO，可能需要很长时间，如果等着它们，就会拖慢worker的处理速度<ul><li>nginx采用了Linux的epoll模型，这个模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。所以worker只需要从epoll队列循环处理即可</li></ul></li><li>nginx挂了怎么办：nginx作为入口网关，如果出现单点问题显然是不可接受的<ul><li>解决方案：Keepalived + Nginx</li><li>keepalived 是一个高可用解决方案，主要用来防止服务器单点发生故障，可以通过和nginx配合来实现Web服务的高可用</li><li>思路：<ul><li>请求不要直接打到nginx上，应该先通过Keepalived (虚拟IP)</li><li>Keepalived 应该能监控nginx的生命状态（提供一个用户自定义的脚本，定期检查nginx进程状态，进行权重变化，从而实现nginx故障切换）<br><img src="https://ws1.sinaimg.cn/large/e4336439gy1frsgov5bh3j20jg07tdgl.jpg" alt=""></li></ul></li></ul></li></ul><h3 id="主战场：nginx-conf"><a href="#主战场：nginx-conf" class="headerlink" title="主战场：nginx.conf"></a>主战场：nginx.conf</h3><p>nginx.conf是典型的分段配置文件</p><h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><ul><li><img src="https://ws1.sinaimg.cn/large/e4336439gy1frsgrqy6tsj20ia080t8w.jpg" alt=""></li><li>把nginx作为web server来处理静态资源<ul><li>location可以进行正则匹配，注意正则的几种形式以及优先级</li><li>nginx能提高速度的其中一个特性：动静分离，把静态资源放到nginx上，由nginx管理，动态请求转发给后端</li><li>在nginx下将静态资源、日志文件归属到不同域名（目录）下，方便管理维护</li><li>nginx可以进行ip访问控制，如有些电商平台，在nginx这一层就做了处理，内置一个黑名单模块<h4 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h4></li></ul></li><li>在location这一段配置中的root替换成proxy_pass即可<ul><li>root说明是静态资源，可以由nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，如代理到Tomcat上</li><li>反向代理过程是透明的，比如在request-&gt;nginx-&gt;Tomcat这里对于Tomcat而言请求的ip就是nginx的地址而不是真实的request地址。好在nginx不仅仅可以反向代理请求，也可以由用户自定义设置HTTP HEADER<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4></li></ul></li><li>在反向代理中，通过proxy_pass来指定Tomcat的地址，这里只能指定一台Tomcat，如果想指定多台来达到负载均衡呢？<ul><li>通过 upstream 来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（nginx监控这一组Tomcat的状态）等</li><li>将proxy_pass换成upstream指定的值即可</li></ul></li><li>带来的问题：用户状态的保存问题，如session信息不能保存到服务器上</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>在配置上开启，同时指定目录，让缓存可以存储到磁盘上</li></ul><p>参考：<br><a href="http://blog.51cto.com/zhangfengzhe/2064524" target="_blank" rel="noopener">http://blog.51cto.com/zhangfengzhe/2064524</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在自己的阿里云服务器上部署了Nginx服务主要用作node服务的代理，这里看到一篇不错的文章简记一下~&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Nginx是一款轻
      
    
    </summary>
    
    
  </entry>
  
</feed>

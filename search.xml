<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web性能优化]]></title>
    <url>%2F2017%2F12%2F02%2FWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在书上看到了关于Web性能优化方面的知识，这里先记录下来，方便以后加以实践~ Web性能优化分为服务器端和浏览器端两个方面： 压缩源码和图片► JavaScript文件源代码可以采用混淆压缩的方式► CSS文件源码可以进行普通压缩► JPG图片可以根据具体质量来压缩为50%-70%► PNG可以使用一些开源压缩软件来压缩，比如24色变成8色、去掉一些PNG格式信息等 选择合适的图片格式► 如果图片颜色数较多就使用JPG格式► 如果图片颜色数较少就使用PNG格式► 如果能够通过服务器端判断浏览器支持WebP，就使用WebP格式和SVG格式 合并静态资源► 包括CSS、JavaScript和小图片，减少HTTP请求 开启服务器端的Gzip压缩► 对于文本资源非常有效，对图片资源则没那么大的压缩比率 使用CDN► 或者一些公开库使用第三方提供的静态资源地址（比如jQuery、normalize、css）。一方面增加并发下载量，另一方面能够和其他网站共享缓存 延长静态资源缓存时间► 这样频繁访问网站的访客就可以更快地访问。但是这里要通过修改文件名的方式，确保资源更新的时候，用户会拉取到最新的内容 把CSS放在页面头部，JavaScript放在页面底部► 这样就不会阻塞页面渲染，让页面出现长时间的空白]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作]]></title>
    <url>%2F2017%2F11%2F30%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[随着做项目的深入，对Git的使用也越来越频繁，这里就做一个常用操作的总结，不断更新~ Git理念► 工作区（即本地文件）► 暂存区► 本地仓库► 远程仓库 使用Git项目的文件都是在上面四个地方传递 本地项目关联远程仓库远程库建好以后就可以运行这条命令关联到本地项目：git remote add origin your-remote-repository-url 如果是直接克隆远程仓库到本地的话：git clone your-remote-repository-url 可以运行以下命令查看结果： git remote -v 查看当前项目的远程库git branch -a 查看当前项目的所有分支 远程库同步到本地► 在提交更新以前都要先同步一下本地仓库1git pull 等同于 git fetch + git merge 如果需要放弃本地修改，强制覆盖本地版本的话（即保持与远程库一致）：123git fetch --allgit reset --hard origin/mastergit pull 提交本地更新到远程库git status 检查当前项目状态 然后对于未跟踪的文件执行以下命令： 123git add untrack-file-path 跟踪单个本地文件，提交到暂存区git commit -m &quot;your commit&quot; 将跟踪过的文件即在暂存区的文件提交到本地仓库git push 将本地仓库提交到远程库 提交到远程库常用的命令还有： git add . 跟踪本地所有未跟踪的文件git push -f 强制提交更新，覆盖远程库 — 慎用！！！ 版本回退► 将当前版本回退到已提交的版本历史中git reset --hard HEAD^ 一个^号代表回退一个版本 更多时候我们都会找到对应的版本号进行回退：首先 git log 显示最近到最远的提交日志如果只想显示版本号和评论信息的话可以加上 --pretty=oneline 参数现在就可以 git reset --hard version number 回退到对应的版本 这里还有一个常用命令：git reflog 显示你的每一次命令，对于自己命令的整理很有帮助 检查修改► 已修改，未暂存git diff ► 已暂存，未提交git diff --cached ► 已提交，未推送git diff master origin/master 撤销修改► 已修改，未暂存git checkout -- file-path ► 已暂存，未提交git reset HEAD file-path 先撤销暂存区的修改git checkout -- file-path 再撤销工作区的修改 PS: 以上两个步骤都可以用 git reset --hard 完成，一步到位将修改完全恢复到未修改的状态 ► 已提交，未推送git reset --hard origin/master 从远程库将代码取回 ► 已推送git reset --hard HEAD^ 先回退本地库的版本git push -f 再强制推送到远程库]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验参考]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[逐步补上之前的数据结构实验代码，之后也会不断完善，仅供参考(^▽^) 顺序表链表的创建输出及两种有序表的合并 对于顺序表和单链表定义不同的结构体，顺序表通过下标创建并输出链表为带头结点的单链表，使用尾插法创建并输出 从头开始遍历两个升序表，将更大的存入第三个表中，并将其标记后移对于单链表，需要使用头插法插入第三个单链表中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 顺序表的创建输出及两个升序表合并成一个升序顺序表*/#include&lt;stdio.h&gt;#include&lt;math.h&gt;typedef struct &#123; int a[100]; int len;&#125;list;void inputList(list *L) &#123; int x, i = 0; printf(&quot;输入一串数(以-1结束)：&quot;); while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123; L-&gt;a[i] = x; i++; &#125; L-&gt;len = i;&#125;void printList(list *L) &#123; printf(&quot;\n线性表为：&quot;); int i; for(i = 0; i &lt; L-&gt;len ; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125; printf(&quot;\n&quot;);&#125;void insertList(list *L, int x) &#123; int i; for(i = L-&gt;len-1; i &gt; 0 &amp;&amp; L-&gt;a[i] &gt; x; i--) &#123; L-&gt;a[i+1] = L-&gt;a[i]; &#125; L-&gt;a[i+1] = x; L-&gt;len++;&#125;void mergeDoubleUp(list *L1, list *L2, list *L3) &#123; int i = 0, j = 0, tail = 0; while(i &lt; L1-&gt;len &amp;&amp; j &lt; L2-&gt;len) &#123; if(L1-&gt;a[i] &lt; L2-&gt;a[j]) &#123; L3-&gt;a[tail] = L1-&gt;a[i]; i++; &#125; else &#123; L3-&gt;a[tail] = L2-&gt;a[j]; j++; &#125; tail++; &#125; while(i &lt; L1-&gt;len) &#123; L3-&gt;a[tail] = L1-&gt;a[i]; i++; tail++; &#125; while(j &lt; L2-&gt;len) &#123; L3-&gt;a[tail] = L2-&gt;a[j]; j++; tail++; &#125; L3-&gt;len = tail;&#125;int main() &#123; list L1, L2, L3; inputList(&amp;L1); inputList(&amp;L2); mergeDoubleUp(&amp;L1, &amp;L2, &amp;L3); printList(&amp;L3); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* 单链表的创建输出、两个升序链表合并为一个降序链表*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct k &#123; int data; struct k *next;&#125;node;void createList(node *h) &#123; node *p, *tail; tail = h; int x; printf(&quot;输入一串数(以-1结束)：&quot;); while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123; p = (node *)malloc(sizeof(node)); p-&gt;data = x; p-&gt;next = NULL; tail-&gt;next = p; tail = p; &#125;&#125;void printList(node *h) &#123; node *p; for(p = h-&gt;next; p != NULL; p = p-&gt;next) &#123; printf(&quot;%d &quot;, p-&gt;data); &#125;&#125;void mergeDoubleDown(node *h1, node *h2, node *h3) &#123; node *i, *j, *head; i = h1-&gt;next; j = h2-&gt;next; while(i != NULL &amp;&amp; j != NULL) &#123; if(i-&gt;data &lt; j-&gt;data) &#123; head = i; i = i-&gt;next; &#125; else &#123; head = j; j = j-&gt;next; &#125; // 头插法建立h3链表 head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125; // 尾部处理 while(i != NULL) &#123; head = (node *)malloc(sizeof(node)); head-&gt;data = i-&gt;data; i = i-&gt;next; head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125; while(j != NULL) &#123; head = (node *)malloc(sizeof(node)); head-&gt;data = j-&gt;data; j = j-&gt;next; head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125;&#125;int main()&#123; node h1, h2, h3; h1.next = NULL; h2.next = NULL; h3.next = NULL; createList(&amp;h1); createList(&amp;h2); printf(&quot;\n链表1为&quot;);printList(&amp;h1); printf(&quot;\n链表2为&quot;);printList(&amp;h2); mergeDoubleDown(&amp;h1, &amp;h2, &amp;h3); printf(&quot;\n链表3为&quot;);printList(&amp;h3); return 0;&#125; 顺序表的排序及单链表求最值 通过两次循环，默认为升序，如果第一次循环出现降序则进入第二次循环，第二次循环若出现升序则说明无序 设置两个标记分别从两边遍历，左为奇数时左标记继续，右为偶数时右标记继续，直到左为偶数右为奇数时则交换 设置当前标记和前驱标记遍历整个单链表，并通过预设的最大标记指针和最大前驱标记指针不断比较，遍历完最大标记指针就指向最大值 123456789101112131415161718192021222324252627282930313233343536373839404142/* 判断顺序表是否有序、实现奇偶分开、实现选择排序算法*/int isSort(sort *L) &#123; // 返回-1说明无序，1则有序 int i, j; // 两次循环判断 for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123; if(L-&gt;a[i] &gt; L-&gt;a[j]) &#123; for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123; if(L-&gt;a[i] &lt; L-&gt;a[j]) return -1; &#125; &#125; &#125; return 1;&#125;void divert(sort *L) &#123; int i = 0, j = L-&gt;len-1; while(i &lt; j) &#123; while(L-&gt;a[i] % 2 != 0) i++; while(L-&gt;a[j] % 2 == 0) j--; if(i &lt; j) &#123; int temp = L-&gt;a[i]; L-&gt;a[i] = L-&gt;a[j]; L-&gt;a[j] = temp; &#125; else break; &#125;&#125;void selectSort(sort *L) &#123; int i; for(i = 0; i &lt; L-&gt;len; i++) &#123; int min = i, j; for(j = i; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] &lt; L-&gt;a[min]) min = j; &#125; int temp = L-&gt;a[min]; L-&gt;a[min] = L-&gt;a[i]; L-&gt;a[i] = temp; &#125;&#125; 123456789101112131415161718/* 选出单链表的最大值并移至末尾*/void removeMax(node *h) &#123; node *pre, *p, *preMax, *max; preMax = h; max = preMax-&gt;next; pre = preMax-&gt;next; p = max-&gt;next; for(; p != NULL; p = p-&gt;next, pre = pre-&gt;next) &#123; if(p-&gt;data &gt; max-&gt;data) &#123; preMax = pre; max = p; &#125; &#125; preMax-&gt;next = max-&gt;next; pre-&gt;next = max; max-&gt;next = NULL;&#125; 带头指针型单链表及模式匹配算法 头指针型单链表创建时对于第一个输入单独造头结点，之后与带头结点型单链表相同 采用递归不断分解直到达最后一个结点输出 从头开始遍历文本串t，同时不断跟模式串p匹配直到成功或遍历结束匹配失败 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 创建输出头指针型单链表、合并两个升序头指针型单链表为降序、将单链表从尾至首输出*/node *createList() &#123; int x; node *h, *p, *tail; printf(&quot;输入一串数(以-1结束)：&quot;); /* 造头结点 */ scanf(&quot;%d&quot;, &amp;x); if(x == -1) return; h = (node *)malloc(sizeof(node)); h-&gt;data = x; h-&gt;next = NULL; tail = h; scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; p = (node *)malloc(sizeof(node)); p-&gt;data = x; p-&gt;next = NULL; tail-&gt;next = p; tail = p; scanf(&quot;%d&quot;, &amp;x); &#125; return h;&#125;void printList(node *h) &#123; printf(&quot;链表为：&quot;); node *p; for(p = h; p != NULL; p = p-&gt;next) &#123; printf(&quot;%d &quot;, p-&gt;data); &#125; printf(&quot;\n&quot;);&#125;node *mergeDoubleDown(node *h1, node *h2, node *h3) &#123; node *i, *j, *k; i = h1; j = h2; while(i != NULL &amp;&amp; j != NULL) &#123; if(i-&gt;data &lt; j-&gt;data) &#123; k = i; i = i-&gt;next; k-&gt;next = h3; h3 = k; &#125; else &#123; k = j; j = j-&gt;next; k-&gt;next = h3; h3 = k; &#125; &#125; // 尾部处理 while(i != NULL) &#123; k = i; i = i-&gt;next; k-&gt;next = h3; h3 = k; &#125; while(j != NULL) &#123; k = j; j = j-&gt;next; k-&gt;next = h3; h3 = k; &#125; return h3;&#125;void revPrintList(node *h) &#123; if(h-&gt;next != NULL) &#123; revPrintList(h-&gt;next); &#125; printf(&quot;%d &quot;, h-&gt;data);&#125; 12345678910111213141516171819202122232425262728/* 朴素的模式匹配算法*/void creStr(seqString *s) &#123; char x; int i = 0; while((x = getchar()) != &apos;\n&apos;) &#123; s-&gt;str[i] = x; i++; &#125; s-&gt;len = i;&#125;int simpleMatch(seqString t, seqString p) &#123; int i; for(i = 0; i &lt; t.len; i++) &#123; if(success(t, p, i)) return i; &#125; return -1;&#125;int success(seqString t, seqString p, int i) &#123; int j; for(j = 0; j &lt; p.len; j++) &#123; if(t.str[i+j] != p.str[j]) return 0; &#125; return 1;&#125; 稀疏矩阵的转置与递归程序设计 首先将行列数与非零元数存入第一个三元组，再根据输入将非零元存入对应位置快速转置时需要一遍扫描填入非零元所在的新位置数组，之后一步转置 递归时传入空格的个数作为参数，将空格作为数字 递归分解整体成第一个和其余个数为两部分进行比较返回比较结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* 稀疏矩阵的创建输出、朴素转置与快速转置*/typedef struct &#123; int r, c, e;&#125;SYZ; void inputMatrix(SYZ ma[]) &#123; int i = 0, m = 0, n = 0, r = 0, c = 0, e = 0; printf(&quot;输入行数和列数(m n)：&quot;); scanf(&quot;%d %d&quot;, &amp;m, &amp;n); ma[0].r = m; ma[0].c = n; printf(&quot;\n输入三元组(格式如3 4 5), 以回车分隔, 输入0 0 0结束：\n&quot;); scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e); while(r != 0) &#123; i++; ma[i].r = r; ma[i].c = c; ma[i].e = e; scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e); &#125; ma[0].e = i;&#125;void printMatrix(SYZ m[]) &#123; int i, j; int k = 1; printf(&quot;\n矩阵为：\n&quot;); for(i = 1; i &lt;= m[0].r; i++) &#123; for(j = 1; j &lt;= m[0].c; j++) &#123; if(k &lt;= m[0].e &amp;&amp; m[k].r == i &amp;&amp; m[k].c == j) &#123; printf(&quot; %d &quot;, m[k].e); k++; &#125; else printf(&quot; 0 &quot;); &#125; printf(&quot;\n&quot;); &#125;&#125;void generalTrans(SYZ ma[], SYZ mb[]) &#123; if(ma[0].e == 0) return; // 行列维数互换 mb[0].r = ma[0].c; mb[0].c = ma[0].r; mb[0].e = ma[0].e; // 扫描ma三元组,依次加到mb中 int k, col, e; for(k = 1, col = 1; col &lt;= ma[0].c; col++) &#123; for(e = 1; e &lt;= ma[0].e; e++) &#123; if(ma[e].c == col) &#123; mb[k].r = ma[e].c; mb[k].c = ma[e].r; mb[k].e = ma[e].e; k++; &#125; &#125; &#125;&#125;void fillNum(SYZ m[], int num[]) &#123; // 计算不同元素的个数, 存入num[] int i, k; for(i = 0; i &lt;= m[0].c; i++) num[i] = 0; for(i = 0; i &lt;= m[0].e; i++) &#123; k = m[i].c; num[k]++; &#125;&#125;void fillPos(int num[], int pos[], int len) &#123; pos[1] = 1; int k; // 从2到原列数 for(k = 2; k &lt;= len; k++) pos[k] = pos[k-1]+ num[k-1];&#125;void quickTrans(SYZ ma[], SYZ mb[]) &#123; // 一遍扫描，获取num[]和pos[] int num[20], pos[20]; fillNum(ma, num); fillPos(num, pos, ma[0].c); // 一步转置 int i, k, c; mb[0].r = ma[0].c; mb[0].c = mb[0].r; mb[0].e = mb[0].e; for(i = 1; i &lt;= ma[0].e; i++) &#123; c = ma[i].c; k = pos[c]; mb[k].r = ma[i].c; mb[k].c = ma[i].r; mb[k].e = ma[i].e; pos[c]++; &#125;&#125; 123456789101112131415/* 递归打印数字金字塔*/void printTriangle(int j, int n) &#123; if(n &lt;= 0) return; printTriangle(j+1, n-1); // 打印第n行 int i; printf(&quot;\n&quot;); for(i = 0; i &lt; j; i++) printf(&quot; &quot;); for(i = 1; i &lt;= n; i++) printf(&quot;%3d&quot;, i); for(i = n-1; i &gt;0; i--) printf(&quot;%3d&quot;, i);&#125; 1234567891011121314151617/* 递归查找顺序表元素下标、最大值下标*/int find(List L, int i, int j, int x) &#123; if(i &gt; j) return -1; if(L.arr[i] == x) return i; else return find(L, i+1, j, x);&#125;int findMax(List L, int i, int j) &#123; if(i &gt; j) return -1; if(i == j) return i; int k = findMax(L, i+1, j); if(L.arr[i] &gt; L.arr[k]) return i; else return k;&#125; 创建二叉树及前中后序遍历输出 输入字母，#代表NULL，然后先建左子树，再建右子树 前序递归先输出根的值再遍历左子树，最后遍历右子树；中序递归先遍历左子树，再输出根值，再遍历右子树；后序递归先遍历左、右子树，再输出根值 前序非递归需要先输出根值，然后保存回溯点，再进入左子树，到底后根据回溯点进入右子树；而后序非递归需要先保存回溯点，进入左子树，然后再输出回溯点值，进入右子树 1234567891011121314151617181920/* 创建二叉树*/typedef struct k&#123; char data; struct k *L, *R;&#125;bTree;bTree *creaTree() &#123; bTree *t; char c = getchar(); if(c == &apos;#&apos;) return NULL; t = malloc(sizeof(bTree)); t-&gt;data = c; t-&gt;L = creaTree(); t-&gt;R = creaTree(); return t;&#125; 12345678910111213141516171819202122/* 前中后序递归算法*/void preTraverse(bTree *t) &#123; if(t == NULL) return; printf(&quot;%c &quot;, t-&gt;data); preTraverse(t-&gt;L); preTraverse(t-&gt;R);&#125;void midTraverse(bTree *t) &#123; if(t == NULL) return; midTraverse(t-&gt;L); printf(&quot;%c &quot;, t-&gt;data); midTraverse(t-&gt;R);&#125;void postTraverse(bTree *t) &#123; if(t == NULL) return; postTraverse(t-&gt;L); postTraverse(t-&gt;R); printf(&quot;%c &quot;, t-&gt;data);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 前序、中序非递归算法*/typedef struct &#123; bTree *a[Max]; int top;&#125;Stack;void initStack(Stack *S) &#123; S-&gt;top = 0; &#125;void push(Stack *S, bTree *t) &#123; if(t == NULL || S-&gt;top == Max-1) return; S-&gt;a[S-&gt;top] = t; S-&gt;top++;&#125;bTree *pop(Stack *S) &#123; bTree *t; if(S-&gt;top == 0) return NULL; S-&gt;top--; t = S-&gt;a[S-&gt;top]; return t;&#125;int empty(Stack *S) &#123; if(S-&gt;top == 0) return 1; return 0;&#125;void preDisplay(bTree *t) &#123; Stack S; initStack(&amp;S); while(t != NULL || !empty(&amp;S)) &#123; if(t != NULL) &#123; printf(&quot;%c &quot;, t-&gt;data); push(&amp;S, t); t = t-&gt;L; &#125; else &#123; t = pop(&amp;S); t = t-&gt;R; &#125; &#125;&#125;void midDisplay(bTree *t) &#123; Stack S; initStack(&amp;S); while(t != NULL || !empty(&amp;S)) &#123; if(t != NULL) &#123; push(&amp;S, t); t = t-&gt;L; &#125; else &#123; t = pop(&amp;S); printf(&quot;%c &quot;, t-&gt;data); t = t-&gt;R; &#125; &#125;&#125; 有向网络邻接表的创建及优先遍历 先初始化结点数和边数，再输入顶点信息初始化顶点表，最后输入两边结点和权值信息利用头插法将新边表结点逐个插入到顶点头部 出度直接找到对应顶点计算边表结点个数，入度需要通过遍历整个顶点表找到边表结点值为该值的结点计算个数 从任意结点开始深度优先遍历即访问对应顶点下的未访问过的邻接点，根据邻接点的值访问对应的顶点，直至为空；广度优先遍历类似于二叉树的层次遍历，利用队列操作，默认从0开始，没访问过则访问并将顶点入队，然后顶点出队并依次访问该顶点下的邻接点，邻接点未访问过则访问并入队，直至为空 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 创建有向网络邻接表*/typedef struct k1 &#123; int eData; // 边点下标 int weight; struct k1 *next;&#125;eNode; // 边表结点typedef struct k2 &#123; int vData; // 顶点下标 eNode *first; // 边表头指针&#125;vNode; // 顶点表结点typedef struct&#123; vNode adjList[Max]; int numV, numE;&#125;ALGraph;int visited[Max] = &#123;0&#125;; // 访问状态数组void creaALGraph(ALGraph *G) &#123; int i, j, vi, vj, weight; eNode *e; printf(&quot;请输入结点数n和边数e&lt;n,e&gt;：&quot;); scanf(&quot;&lt;%d,%d&gt;&quot;, &amp;G-&gt;numV, &amp;G-&gt;numE); // 建立顶点表 printf(&quot;请连续输入顶点信息&lt;V&gt;：\n&quot;); fflush(stdin); for(i = 0; i &lt; G-&gt;numV; i++) &#123; scanf(&quot;&lt;%d&gt;&quot;, &amp;(G-&gt;adjList[i].vData)); G-&gt;adjList[i].first = NULL; &#125; // 建立边表 printf(&quot;连续输入两边结点和权值&lt;vi,vj,weight&gt;：\n&quot;); fflush(stdin); for(j = 0; j &lt; G-&gt;numE; j++) &#123; scanf(&quot;&lt;%d,%d,%d&gt;&quot;, &amp;vi, &amp;vj, &amp;weight); e = (eNode *)malloc(sizeof(eNode)); e-&gt;eData = vj; e-&gt;weight = weight; e-&gt;next = G-&gt;adjList[vi].first; // 将新边表结点插入到顶点Vi头部 G-&gt;adjList[vi].first = e; // 头插法 &#125;&#125;void printALGraph(ALGraph *G) &#123; int i, j; eNode *p; for(i = 0; i &lt; G-&gt;numV; i++) &#123; printf(&quot;%3d-&gt;&quot;, G-&gt;adjList[i].vData); p = G-&gt;adjList[i].first; while(p) &#123; printf(&quot;%3d&quot;, p-&gt;eData); p = p-&gt;next; &#125; printf(&quot;\n&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132/* 输出指定结点的入度和出度*/int getInDegree(ALGraph *G, int n) &#123; int count = 0, i; eNode *e; for(i = 0; i &lt; G-&gt;numV; i++) &#123; if(G-&gt;adjList[i].vData != n) &#123; e = G-&gt;adjList[i].first; while(e != NULL) &#123; if(e-&gt;eData == n) count++; e = e-&gt;next; &#125; &#125; &#125; return count;&#125;int getOutDegree(ALGraph *G, int n) &#123; int count = 0, i; eNode *e; for(i = 0; i &lt; G-&gt;numV; i++) &#123; if(G-&gt;adjList[i].vData == n) &#123; e = G-&gt;adjList[i].first; while(e != NULL) &#123; count++; e = e-&gt;next; &#125; break; &#125; &#125; return count;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 输出深度优先遍历和广度优先遍历结果*/typedef struct &#123; int f, r; int a[Max];&#125;Queue;void DFS(ALGraph *G, int i) &#123; eNode *p; if(visited[i]) return; printf(&quot;%d &quot;, G-&gt;adjList[i].vData); visited[i] = 1; p = G-&gt;adjList[i].first; while(p) &#123; if(visited[p-&gt;eData] == 0) DFS(G, p-&gt;eData); p = p-&gt;next; &#125;&#125;void initQueue(Queue *Q) &#123; Q-&gt;f = 0; Q-&gt;r = 0; &#125;void inQueue(Queue *Q, int i) &#123; if((Q-&gt;r+1)%Max == Q-&gt;f) return; Q-&gt;a[Q-&gt;r] = i; Q-&gt;r = (Q-&gt;r+1)%Max;&#125;int outQueue(Queue *Q) &#123; int i; if(Q-&gt;f == Q-&gt;r) return; i = Q-&gt;a[Q-&gt;f]; Q-&gt;f = (Q-&gt;f+1)%Max; return i;&#125;int isEmpty(Queue *Q) &#123; if(Q-&gt;f == Q-&gt;r) return 1; return 0;&#125;void BFS(ALGraph *G) &#123; int i; eNode *p; Queue Q; for(i = 0; i &lt; G-&gt;numV; i++) visited[i] = 0; // 初始化访问状态 initQueue(&amp;Q); for(i = 0; i &lt; G-&gt;numV; i++) &#123; // 默认从0开始遍历 if(visited[i] == 0) &#123; visited[i] = 1; printf(&quot;%d &quot;, G-&gt;adjList[i].vData); // 没访问过则访问并将顶点入队 inQueue(&amp;Q, i); while(!isEmpty(&amp;Q)) &#123; int i = outQueue(&amp;Q); p = G-&gt;adjList[i].first; // 顶点出队, 依次访问该顶点下的邻接点 while(p) &#123; if(visited[p-&gt;eData] == 0) &#123; // 邻接点未访问过则访问并入队 visited[p-&gt;eData] = 1; printf(&quot;%d &quot;, G-&gt;adjList[p-&gt;eData].vData); inQueue(&amp;Q, p-&gt;eData); &#125; p = p-&gt;next; &#125; &#125; &#125; &#125;&#125; 二分查找与二叉排序树 递归的划分判断对应下标值与key的大小而调整递归对应区间返回结果，非递归的划分通过while循环判断调整区间返回相等时的下标值，基于x:y的划分只是公式特殊一些 二叉排序树的创建就是不断插入结点的过程，使用递归时需要注意真正插入到子树，删除结点需要分度数：0度结点直接删除，1度结点由孙代子，2度结点找到前驱交换值后再删除1度结点 分块索引表的前提是数据分块有序，以界限为下标，对应的key为块的最大值，从而可以通过索引表快速查找到值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 递归与非递归实现基于x:y的划分查找 */typedef struct &#123; int a[100]; int len;&#125;list;void inputList(list *L) &#123; int x, i = 0; printf(&quot;输入一串数(以-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; L-&gt;a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; L-&gt;len = i;&#125;void printList(list *L) &#123; printf(&quot;\n线性表为：&quot;); int i; for(i = 0; i &lt; L-&gt;len ; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125; printf(&quot;\n&quot;);&#125;int BinSearchCurison(list *L, int Low, int High, int key, int X, int Y) &#123; int m; if(Low &gt; High) return -1; m = Low + (High-Low)*X/(X+Y); // 按比例划分 if(L-&gt;a[m] == key) return m; if(L-&gt;a[m] &gt; key) return BinSearch(L, Low, m-1, key, X, Y); else return BinSearch(L, m+1, High, key, X, Y);&#125;int BinSearch(list *L, int Low, int High, int key, int X, int Y) &#123; int m; while(Low &lt;= High) &#123; m = Low + (High-Low)*X/(X+Y); if(L-&gt;a[m] == key) return m; else if(L-&gt;a[m] &gt; key) High = m-1; else Low = m+1; &#125; return -1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 创建二叉排序树并对其进行查找、插入和删除，使用中序遍历验证 */#define Max 100typedef struct k&#123; int data; struct k *L, *R;&#125;bTree;typedef struct &#123; bTree *a[Max]; int top;&#125;Stack;bTree *insertBSTree(bTree *t, int x) &#123; bTree *p; p = malloc(sizeof(bTree)); p-&gt;data = x; p-&gt;L = NULL; p-&gt;R = NULL; if(t == NULL) return p; if(x &lt;= t-&gt;data) t-&gt;L = insertBSTree(t-&gt;L, x); else t-&gt;R = insertBSTree(t-&gt;R, x); return t;&#125;bTree *creaTree() &#123; bTree *t; int x; t = NULL; scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; t = insertBSTree(t, x); scanf(&quot;%d&quot;, &amp;x); &#125; return t;&#125;void midTraverse(bTree *t) &#123; if(t == NULL) return; midTraverse(t-&gt;L); printf(&quot;%d &quot;, t-&gt;data); midTraverse(t-&gt;R);&#125;bTree *searchBST(bTree *t, int x) &#123; if(t == NULL) return NULL; if(x == t-&gt;data) return t; if(x &lt; t-&gt;data) return searchBST(t-&gt;L, x); else return searchBST(t-&gt;R, x);&#125;void FindBST(bTree **t, bTree **pre, bTree **p, int x) &#123; *pre = NULL; *p = *t; while((*p) != NULL) &#123; // 查找到对应的结点，p指向它，pre指向p的双亲 if((*p)-&gt;data == x) break; if(x &lt; (*p)-&gt;data) &#123; (*pre) = (*p); (*p) = (*p)-&gt;L; &#125; else &#123; (*pre) = (*p); (*p) = (*p)-&gt;R; &#125; &#125;&#125;void del_0(bTree **pre, bTree **p) &#123; if((*pre)-&gt;L == *p) (*pre)-&gt;L = NULL; else if((*pre)-&gt;R == *p) (*pre)-&gt;R = NULL; free(*p);&#125;void del_1(bTree **pre, bTree **p) &#123; if((*pre)-&gt;L == *p) &#123; // 判断p是左子树还是右子树 if((*p)-&gt;L != NULL) (*pre)-&gt;L = (*p)-&gt;L; else (*pre)-&gt;L = (*p)-&gt;R; &#125; else &#123; if((*p)-&gt;L != NULL) (*pre)-&gt;R = (*p)-&gt;L; else (*pre)-&gt;R = (*p)-&gt;R; &#125; free(*p);&#125;void del_2(bTree **p) &#123; // 前驱替换 bTree *preQ, *q; int temp; preQ = (*p); q = (*p)-&gt;L; while(q-&gt;R != NULL) &#123; preQ = q; q = q-&gt;R; &#125;; // 找到p的前驱q, q的双亲preQ temp = (*p)-&gt;data; // p、q值互换 (*p)-&gt;data = q-&gt;data; q-&gt;data = temp; if(preQ-&gt;L == q) &#123; // 删除1度结点q if(q-&gt;L != NULL) preQ-&gt;L = q-&gt;L; else preQ-&gt;L = q-&gt;R; &#125; else &#123; if(q-&gt;L != NULL) preQ-&gt;R = q-&gt;L; else preQ-&gt;R = q-&gt;R; &#125; free(q);&#125;bTree *delBST(bTree *t, int x) &#123; bTree *pre, *p; if(t == NULL) return NULL; FindBST(&amp;t, &amp;pre, &amp;p, x); // 删除0度结点 if(p-&gt;L == NULL &amp;&amp; p-&gt;R == NULL) del_0(&amp;pre, &amp;p); // 删除1度结点 else if((p-&gt;L == NULL) != (p-&gt;R == NULL)) del_1(&amp;pre, &amp;p); // 删除2度结点 else if(p-&gt;L != NULL &amp;&amp; p-&gt;R != NULL) del_2(&amp;p); return t;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 创建分块索引表，并进行查找 */#define M 30#define DIS 7typedef struct &#123; int a[M]; int len;&#125;List;typedef struct &#123; int addr; // 地址 int key; // 关键字&#125;sNode;typedef struct &#123; sNode s[M]; int len;&#125;sList;void creaList(List *L) &#123; int x, i = 0; printf(&quot;输入一串数(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; L-&gt;a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; L-&gt;len = i;&#125;void printList(List *L) &#123; int i; for(i = 0; i &lt; L-&gt;len; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125;&#125;void creaSList(sList *S, List *L) &#123; int i, j, max, k = 0; for(i = 0; i &lt; L-&gt;len; i=i+DIS) &#123; max = L-&gt;a[i]; for(j = i; j &lt; i+DIS &amp;&amp; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] &gt; max) max = L-&gt;a[j]; &#125; S-&gt;s[k].addr = i; S-&gt;s[k].key = max; k++; &#125; S-&gt;len = k;&#125;void printSList(sList *S) &#123; int i; for(i = 0; i &lt; S-&gt;len; i++) &#123; printf(&quot;%d--%d &quot;, S-&gt;s[i].addr, S-&gt;s[i].key); &#125;&#125;int sListFind(sList *S, List *L, int x) &#123; int i, j; for(i = 0; i &lt; S-&gt;len; i++) &#123; if(S-&gt;s[i].key == x) return S-&gt;s[i].addr; else if(S-&gt;s[i].key &gt; x) &#123; // 进入顺序表 for(j = S-&gt;s[i].addr; j &lt; S-&gt;s[i].addr+DIS &amp;&amp; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] == x) return j; &#125; return -1; &#125; &#125; return -1;&#125; 常用排序算法 首先从最后一个双亲开始进行堆调整，然后将堆顶与堆的末尾位置（哨位）交换，之后去掉哨位，重复进行堆调整、交换过程直至排序完成，根据大根堆还是小根堆实现升序或降序排序 以最开始的元素x为基准，从最后一位开始设标志位，违反大小规则就交换头尾两边，将数据集分成左边小于x和右边大于x两个集合，重复这样的过程直至有序 从头至尾，归并所有相邻有序段，类似于两个升序表合并，利用辅助的数组保存归并结果，最终一趟归并完成所有归并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 堆排序 */#define M 30int initArray(int a[]) &#123; int x, i; i = 0; a[i] = -1; i++; printf(&quot;输入关键字(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; return i-1;&#125;int minChildPos(int a[], int i, int n) &#123; int k = i*2; if(k &gt; n) return -1; if(k+1 &gt; n || a[k] &lt; a[k+1]) return k; return k+1;&#125;void adjustHeap(int a[], int i, int n) &#123; int t, k; t = a[i]; k = minChildPos(a, i, n); while(k != -1 &amp;&amp; t &gt; a[k]) &#123; a[i] = a[k]; i = k; k = minChildPos(a, i, n); &#125; a[i] = t;&#125;void heapSort(int a[], int n) &#123; int t, i; // 第一次堆调整 for(i = n/2; i &gt;= 1; i--) &#123; adjustHeap(a, i, n); &#125; // 极值交换排序 for(i = n; i &gt; 1; i--) &#123; t = a[i]; a[i] = a[1]; a[1] = t; adjustHeap(a, 1, i-1); &#125;&#125; 1234567891011121314151617181920212223242526272829/* 快速排序 */#define M 30int initArray(int a[]) &#123; int x, i = 0; printf(&quot;输入关键字(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; return i-1;&#125;void quickSort(int a[], int L, int H) &#123; int i, j, t; i = L, j = H; t = a[i]; if(i &gt; j) return; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; a[j] &gt;= t) j--; if(i &lt; j) &#123; a[i] = a[j]; i++; &#125; while(i &lt; j &amp;&amp; a[i] &lt;= t) i++; if(i &lt; j) &#123; a[j] = a[i]; j--; &#125; &#125; a[i] = t; quickSort(a, L, j-1); quickSort(a, i+1, H);&#125; 123456789101112131415161718192021222324252627282930313233343536373839/* 归并排序 */#define M 30int initArray(int a[]) &#123; int x, i = 0; printf(&quot;输入关键字(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; return i-1;&#125;void mergeOne(int a[], int b[], int len, int staPos, int step) &#123; int i, j, k, endi, endj; i = staPos; j = i + step; k = i; if(j &gt;= len) &#123; for(j = i; j &lt; len; j++) b[j] = a[j]; return; &#125; endi = j-1; endj = (j+step-1&lt;len)?j+step-1:len-1; while(i &lt;= endi &amp;&amp; j &lt;= endj) &#123; if(a[i] &lt;= a[j]) &#123; b[k] = a[i]; i++; &#125; else &#123; b[k] = a[j]; j++; &#125; k++; &#125; while(i &lt;= endi) &#123; b[k] = a[i]; k++; i++; &#125; while(j &lt;= endj) &#123; b[k] = a[j]; k++; j++; &#125;&#125;void mergeAll(int a[], int b[], int len, int step) &#123; int i; for(i = 0; i &lt; len; i=i+2*step) mergeOne(a, b, len, i, step); for(i = 0; i &lt; len; i++) a[i] = b[i];&#125;void mergeSort(int a[], int b[], int len) &#123; int step; for(step = 1; step &lt; len; step=step*2) mergeAll(a, b, len, step);&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数防抖与函数节流]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[前言► 实际开发中以下场景往往由于事件频繁被触发，从而频繁执行DOM操作、资源加载等行为，导致页面卡顿甚至浏览器崩溃： window对象的 resize、scroll 事件 拖拽时的 mousemove 事件 射击游戏中的 mousedown、keydown 事件 文字输入、自动完成的 keyup 事件 ► 对于 window 的 resize 事件，实际需求一般是停止改变大小n毫秒后执行；而其它事件一般是以一定的频率执行。 ► 针对这两种需求就出现了 debounce (防抖) 和 throttle (节流) 两种解决办法 函数防抖► 如果用手一直按住一个弹簧，它将不会弹起直到你松手为止，也就是调用动作n毫秒后才会执行该动作，如果n毫秒内再次调用则重新计算执行时间 简单实现： debounce 方法接收两个参数，一个是需要防抖动的函数 fn ，另一个是延迟时间 delay 函数节流► 将水龙头拧到水以水滴的形式流出，每隔一段时间就有一滴水流出，也就是预先设定一个执行周期，调用动作的时刻不小于这个执行周期就执行它 简单实现：throttle 方法也是接收两个参数，一个是需要节流的函数 fn ，另一个是函数执行间隔阈值 threshhold 总结可以参考一下防抖和节流与正常触发的对比效果图： ► debounce 可以想象成把很多事件压缩成了一个事件，throttle 可以想象成像阀门一样定时打开调节流量 ► 简单来说，debounce 适合只执行一次的情况，比如 搜索框的自动完成：在停止输入后才提交一次ajax请求； throttle 适合每隔一定时间间隔内执行不超过一次的情况，比如 拖动滚动条、移动鼠标、滚轮事件的处理等]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6基础概念]]></title>
    <url>%2F2017%2F11%2F23%2FES6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[let命令基本用法► 用来声明变量，类似于 var，但只在 let 命令所在的代码块内有效 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceErrorb // 1 ► 使用 let ，声明的变量只在块级作用域内有效，因此 for 循环的计数器很适合用 let 命令 ► for 循环还有一个特别之处，设置循环变量的那部分是一个副作用域，而循环体内部是一个单独的子作用域 1234for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abs&apos;; console.log(i);&#125; 不存在变量提升► var 命令会有变量提升，也就是变量可以在声明之前使用，值为 undefined ► let 命令改变了这种语法行为，它所声明的变量一定要在声明后使用，否则就报错 暂时性死区► 只要块级作用域内存在 let 命令，它所声明的变量就绑定这个区域，不受外部的影响 123456var tmp = 123;if(true) &#123; tmp = &apos;abc&apos;; //ReferenceError let temp;&#125; ► 上述代码中虽然存在全局变量 tmp,但是块级作用域内 let 又声明了一个局部变量 tmp，导致后者绑定了这个块级作用域，所以在 let 声明变量之前，对 tmp 赋值都会报错 ► ES6 明确规定，区块中如果存在 let 和 const 命令，在语法上，这个区块就形成了”暂时性死区” ► 这也意味着 typeof 命令不再是一个百分百安全的操作，这样规定暂时性死区和 let、const 语句不出现变量提升，主要就是为了防止变量在声明前就使用它从而减少错误 不可重复声明► let 不允许在相同作用域内，重复声明同一个变量，也即不能在函数内部重新声明参数 123456789function func(arg) &#123; let arg; //执行会报错&#125;function func(arg) &#123; &#123; let arg; //不会报错 &#125;&#125; const命令基本用法► 用来声明一个只读的常量，一旦声明，值就不能改变，这也意味着，const 一旦声明变量就必须立即初始化，不能留到之后再赋值，其它与 let 命令类似 本质► const 实际保证的，不是变量的值不能改动，而是变量所指向的内存地址不能改动 12345678const foo = &#123;&#125;;//添加属性可以成功foo.prop = 123;foo.prop;//指向另一个对象就会报错foo = &#123;&#125;; 箭头函数基本用法► ES6 允许使用“箭头”（=&gt;）定义函数 123456var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;; ► 如果箭头函数不需要参数或者需要多个参数，就使用圆括号 1234567891011var f = () =&gt; 5;//等同于var f = function() &#123; return 5;&#125;;var sum = (num1,num2) =&gt; num1 + num2;//等同于var sum = function(num1,num2) &#123; return num1 + num2;&#125; ► 代码块多于一条语句的话就要用大括号括起来并且使用 return 语句返回 ► 由于大括号被解释为代码块，所以箭头函数返回的是一个对象的话，必须在对象外面加上括号 12345var getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot;&#125;);//等同于var getTempItem = function(id) &#123; return &#123; id: id, name: &quot;Temp&quot;&#125;;&#125;; ► 箭头函数使表达式更简洁12const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n; ► 其它用途… 使用注意点► 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象 ► 不可以当作构造函数，即不能使用 new 命令 ► 没有 arguments 对象，需要的话可以用 rest 参数代替 ► 不能使用 yield 命令，所以箭头函数不能用作 Generator 函数 尤其注意第一点，在箭头函数中 this 对象的指向是固定的 123456789function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;,100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); // id: 42 ► 上例中 setTimeout 的参数是一个箭头函数，它的定义生效在 foo 函数生成时，真正执行就要等到100ms后，如果是普通函数的话，执行时 this 应该指向全局对象 window ，即输出 21 ，但箭头函数导致this总是指向函数定义生效时所在的对象( {id: 42} )，所以输出 42 . ► this 指向的固定化，不是箭头函数内部有这样的机制，而是它没有自己的 this，所以它内部的 this 就是外层代码块的 this ,这也是它不能用作构造函数的原因 所以箭头函数转换成ES5的代码如下： 123456789101112function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id: &apos;,this.id); &#125;,100);&#125;function foo() &#123; var _this = this; setTimeout(function() &#123; console.log(&apos;id: &apos;,_this.id); &#125;,100);&#125; 对象和数组数组的解构赋值► ES6 允许按照一定模式，从数组和对象中提取值同时对变量进行赋值，这被称为 解构 1let [a,b,c] = [1,2,3]; 上面的代码中从数组中提取值并按照对应位置对变量赋值 本质上这种写法属于”模式匹配”, 只要等号两边的模式相同，左边的变量就会被赋予对应的值, 如果不完全解构即左边的模式只匹配一部分的右边的数组，解构也成功 一些例子：1234567891011121314151617/*完全解构*/let [ , , third] = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;];third // &apos;baz&apos;let [head, ...tail] = [1,2,3,4];head // 1tail // [2,3,4]/*不完全解构*/let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4]a // 1b // 2d // 4 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值 对象的解构赋值► 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名才能正确取到值 12345678910let &#123; bar, foo &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;foo // &quot;aa&quot;bar // &quot;cc&quot;let &#123; baz &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;baz // undefined/*变量名与属性名不一致的写法*/let &#123; foo: baz &#125; = &#123; foo: &apos;aa&apos;, bar: &apos;cc&apos; &#125;;baz // &quot;aa&quot; 变量名与属性名不一致的写法实际上说明，对象的解构赋值是下面形式的简写： 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aa&quot;, bar: &apos;cc&apos; &#125;; 即对象的解构赋值是先找到同名属性，再赋给对应的变量。真正被赋值的是后者而不是前者 ► 对象的解构赋值，可以很方便地将现有对象的方法赋值给对应的变量 1let &#123; log, sin, cos &#125; = Math; 解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象 用途12345/*交换变量的值*/let x = 1;let y = 2;[x, y] = [y, x] 12345678910111213141516/*从函数返回多个值*/// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();//返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 12345/*函数参数的定义*/// 参数是一组无次序的值时function f(&#123; x, y, z &#125;) &#123; ... &#125;f(&#123; z: 3, y: 5, x: 0 &#125;) 1234567/*提取JSON数据*/let jsonData = &#123; id: 42, data: [860, 504]&#125;;let &#123; id, data: number &#125; = jsonData; 123456789jQuery.ajax = function(url, &#123; async = true, beforeSend = function() &#123;&#125;, cache = true, complete = function() &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123;&#125;; 123/* 输入模块的指定方法 */const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础]]></title>
    <url>%2F2017%2F11%2F23%2FjQuery%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础核心代码风格‘$’： jQuery 当中最重要并且独有的对象：jQuery对象1234567$(function() &#123;&#125;); //执行一个匿名函数$(&apos;#box&apos;); //进行执行的ID元素选择$(&apos;#box&apos;).css(&apos;color&apos;,&apos;red&apos;); //执行功能函数/*等同于*/jQuery(function() &#123;&#125;);jQuery(&apos;#box&apos;); 执行功能函数时，先获取元素返回 jQuery 对象后再调用功能函数，同时返回的还是 jQuery 对象，所以可以连缀不停的调用功能函数 1$(&apos;#box&apos;).css(&apos;color&apos;,&apos;red&apos;).css(&apos;font-size&apos;,&apos;50px&apos;); 加载模式jQuery 等待加载： 1$(document).ready(function () &#123;&#125;); 它的执行时机只需等待网页中的DOM结构加载完毕就可以执行包裹的代码，并且可以执行多次不会覆盖 window.onload 需要等待图片之类的大型元素加载完毕后才能执行JS代码，在网速慢的情况下，图片还在缓慢加载时，页面上任何的JS交互功能都会处在假死状态，同时只能执行一次，会给实际开发带来困难 对象互换jQuery 对象是 jQuery 库独有的对象，通过JS封装而来，可以直接输出得到它的信息 只要使用代码包裹以后，最终返回的都是 jQuery 对象，好处就是可以连缀处理，如果需要返回原生的DOM对象的话，可以这么处理： 1$(&apos;#box&apos;).get(0); //ID元素的第一个原生DOM 从get(0)的索引看出， jQuery 可以批量处理DOM，在循环遍历上会更方便 多个库之间的冲突同一个项目中引入多个第三方库时，由于没有命名空间的约束，不同库之间很容易发生冲突 对于同样使用’$’作为基准起始符的库(如 Base 库)，想和 jQuery 共存的话有两种办法： 先引入 jQuery 库，这样’$’的所有权就归之后的库所有， jQuery 可以直接用jQuery对象调用，或者创建一个新符(‘$$’)给它用： 12345var $$ = jQuery;$(function () &#123; $(&apos;#box&apos;).get(0); // 都是Base的$ $$(&apos;#box&apos;).width(0); // jQuery的$$&#125;); 后引入 jQuery 库，’$’归 jQuery 库，jQuery 有一个方法可以放弃： 12345jQuery.noConflict(); // 将$符所有权剔除var $$ = jQuery;$(function () &#123; ... // $属于Bae, $$属于jQuery&#125;); 工具函数字符串操作12var str = &apos; sad&apos;;$.trim(str); //去除字符串左右空格 数组和对象操作12345678910/*$.each()遍历数组*/var arr = [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;];$.each(arr,function(index, value) &#123; $(&apos;#box&apos;).html($(&apos;#box&apos;).html + index + &apos;.&apos; + value + &apos;&lt;br&gt;&apos;);&#125;);/*遍历对象*/$.each($.ajax(), function(name, fn) &#123; $(&apos;#box&apos;).html($(&apos;#box&apos;).html() + name + &apos;.&apos; + &apos;&lt;br&gt;&lt;br&gt;&apos;);&#125;) 123456/*$.grep()数据筛选*/var arr = [5,3,5,7,45,98,23,10];$.grep(arr, function(element, index) &#123; return element &lt; 6 &amp;&amp; index &lt; 5;&#125;);/*index从0开始计算*/ 1234567/*$.map()修改数据*/var arr = [5,6,87,54,32,4,10];$.map(arr, function(element, index) &#123; if(element &lt; 6 &amp;&amp; index &lt; 5) &#123; return element + 1; &#125;&#125;); ► $.merge() 合并两个数组 ► $.unique() 删除重复的DOM元素 ► .toArray() 合并多个DOM元素组成数组 … 测试操作 URL操作123456/*$.param()将对象键值对转换为URL字符串键值对*/var obj = &#123; name : &apos;Lee&apos;, age : &apos;20&apos;&#125;;$.param(obj); 其它操作jQuery提供了一个预备绑定函数上下文的工具函数: $.proxy(),可以解决如外部事件触发调用对象方法时this的指向问题 12345678910111213141516171819/*$.proxy()调整this指向*/var obj = &#123; name : &apos;Lee&apos;, test: function() &#123; alert(this.name); &#125;&#125;$(&apos;#box&apos;).click(obj.test); //this指向为#box元素，undefined$(&apos;#box&apos;).click($.proxy(obj,&apos;test&apos;)); //this指向为对象box，Lee/*等效于*/var obj = &#123; name : &apos;Lee&apos;, test : function() &#123; var _this = obj; alert(_this.name); &#125;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象与原型]]></title>
    <url>%2F2017%2F11%2F23%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这里会先把之前已经写好的总结陆续放上来，主要也是有一个时间顺序记录自己的学习过程（(#^.^#)） 面向对象与原型一.创建对象：1.最基本的创建一个对象并添加属性和方法 缺点：每创建一个类似对象，都会产生大量代码 解决：工厂模式解决实例化对象产生大量重复代码，即设计一个实例化的函数 2.工厂模式： 新问题：无法区别实例的来源对象 解决：用构造函数来创建特定的对象 3.构造函数 重复实例化和对象识别的问题都得到解决 规范：1.函数名和实例化名相同并且首字母大写（有助于区分构造函数和普通函数） 2.必须用new运算符创建对象（与普通函数的区别） 与工厂模式的区别：1.构造函数没有显式地创建对象 2.直接把属性方法赋给this对象 3.没有return语句 小问题：在对run方法的引用上每次实例化的地址都不同，即alert(person1.run == person2.run)的结果是false 二.原型创建的每个函数都有一个prototype属性（对象）。包含可以由特定类型的所有实例共享的属性和方法 1.构造函数与原型模式的声明方式： 通过两种方式的对比可以明白为什么它们在对方法的引用地址上会有区别 2.原型模式的执行流程：构造函数实例里有属性或方法的话就返回，没有就去它的原型对象中找 对属性是在构造函数的实例里还是原型里的判断：hasOwnProperty()---&gt;实例有返回true in操作符 ---&gt;只要存在就返回true ---&gt;两种方法结合判断原型中是否存在属性 3.原型模式创建对象的缺点：共享—–如果某次实例化时改变了原型中的属性，则会影响到之后的实例化对象 —–如果有传入参数的话，之后的实例化对象属性会覆盖掉之前的，无法独立 即用相同原型创建的对象访问原型中的属性时，访问的都是同一个对象解决：构造函数+原型模式的组合模式： 构造函数适合封装属性 原型模式适合封装方法 组合模式： 解决了传参和共享的难题，进一步的优化是把构造函数和原型封装到一起 动态原型模式： 以上两种是JS创建对象时使用较多的方式，优先考虑动态原型模式 4.补充：寄生构造函数：工厂模式+构造函数模式 —&gt;需要创建一个具有额外方法的引用类型 稳妥构造函数： —&gt;构造函数中不用this,外部实例化函数时不用new 三.继承1.原型链正统面向对象语言实现继承的方式：接口实现和继承 ECMAScript只支持继承，实现的方式是依靠原型链 实质：通过原型让一个引用类型继承另一个引用类型的属性和方法 被继承的函数称为超类型（父类、基类）;继承的函数称为子类型（子类、派生类） 继承存在的问题： 字面量重写原型会中断关系 子类型无法给超类型传递参数 2.借用构造函数（对象冒充）—&gt;解决引用共享和不能给超类型传参的问题 新问题：没有原型，无法复用 3.组合继承（最常用）—&gt;通过原型链继承原型的属性方法 —&gt;通过借用构造函数继承实例的属性 —&gt;既实现了函数复用，又保证每个实例的独立性 4.原型式继承—&gt;借助原型并基于已有的对象创建新对象，不用再创建自定义类型 5.寄生式继承（原型式+工厂模式）—&gt;为了封装创建对象的过程 6.寄生组合式继承—&gt;处理组合式继承的问题：超类型在使用过程中被调用了两次： 创建子类型时 在子类型构造函数内部 通过原型链的混成形式调用方法，解决了两次调用的问题 总结：1.创建对象： 工厂模式：用简单的函数创建对象，添加属性方法然后返回它 构造函数模式：可以创建特定的对象，但是它的成员包括函数都不能复用 原型模式：利用函数的prototype属性来指定应该共享的方法和属性 组合模式：利用构造函数定义实例属性，利用原型定义共享方法 2.继承： 原型链继承：通过原型让一个引用类型继承另一个引用类型的属性和方法 借用构造函数（对象冒充）：解决引用共享和超类型不能传参的问题 组合继承：通过原型链继承原型的属性方法，通过借用构造函数继承实例的属性，最常用，但有多次调用超类型构造函数导致的低效率问题 原型式继承：在已有对象上借助原型创建新对象，新对象可以进一步添加属性方法 寄生式继承：封装了创建对象的过程，基于这个可以进一步增强对象 寄生组合式继承：通过原型链的混成形式调用方法，避免多次调用超类型构造函数，基于类型继承的最有效方式]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建你的博客]]></title>
    <url>%2F2017%2F11%2F23%2FHexo-blog%2F</url>
    <content type="text"><![CDATA[一开始自己用hexo搭博客的时候踩了比较多坑，在这里想总结一下做一个简单的搭建教程，后续使用再慢慢完善 初始配置环境 node 作用：生成静态页面 Git 作用：将本地的hexo内容提交到github上 申请Github 作用：作为博客的远程仓库和服务器 Hexo的安装及初始化环境配置好后，创建一个文件夹，进入后执行以下命令： npm install hexo-cli -g 安装hexo hexo init 初始化 npm install hexo generate 生成静态页面 hexo server 启动本地服务之后浏览器输入localhost:4000 就可以看到一个默认的hexo博客啦 Github上的配置进入Github新建一个仓库，这里特别要强调的是仓库名的格式必须为yourusername.github.io，yourusername就是你的Github用户名，这里错误的话，之后直接访问就会404（我就是这样o(╥﹏╥)o）,建好以后就clone一下HTTPS形式的url（这里先不用SSH） 本地Hexo文件的修改进入Hexo文件根目录下的_config.yml，打开以后拉到最下面的deploy那里，改成如下形式：1234deploy: type: git repo: https://github.com/fxbabys/fxbabys.github.io.git branch: master 这里也特别要强调的是冒号后面一定要加空格 然后执行命令安装: npm install hexo-deployer-git --save再执行配置命令: hexo deploy这样本地文件就上传到Github远程库上了，访问https://fxbabys.github.io/就行了 之后每次部署发布文章可以按下面的步骤进行： hexo new &quot;文章名称&quot; 这样会在source/_posts下生成一个md文档 hexo server(hexo s) 上传前本地先预览一下效果 hexo generate(hexo g) hexo deploy(hexo d) 到这里搭建一个hexo博客和发布新文章就完成啦！更个性化的设置可以自己去Hexo官方文档上查看，介绍的都很详细，也可以去网上找教程再多折腾一些自己的喜好（(^▽^)）]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome]]></title>
    <url>%2F2017%2F11%2F19%2Fwelcome%2F</url>
    <content type="text"><![CDATA[Welcome to my technology blog !This is the first blog I built myself and I will update my study and thinking life in it later.I hope it can also help others who read this blog，let’s step forward together！]]></content>
  </entry>
</search>

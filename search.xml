<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[每周精进(12.25)]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-12-25%2F</url>
    <content type="text"><![CDATA[学业方面：目前基本完成了 Drive Online 整体的逻辑，最终决定做的还是精简化 健壮化（学会给自己砍需求2333）, 剩下的在前台交互细节上再打磨一下周六就可以答辩了，这个项目已经有了足够完善的基础，之后是打算扩展成毕设的～ 实习方面：目前已经投出去了好几家，也联系到了一些大佬进行交流，自己目前薄弱的地方还是在算法没怎么刷过题上，上次面试也感觉这是个短板，因此接下来重点放在多刷点题上，之前用 js 实现数据结构与算法的仓库也会继续完善，同时对于前端一些较陌生的原理会继续深入理解，结合被动面试法好好涨涨经验～ 12.31 日前计划： Drive Online 答辩 理电项目接口完成 面试准备 剑指 offer 缓存与性能优化整理]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(12.19)]]></title>
    <url>%2F2018%2F12%2F19%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-12-19%2F</url>
    <content type="text"><![CDATA[上一次的周计划已经算是三周前了, 这三周也密密麻麻经历过很多事情, 日志易面试, 理电项目功能修补, java 课设答辩, jsp课设, 六级… 也包括一些不太愉快的人际交往. 面试的结果确实比较出乎我的意料, 我对自己应该有更加自信的定位, HR那边也很积极地在跟我沟通, 在目前期末包括未来方向等等的压力下我确实多了一些纠结性的思考, 但冷静下来以后还是坚定自己最初的想法, 坚持对技术的追求, 必须去大厂见识一下前沿的技术实践, 真正会承受的压力未来还有很多. 因此决定坚持周计划下去, 毕竟坚持本不易, 在繁忙的生活中适当停下来进行总结思考是非常有必要的, 有更规律性计划性的输出对自己的成长也绝对是更有帮助的, 同时也调整好心态继续进行实习的简历投递. 话不多说, 12.24 日前计划: 完成好数据库与算法设计的上机考试 理电论文项目完成最后的缴费支付部分 Drive Online 分类以及基本操作实现方式敲定, 下周的重点 框架原理再深入(结合 Drive Online) React-Router v4 React 性能优化相关 …]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React入门]]></title>
    <url>%2F2018%2F12%2F07%2FReact%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本文将会从零开始介绍 React 的核心知识点，以下是参考大纲~ React React 是什么 为什么要使用 React 项目预览 JSX Styles 组件 props 类组件 State 事件处理 生命周期 更多 脚手架 状态管理与路由 话不多说，直接进入~ ReactReact 是什么 官方定义: 一个用来构建用户界面的 JavaScript 库 从定义中我们要有一个认知: React 本身所做的只是构建用户界面，而大型的 React 项目一般都会紧密结合它的生态圈(路由: React-Router 状态管理库: Redux等等)来实现，这篇文章主要专注的还是 React 的核心知识点 为什么要使用 React 虚拟 DOM: 我们都知道 js 频繁操作 dom 的成本是非常昂贵的，而 React 首创的 virtual dom 实现了在 js 层面来操作 dom，极大地提高了应用的效率 可复用组件: React 的流行带动了组件化的思想，组件化的核心就是在于可复用性，相比于传统的 Web 开发模式也更容易维护，很好地提高了开发效率 由 Facebook 维护: React 背靠 Facebook 这座大山，其身后有许多优秀的开发者在维护迭代，同时社区也十分的活跃，开发遇到的大部分问题很快都可以得到解决 现实: 最后一点就是国内的现状，大厂的技术栈基本都是基于 React 的，所以向公司(qian)看齐的话 React 也是必不可少的技能 项目预览先看一下最终的项目效果，可以思考一下利用原生 js 如何实现 ? 初始的空模板: 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; JSX我们首先来看 React 是如何构建界面即渲染元素的: React 的语法为 JSX, 即混合了 JavaScript 和 HTML 的语法 这里我们采用外链引入的方式加入 React 项目最基本的两个链接: 12&lt;script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"&gt;&lt;/script&gt; // react 核心&lt;script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"&gt;&lt;/script&gt; // react-dom 浏览器(dom)的渲染 同时为了直接能够使用 JSX 的语法, 我们还需要引入 babel 的外链: 123456&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"&gt;&lt;/script&gt;// script 标注 type&lt;script type="text/babel"&gt;// coding....&lt;/script&gt; 然后敲上第一行 React 代码: 1ReactDOM.render(&lt;h1&gt;Hello React!&lt;/h1&gt;, document.getElementById('app')); 刷新浏览器: ReactDOM 对象来自 react-dom, 这里我们调用了它的 render 方法, 第一个参数是要渲染的元素, 第二个是实际的 DOM 对象, 这样就成功的将 JSX 元素渲染到了页面上 我们可以看到 JSX 语法实际上跟 HTML 还是很像的, 那么 CSS 呢 ? Styles内联样式: 1ReactDOM.render(&lt;h1 style=&#123;&#123;backgroundColor: 'lightblue'&#125;&#125;&gt;Hello React!&lt;/h1&gt;, document.getElementById('app')) 外部样式: 12345const h1Style = &#123; backgroundColor: 'lightblue'&#125;ReactDOM.render(&lt;h1 style=&#123;h1Style&#125;&gt;Hello React!&lt;/h1&gt;, document.getElementById('app')) PS: 如果是使用了 css 类选择器, 那么 JSX 中的写法是 className (为了与 ES6 的 class 区分) 目前学会这几种写法就足够了 组件我们刚刚在 render 方法中直接写的 JSX , 当你的 JSX 元素变得复杂起来就需要单独定义一个 Component, 我们先来看看 无状态组件 的写法: 12345678910function App () &#123; return ( &lt;div&gt; &lt;h1&gt;Hello React!&lt;/h1&gt; &lt;p&gt;react is so awesome!&lt;/p&gt; &lt;/div&gt; )&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('app')) 刷新浏览器: 这里需要注意的是返回的组件必须只由一个最大的标签来包含 接下来让我们敲一些有意思的: 123456789101112131415function App () &#123; const books = ['dataBase', 'data structure', 'computer network'] return ( &lt;div&gt; &lt;h3&gt;My books: &lt;/h3&gt; &lt;ul&gt; &#123;books.map(book =&gt; &lt;li&gt;&#123;book&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; &lt;/div&gt; )&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('app')) 我们定义一个 books 数组, 然后在函数组件内部使用 ES6 的 map 方法循环渲染出对应的 book 元素 刷新浏览器: 首先我们可以看到界面上出现了三个 li , 但是更显眼的是控制台出现了显眼的报错, 这个报错提示很重要, 意即每一个循环出的元素都需要有一个 key , 这样的话 React 就能在列表变化时识别其中成员的添加 、更改和删除的操作(diff 算法), 会有更好的性能, 因此这里我们使用 map 的第二个参数来加上对应的 key: 12345678910111213function App () &#123; const books = ['dataBase', 'data structure', 'computer network'] return ( &lt;div&gt; &lt;h3&gt;My books: &lt;/h3&gt; &lt;ul&gt; &#123;books.map((book, i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;book&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; &lt;/div&gt; )&#125; 刷新控制台不再报错 这里我们也可以发现, App 组件内部的循环列表更适合抽出来单独做一个列表组件以实现更好的复用性: 12345678910111213141516171819function BookList () &#123; return ( &lt;ul&gt; &#123;books.map((book, i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;book&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; )&#125;function App () &#123; const books = ['dataBase', 'data structure', 'computer network'] return ( &lt;div&gt; &lt;h3&gt;My books: &lt;/h3&gt; &lt;BookList /&gt; &lt;/div&gt; )&#125; 但是很明显我们又发现了另一个问题, books 数组是定义在 App 组件内部的, bookList 组件如何获取到它的值? props上面的问题即是父子组件如何传递值? 很直接的想法, 我们可以在父组件内部放置子组件时传入一些自定义的参数: 123456789function App () &#123; const books = ['dataBase', 'data structure', 'computer network'] return ( &lt;div&gt; &lt;h3&gt;My books: &lt;/h3&gt; &lt;BookList list=&#123;books&#125; /&gt; &lt;/div&gt; )&#125; 然后我们在 BookList 子组件内捕捉到传下来的参数: 1234567891011function BookList (props) &#123; console.log('props: ', props) const books = props.list return ( &lt;ul&gt; &#123;books.map((book, i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;book&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; )&#125; 刷新浏览器: OK! 这就是 props, 我们同时在控制台打印了这个对象, 从这就可以看出数据在不同组件间传递的方式. 现在来思考一个新问题: 目前的数据只是默默地在传递, 不同组件只是单纯地把它显示出来, 如果我们需要添加或者删除这些数据该如何操作, React 又如何获知这些数据被更改了并及时更新 UI 呢? 类组件让我们来认识 React 自身给我们提供的另一种组件—类组件 类组件的来源于 ES6 中 的class, 这里我们看一下将 App 组件改写成类组件的写法: 12345678910111213141516class App extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; books: ['dataBase', 'data structure', 'computer network'] &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;h3&gt;My books: &lt;/h3&gt; &lt;BookList list=&#123;this.state.books&#125; /&gt; &lt;/div&gt; ) &#125;&#125; React.Component 是 React 自带的通用类, 它封装了所有 React 类需要的实现细节, 类组件都是通过继承它来实现, 通过重写 render 方法来定义返回的组件元素 State我们可以看到原来的 books 数组放到了 constructor 构造函数中作为该类组件的内部状态来使用: 123this.state = &#123; books: ['dataBase', 'data structure', 'computer network']&#125; state 通过使用 this 绑定在类上, 我们可以在整个组件内访问到 state, 每次修改组件的 state, 组件的 render 方法会再次运行即组件重新渲染, 那我们可以直接修改 state 吗 ? React 有两个重要的原则: 一个是单向数据流, 另一个是明确的状态改变. 我们唯一改变 state 的方式是通过 setState() 组件在 render 中获取最新 state 的信息进行渲染, 在 View 层通过调用 setState 来更新 state, 然后组件再次运行 render 方法并更新界面. 我们来尝试一下: 1234567891011121314151617class App extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; books: ['database', 'data structure', 'computer network'] &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;h3&gt;My books: &lt;/h3&gt; &lt;BookList list=&#123;this.state.books&#125; /&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; books: ['Compilation principle', 'operating system'] &#125;)&#125;&gt;Change&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 事件处理当 setState 关联的逻辑复杂起来以后, 包括我们需要在不同组件间调用 setState 时, 从复用性与维护性角度上来说, 我们都需要将事件处理抽离成自定义的函数来调用, React 中推荐事件处理函数的前缀都为 handle , 监听函数的前缀都为 on: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class App extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; books: ['database', 'data structure', 'computer network'], input: '' &#125; this.handleAddBook = this.handleAddBook.bind(this) this.handleRemoveBook = this.handleRemoveBook.bind(this) this.updateInput = this.updateInput.bind(this) &#125; handleAddBook () &#123; this.setState(currentState =&gt; &#123; return &#123; books: currentState.books.concat([this.state.input]) &#125; &#125;) &#125; handleRemoveBook (name) &#123; this.setState(currentState =&gt; &#123; return &#123; books: currentState.books.filter(book =&gt; book !== name) &#125; &#125;) &#125; updateInput (e) &#123; this.setState(&#123; input: e.target.value &#125;) &#125; render () &#123; return ( &lt;div&gt; &lt;h3&gt;My books: &lt;/h3&gt; &lt;input type="text" placeholder="new book" value=&#123;this.state.input&#125; onChange=&#123;this.updateInput&#125; /&gt; &lt;button onClick=&#123;this.handleAddBook&#125;&gt;Add&lt;/button&gt; &lt;BookList list=&#123;this.state.books&#125; onRemoveBook=&#123;this.handleRemoveBook&#125; /&gt; &lt;/div&gt; ) &#125;&#125; handleAddBook 和 handleRemoveBook 为新增和修改的操作, 这里还需要特别强调的是构造函数中的这三行代码: 123this.handleAddBook = this.handleAddBook.bind(this)this.handleRemoveBook = this.handleRemoveBook.bind(this)this.updateInput = this.updateInput.bind(this) 当我们想在自定义的类方法中调用 this.setState 时, 这里的 this 是 undefined, 所以为了类组件的 this 在类方法中可以访问, 我们需要将 this 绑定到类方法上, 而放在构造函数里面的话绑定只会在组件实例化时运行一次, 性能消耗更少. OK! 事实上到这里我们已经可以基本完成项目预览所呈现的内容了, 现在请你试着做更多的改进以达到下面的效果: 如果你已经完成, 可以参考以下的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function ActiveBooks (props) &#123; return ( &lt;div&gt; &lt;h2&gt;Reading Books&lt;/h2&gt; &lt;ul&gt; &#123;props.list.map((book, i) =&gt; ( &lt;li key=&#123;i&#125;&gt; &lt;span&gt;&#123;book.name&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; props.onRemoveBook(book.name)&#125;&gt;Remove&lt;/button&gt; &lt;button onClick=&#123;() =&gt; props.onDeactive(book.name)&#125;&gt;Readed&lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; )&#125;function InactiveBooks (props) &#123; return ( &lt;div&gt; &lt;h2&gt;Readed Books&lt;/h2&gt; &lt;ul&gt; &#123;props.list.map((book, i) =&gt; ( &lt;li key=&#123;i&#125;&gt; &lt;span&gt;&#123;book.name&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; props.onActive(book.name)&#125;&gt;Reading&lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; )&#125;class App extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; books: [ &#123; name: 'database', active: true &#125;, &#123; name: 'data structure', active: true &#125;, &#123; name: 'computer network', active: true &#125;], input: '' &#125; this.handleAddBook = this.handleAddBook.bind(this) this.handleRemoveBook = this.handleRemoveBook.bind(this) this.handleToggleBook = this.handleToggleBook.bind(this) this.updateInput = this.updateInput.bind(this) &#125; handleAddBook () &#123; this.setState(currentState =&gt; &#123; return &#123; books: currentState.books.concat([&#123; name: this.state.input, active: true &#125;]), input: '' &#125; &#125;) &#125; handleRemoveBook (name) &#123; this.setState(currentState =&gt; &#123; return &#123; books: currentState.books.filter(book =&gt; book.name !== name) &#125; &#125;) &#125; handleToggleBook (name) &#123; this.setState(currentState =&gt; &#123; const book = currentState.books.find(book =&gt; book.name === name) return &#123; books: currentState.books.filter(book =&gt; book.name !== name) .concat([&#123; name, active: !book.active &#125;]) &#125; &#125;) &#125; updateInput (e) &#123; this.setState(&#123; input: e.target.value &#125;) &#125; render () &#123; return ( &lt;div&gt; &lt;h3&gt;My books: &lt;/h3&gt; &lt;input type="text" placeholder="new book" value=&#123;this.state.input&#125; onChange=&#123;this.updateInput&#125; /&gt; &lt;button onClick=&#123;this.handleAddBook&#125;&gt;Add&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; books: [] &#125;)&#125;&gt; Clear All &lt;/button&gt; &lt;ActiveBooks list=&#123;this.state.books.filter(book =&gt; book.active)&#125; onRemoveBook=&#123;this.handleRemoveBook&#125; onDeactive=&#123;this.handleToggleBook&#125; /&gt; &lt;InactiveBooks list=&#123;this.state.books.filter(book =&gt; !book.active)&#125; onActive=&#123;this.handleToggleBook&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 走到这里, 你已经可以自己再写几个小 demo 熟悉一下了, 那么让我们再来思考最后一个问题: 项目中很多时候的数据都是要与后台交互的, 也就是会有异步的操作, 在数据还未请求到时我们希望显示加载样式, 请求到以后再更新界面, 这样的逻辑应该放在哪里? 生命周期对于上面的问题, 我们实际希望的是当组件被挂载到 DOM 上以后再来渲染界面, 同时对于有很多组件的应用, 当组件销毁时, 我们也需要释放它所占用的资源, 这就是 React 生命周期 当中很重要的两个函数: componentDidMount和 componentWillUnmout 让我们整体感觉一下生命周期函数执行的过程: 1234567891011121314151617181920212223242526272829class App extends React.Component &#123; constructor (props) &#123; ...... console.log('--constructor--') &#125; componentDidMount () &#123; console.log('--componentDidMount--') &#125; componentDidUpdate () &#123; console.log('--componentDidUpdate--') &#125; componentWillUnmout () &#123; console.log('--componentWillUnmout--') &#125; ...... render () &#123; console.log('--render--') return ( ...... ) &#125;&#125; 我们可以看出, 组件整个的生命周期是从 constructor –&gt; render –&gt; componentDidMount, 然后组件更新再次 render –&gt; componentDidUpdate , 组件销毁前则会调用 componentWillUnmout 接下来我们将会深入使用这几个函数: 让我们先手动模拟一个 API: 123456789101112131415161718192021window.API = &#123; fetchBooks () &#123; return new Promise((res, rej) =&gt; &#123; const books = [ &#123; name: 'database', active: true &#125;, &#123; name: 'data structure', active: true &#125;, &#123; name: 'computer network', active: false &#125; ] setTimeout(() =&gt; res(books), 2000) &#125;) &#125;&#125; 然后在 componentDidMount 函数中调用它: 12345678910componentDidMount () &#123; console.log('--componentDidMount--') API.fetchBooks() .then(books =&gt; &#123; this.setState(&#123; books &#125;) &#125;)&#125; 我们可以看到在 componentDidMount 之后再去请求数据, 然后 render 重新渲染再执行了 componentDidUpdate 让我们再来提升一下用户体验加上 Loading 的逻辑: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class App extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; books: [], loading: true, input: '' &#125; ...... console.log('--constructor--') &#125; componentDidMount () &#123; console.log('--componentDidMount--') API.fetchBooks() .then(books =&gt; &#123; this.setState(&#123; books, loading: false &#125;) &#125;) &#125; componentDidUpdate () &#123; console.log('--componentDidUpdate--') &#125; componentWillUnmout () &#123; console.log('--componentWillUnmout--') &#125; ...... render () &#123; console.log('--render--') if (this.state.loading === true) &#123; return &lt;h2&gt;Loading...&lt;/h2&gt; &#125; return ( ...... ) &#125;&#125; OK! 现在我们整个的 React 入门历程已经结束了, 当然并没有完全实现预览的效果, 鼓励你进一步独立封装一个 Loading 组件, 最后让我们简单谈一下更进一步的开发操作 更多脚手架我们的入门教程是用传统的外链引入方式来使用 React 的, 并且为了使用 JSX 我们还需要再引入 babel , 现代化的 Web 开发流程都是基于 Webpack 的模块化构建与部署过程, 对于实际成型的项目来说, 一般都推荐使用官方的脚手架 create-react-app 来一步构建, 简化依赖安装与环境部署的流程, 更多地专注在代码逻辑的编写上 状态管理与路由还记得 React 的定义吗? 它只是专注在用户界面的构建上面, 虽然我们通过类组件可以管理一定的内部状态, 但是当项目复杂到一定程度以后, 避免不了是要引入外部的状态管理库, 这里推荐使用跟 React 理念相合的 Redux ; 目前的单页面应用都需要用到路由管理, 推荐使用 React-Router 最后我想说, 前端的技术表面是发展得很快的, 但是内部的原理基本都是万变不离其宗, React 带来的是一种新的变革的开发方式, 希望你以此为起点, 结合 React 的设计理念去深入它更多的特性.]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从原型到class]]></title>
    <url>%2F2018%2F11%2F30%2F%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0class%2F</url>
    <content type="text"><![CDATA[本文将会从原型介绍到原型实现继承与 ES6 的 class 实现继承并进行对比~ 原型JavaScript 并不是一门纯面向对象的语言，而是一门基于原型的动态类型语言． 每一个 js 对象都有一个特殊的内置 [[Prototype]] 属性，这个属性我们不能直接访问到，需要借助另一个 __proto__ 属性，这个属性即指向了原型，而原型也是一个对象，这个对象当中定义了很多函数可以让我们使用(类似超类) 在原型对象中还有一个 constructor 属性，也就是构造函数，而这个构造函数又通过 prototype 属性指回原型（除了 Function.prototype.bind()，因为这个对象是由引擎创建出来的） 多个对象通过 __proto__ 属性连接起来就形成了原型链 这里把经典的图放上来对照着理解： 总结： Object 是所有对象的祖先，即所有对象都可以通过 __proto__ 找到它 Function 是所有函数的祖先，即所有函数都可以通过 __proto__ 找到它 对象都是通过 Function (构造器)创建的，即有 Object.__proto__ === Function.prototype 函数也是由 Function 创建的，自然也有 Fucntion.__proto__ === Function.prototype 除了 Function.prototype 和 Object.prototype 由引擎创建，其余都是通过 Function new 出来的 __proto__ 将对象和原型连接起来形成了原型链，原型链最终为 null new调用 new 的过程中会发生四件事情： 新生成一个中间对象 将这个中间对象链接到原型 绑定这个对象的 this 到构造函数上 返回该中间对象 实现一下： 1234567function create () &#123; let obj = new Object() let Con = [].shift.call(arguments) obj.__proto__ = Con.prototype let res = Con.call(obj, arguments) return typeof res === 'object' ? res : obj&#125; 从这里可以看出两点： 通过 new 生成的对象 this 是永久绑定到对应构造函数的 创建对象最好使用字面量的方式，使用 new Obejct() 需要通过作用域链一层层向上找到 Object 并且可读性也不好 (内部都是通过 new Object() 方式，但是如果我们自己采用 new Object() ，引擎就会认为可能存在同名的构造函数而选择通过作用域链一层一层找至全局) instanceofinstanceof 可以正确的判断对象的类型，内部机制是通过判断该对象的原型链中是否能找到类型的 prototype 实现一下： 123456789function instanceof (obj, type) &#123; let prototype = type.prototype obj = obj.__proto__ while (true) &#123; if (obj === null) return false if (prototype === obj) return true obj = obj.__proto__ &#125;&#125; PS： instanceof 可不可以直接被用来判断基本类型？（自定义 instanceof 行为） 继承原型继承组合继承在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后再改变子类的原型为继承父类的函数 12345678910function Parent (value) &#123; this.val = value&#125;Parent.prototype.getValue = function () &#123; return this.val&#125;function Child (value) &#123; Parent.call(this, value)&#125;Child.prototype = new Parent() 这种继承的优点在于构造函数可以传参，不会与父类的引用属性共享，因此可以复用父类的函数，但是也有一个缺点就是继承父类函数时通过 new 调用了父类构造函数，导致子类的原型上多出了不需要的父类属性 寄生组合继承组合继承的优化版，即继承父类函数时不通过调用构造函数的方式，而是将父类的原型赋值给子类并将构造函数设置成子类 1234567891011121314151617function Parent (value) &#123; this.val = value&#125;Parent.prototype.getValue = function () &#123; return this.val&#125;function Child (value) &#123; Parent.call(this, value)&#125;Child.prototype = Object.create(Parent.prototype, &#123; constructor: &#123; value: Child, enumerable: false, writable: true, configurable: true &#125;&#125;) class 继承class 实际上只是语法糖，本质上还是函数： 12class Person &#123;&#125;Person instanceof Function 通过 class 实现的继承： 1234567891011121314class Parent &#123; constructor (value) &#123; this.val = value &#125; getValue () &#123; return this.val &#125;&#125;class Child extends Parent &#123; constructor (value) &#123; super(value) // 等同于 Parent.call(this.value) this.val = value &#125;&#125; 参考链接： https://yuchengkai.cn/docs/zh/frontend/#%E5%8E%9F%E5%9E%8B https://github.com/amandakelake/blog/issues/39]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(11.26)]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-26%2F</url>
    <content type="text"><![CDATA[11.18 第八周计划总结～ 完善 jsp 大作业的整体模板 完成 Speedest 功能的基本扩展(doing) Algorithm-JS 的完善(doing) 本周推进最多的应该是 jsp 的大作业了，到现在的阶段基本的构造以及计划都已经成型，我是不打算写 jsp 的，最终思路还是进行前后端分离的实践，做一个类似 Google Drive 的文件存储云平台，后端采用 java ，数据库的选择上一方面项目有很重要的一个逻辑就是文件的分类，即一个分类对应多个文件，另一方面也想尝试一下新东西，所以选择了 MongoDB，目前后端的接口基础已经打好了，接下来这一周会结合数据库的设计逐渐完善，另一个 java 的课设实现多线程下载与断点续传比较难啃，接下里的重心会放在这两个上面 12.2日前计划: 继续完善 Drive Online （后端接口设计） Speedest-downloader 实现 Algorithm-JS 的完善]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(11.18)]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-18%2F</url>
    <content type="text"><![CDATA[11.10第七周计划总结~ 实践 jeem 结合 react-router 的使用规范 戳我 专栏进度跟进 熟悉网络与算法相关的基础面试题 这周重新改造了 jeem-demo 的目录结构，结合 react-router 的语法设计了一个demo增强版的模板，可以直接基于这个模板进行成型项目的开发部署，同时结合专栏完善了基本数据结构的项目并开放出来，之后会依据已有目录更新完善更多的 JS 版本的代码～，接下来的重心觉得应该放一部分精力回各类大作业上了(~~) 11.25日前计划: 完善 jsp 大作业的整体模板 (jeem subscription的扩展) 完成 Speedest 功能的基本扩展 Algorithm-JS 的完善]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(11.10)]]></title>
    <url>%2F2018%2F11%2F10%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-11-10%2F</url>
    <content type="text"><![CDATA[10.30 第六周计划总结~ react深入学习(Test方面)(continuing) 专栏的跟进(continuing) 读完&lt;&lt;跃迁&gt;&gt; 关于 Test 这方面目前能深入的并不多，大部分时间还是在完成业务逻辑，两篇专栏的进度会更加重视跟进，最大的收获就是读完跃迁了，对硅谷的相关体系有了更深的了解，同时也对我之后想走的方向有一定的指导性 这个月开始来年春招的消息越来越多了，也有争取寒假实习的打算，接下来的重点结束好手上的项目以后会放在面试上，每周精进这部分之后会固定在周末的时间进行回顾，下一周的目标会更细致地考虑而定，保证立下的 flag 能好好实现 11.17日前计划： 实践 jeem 结合 react-router 的使用规范 专栏进度持续跟进 熟悉网络与算法相关的基础与面试题]]></content>
      <tags>
        <tag>每周精进</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(10.30)]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-30%2F</url>
    <content type="text"><![CDATA[10.22 第五周计划总结~ 理电项目测试上线(nearly end) react体系深入(接下来的重点) 专栏训练营进度跟进(同上) 本月完成webpack配置细节博客 这周得到最大的bonus应该就是 autosub 的完美使用了，算是为之后的学习道路解决了一个比较大的障碍，同时1024拼单买到了很喜欢的两本书，也会是接下来几周的阅读重点，不考虑内容对于现在的实际收获，仅仅很久没有感受到的读纸质书时内心的平静与满足就足够了，也算是作为我未来发展方向的启蒙读物吧～ 11.4日前完成： react 深入学习(Test 方面) 专栏(数据结构与算法之美 网络协议)专栏的跟进 读完&lt;&lt;跃迁&gt;&gt; More：结合 jeem 考虑好 web应用技术大作业的实现 基于 Taro 编写小程序应用架构 近期书单：跃迁 从零开始学架构]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack配置介绍]]></title>
    <url>%2F2018%2F10%2F28%2Fwebpack%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍 jeem webpack(4.0)相关的配置，不会针对webpack作过多的详解，算是webpack最佳配置的一个总结，会不断更新~ WebpackWebpack 是一个现代 JavaScript 应用程序的静态模块打包器，它处理应用程序时会递归地构建一个依赖关系图，其中包含应用程序所需的各个模块，然后将所有这些模块打包成一个或多个bundle 概念结合四个核心概念介绍目前所需的依赖： entry: 入口起点指示 webpack 应该使用哪个模块开始，默认: ./src output: 出口属性告诉 webpack 在哪里输出它所创建的bundles及如何命名这些文件，默认: ./dist loader: 让 webpack 能够处理非 JavaScript 文件(将所有类型的文件转换为 webpack 能够处理的有效模块) babel-loader: ES6语法转化 这里一并介绍下跟 babel 相关的技术生态: babel-preset-env: babel配置文件中使用, 包含 ES6+ 等版本的语法转化规则 babel-polyfill: ES6 内置方法和函数转化 babel-plugin-transform-runtime: 避免 polyfill 污染全局变量 babel-loader 负责的是语法转化，babel-polyfill 负责内置的方法和函数 style-loader: 从 js 字符串中生成 style 节点 css-loader: 将 css 转化成 commonJS 模块 less-loader: 将 less 编译成 css url-loader: 图片处理 plugins: 用于执行范围更广(从打包优化压缩到重新定义环境中的变量)的任务 html-webpack-plugin: 自动生成 html 文件并自动插入静态资源 js脚本 mini-css-extract-plugin: css提取压缩 clean-webpack-plugin: 重新打包时先清除 dist 目录下的文件 mode设置：webpack4 开始通过设置 mode 为 development 或 production 就可以启用相应模式下 webpack 内置的优化 实战配置公用配置基于 jeem 推荐的语法，公用配置重点在针对 es6+ 和 less 的处理： es6+：babel7 转译 es6+ 的依赖是 @babel/polyfill 为什么不用不会污染全局变量的 babel-plugin-transform-runtime？ jeem 定位是一个框架，针对于提供最良好的使用体验，因此对于api的使用需求会比较高，而babel-plugin-tranform-runtime 不能够转码实例方法(如 repeat includes等)，因此选择支持更多特性的babel-polyfill less: less-loader + css-loader + style-loader 先看babel相关的配置： 12345678910111213141516"babel": &#123; "presets": [ "@babel/preset-env", "@babel/preset-react" ], "plugins": [ [ "import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": true &#125; ] ]&#125;, 接下来直接结合配置注释理解吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const path = require('path');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const webpackMerge = require('webpack-merge');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const modeConfig = env =&gt; require(`./build/webpack.$&#123;env&#125;`)(env);module.exports = (&#123; mode &#125; = &#123; mode: 'development', presets: [] &#125;) =&gt; webpackMerge( &#123; mode, entry: ['@babel/polyfill', './src/index.js'], output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;, resolve: &#123; alias: &#123; '@': path.join(__dirname, '.', 'src'), &#125;, &#125;, module: &#123; rules: [ &#123; test: /\.(js)$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', &#125;, &#125;, &#123; test: /\.js$/, exclude: /node_modules/, use: ['babel-loader', 'eslint-loader'], &#125;, &#123; test: /\.(less)$/, exclude: /node_modules/, use: [&#123; loader: mode === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, // creates style nodes from JS strings &#125;, &#123; loader: 'css-loader', // translates CSS into CommonJS options: &#123; sourceMap: true, modules: true, localIdentName: '[name]__[local]__[hash:base64:5]', &#125;, &#125;, &#123; loader: 'less-loader', // compiles Less to CSS options: &#123; javascriptEnabled: true, &#125;, &#125;], &#125;, &#123; test: /\.(less)$/, exclude: /src/, use: [&#123; loader: mode === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader, // creates style nodes from JS strings &#125;, &#123; loader: 'css-loader', // translates CSS into CommonJS &#125;, &#123; loader: 'less-loader', // compiles Less to CSS options: &#123; javascriptEnabled: true, &#125;, &#125;], &#125;, &#123; test: /\.(jpe?g|png|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; name: '[name]-[hash:5].min.[ext]', limit: 20000, publicPath: 'static/', outputPath: 'static/', &#125;, &#125;, ], &#125;, ], &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', &#125;), new webpack.ProgressPlugin(), new MiniCssExtractPlugin(), ], &#125;, modeConfig(mode),); 开发配置开发配置主要需要的是热更新以及调试直接定位源码（结合webpack4 development模式内置优化）： 12345678910111213// build/webpack.development.jsconst webpack = require('webpack')module.exports = () =&gt; (&#123; devtool: 'source-map', //方便调试 devServer: &#123; hot: true, // 结合下面的plugin开启热更新 overlay: true // 报错网页遮罩提示 &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;) 生产配置webpack4 production 模式已经内置了针对压缩打包方面的优化，这里目前解决的是多次重复打包dist目录下会出现冗余的文件： 123456789101112131415// build/webpack.production.jsconst path = require('path')const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = () =&gt; (&#123; output: &#123; filename: 'bundle.js' &#125;, plugins: [ new CleanWebpackPlugin(['dist'], &#123; root: path.resolve(__dirname, '../'), // webpack根目录的绝对路径 verbose: true // 写入日志调试 &#125;) ]&#125;) 以上就是 jeem 目前 webpack 相关的配置，后续 jeem 进一步开发需要支持的也会越多 (如 file image等处理)，届时会同步更新~]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(10.22)]]></title>
    <url>%2F2018%2F10%2F22%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-22%2F</url>
    <content type="text"><![CDATA[10.15 第四周计划总结~ 理电学院项目的基本结尾(continuing) 心理学院项目初步(老师那边说暂时不做了…) 细读&lt;你不知道的js&gt;(中卷) 回调 Promise 生成器 章节(continuing) &lt;数据结构与算法之美&gt;专栏与训练营进度的跟进 至少完成&lt;网络协议&gt;专栏两篇文章的阅读(Hmm) 这周的good parts应该就是 jeem 关于webpack配置部分做好了基础, 分离了开发和生产环境的配置, 为之后做了一个铺垫, 同时自己对于webpack整体的理解使用也有了一定的体会, 有空可以撰写博客出来啦, 其它部分… 项目上结尾进行中, 读书上感觉略微有点难啃了但是我会坚持进行下去的, keep forward! 10.28日前完成: 理电项目测试上线 react 体系深入(结合视频开始) 专栏与训练营进度跟进, &lt;网络协议&gt; 至少完成两篇! More: 争取本月内完成 webpack 配置细节的博客, and jeem is forwarding now~ 近期书单: 你不知道的JavaScript]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(10.15)]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-15%2F</url>
    <content type="text"><![CDATA[10.7 第三周计划总结~ 实现 jeem model 数据订阅相关功能，尝试 npm 自动构建流程 撰写与 jeem 相关知识的一篇博客 多阅读&lt; 你不知道的js &gt;（下卷）关键内容 专栏与训练营进度的持续跟进 这周计划的完成度实在不忍看（捂脸），没有什么借口好找，假期结束后在平时事务与前端学习之间应该更好地掌握其中的节奏，接下来一周重点会放在16项目的结尾与17新开发的项目上，这也是 jeem 第一次亮剑，也希望能结合这个新项目更好地完善 jeem ，读书方面具体读到下卷的异步与性能之后发现中卷相关的回调 Promise 生成器等底层的理解与起源还是应该细读一遍，所以也会重读中卷的相关细节 10.21日前完成: 理电学院项目的基本结尾 心理学院项目的开发初期领步并暨此完善 jeem 已知的不足（开发与生产模式配置 前后端联调配置） 细读&lt; 你不知道的js &gt; (中卷) 回调 Promise 生成器章节，回归下卷的阅读 &lt; 数据结构与算法之美 &gt; 专栏进度与训练营的跟进 至少完成&lt;网络协议&gt;专栏两篇文章的阅读 近期书单：你不知道的JavaScript]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(10.7)]]></title>
    <url>%2F2018%2F10%2F07%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-10-7%2F</url>
    <content type="text"><![CDATA[9.30 第二周计划总结～ 基于dva &amp; umi &amp; deef 尝试开始造自己的Framework 将已经实现的轮子至少选一个作好博客说明 戳我 跟上＜数据结构与算法之美＞专栏的进度 至少完成＜你不知道的js＞(中卷)关键部分的阅读 完成本周六级训练营的基本任务 10月内完成＜趣谈网络协议＞专栏的阅读 jeem 成型主要理念参考是来自 dva 和 rematch，在这个过程中对于 Redux 的理念与局限有了更深的理解，同时 jeem 的核心也是完全自己来实现的，收获很多，但是开始接触 npm 模块发布流程后也碰了不少壁，感觉十分的麻烦，也说明自己对前端模块化工程这方面的理解还不够，希望在持续完善 jeem 的过程中能补充好相关知识并且多思考前端架构选型的原则，有些坑还是越早踩越好(==) 10.14日前完成: 实现 jeem model 数据订阅相关功能，尝试利用好 npm 自动构建流程 撰写与 jeem 相关知识 (redux 模块化…) 的一篇博客 尽量多阅读&lt; 你不知道的js &gt; (下卷) 关键部分内容 专栏与训练营的进度持续跟进 近期书单：你不知道的JavaScript]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零实现一个MVVM]]></title>
    <url>%2F2018%2F09%2F30%2F%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAMVVM%2F</url>
    <content type="text"><![CDATA[介绍MVVM 由以下三个内容组成: Model: 数据模型 View: 界面 ViewModal: 沟通 View 和 Model MVVM 的思想是数据驱动视图，相比于 jQuery 操作 DOM 的时代，数据逻辑与页面实现了解耦，数据改变&lt;=&gt;UI改变，数据与业务的处理都放在 ViewModel 中并且可以复用 MVVM 中最核心的就是数据双向绑定，如 Angluar 的脏数据检测，Vue 中的数据劫持 接下来就详细解析实现基于数据劫持的双向绑定，功能上参考 v-model 还会完善一下编译的过程 数据劫持首先是 DOM 元素以及类的实例化使用: 1234&lt;div id="app"&gt; &lt;input type="text" v-model="message"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 123456let vm = new MVVM(&#123; el: '#app', data: &#123; message: 'Hello Jeremy!' &#125;&#125;) 这里实例化了一个 MVVM 类，我们来实现它的初始结构: 12345678910class MVVM &#123; constructor (options) &#123; this.$el = options.el this.$data = options.data if (this.$el) &#123; new Observer(this.$el, this) // 数据劫持 &#125; &#125;&#125; 接下来就是 Observer 类: 12345678910111213141516171819202122232425262728293031class Observer &#123; constructor (data) &#123; this.observe(data) // 劫持函数 &#125; observe (data) &#123; if (!data || typeof data !== 'object') return Object.keys(data).forEach(key =&gt; &#123; this.defineReactive(data, key, datat[key]) this.observe(data[key]) // 递归劫持 -&gt; 针对嵌套对象 &#125;) &#125; defineReactive (data, key, value) &#123; const _this = this const dep = new Dep() // Observer 与 Watcher 解耦 Object.defineProperty(data, key, &#123; // 双向绑定关键 enumerable: true, configurable: true, get () &#123; Dep.target &amp;&amp; dep.subscribe(Dep.target) // 订阅 Watcher 对象 return value &#125;, set () &#123; if (newValue !== value) &#123; value = newValue _this.observe(newValue) // 赋值也劫持 dep.notify() &#125; &#125; &#125;) &#125;&#125; Dep 类: 1234567891011class Dep &#123; constructor () &#123; this.subs = [] &#125; subscribe (watcher) &#123; this.subs.push(watcher) &#125; notify () &#123; this.subs.forEach(watcher =&gt; watcher.update()) &#125;&#125; 接下来就是 Watcher 类: 12345678910111213141516171819202122232425262728class Watcher &#123; constructor (vm, expr, cb) &#123; this.vm = vm this.expr = expr this.cb = cb this.value = this.get() // 初始化时保存当前值 &#125; getVal (vm, expr) &#123; // 兼容嵌套对象的取值 const attrs = expr.split('.') return attrs.reduce((prev, next) =&gt; &#123; return prev[next] &#125;, vm.$data) &#125; get () &#123; Dep.target = this // 将 target 指向自己 const value = this.getVal(this.vm, this.expr) // 触发 getter 监听 Dep.target = null // 置空 return value &#125; update () &#123; const newValue = this.getVal(this.vm, this.expr) const oldValue = this.value if (newValue !== oldValue) &#123; this.cb(newValue) // 对应 watcher 的更新回调 &#125; &#125;&#125; 以上三个类就是关于数据劫持的核心代码，new MVVM 时将 data 传入 observe 类中进行劫持，通过 Object.defineProperty 属性设置 getter 与 setter，在 new Watcher 类时构造函数调用 get 方法，触发 getter 监听并将对应 watcher 实例保存在 dep 对象数组中，修改数据值时 触发 setter 调用 notify 方法，遍历所有 watcher 实例，值修改了的实例就更新 那么 new Watcher 在哪里会调用呢？．．． 编译过程数据劫持完之后便是对节点的编译: 123456789class MVVM &#123; constructor (options) &#123; ... if (this.$el) &#123; new Observer(this.$data) // 数据劫持 new Compile(this.$el, this) // 节点编译 &#125; &#125;&#125; 所以最后我们要来实现 Compile 类: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Compile &#123; constructor (el, vm) &#123; this.el = isElementNode(el) ? el : document.querySelector(el) this.vm = vm if (this.el) &#123; const fragment = this.nodeToFragment(this.el) // 将真实DOM移入内存中 this.compile(fragment) // 编译 v-model 和 &#123;&#123;&#125;&#125; 节点 this.el.appendChild(fragment) // 重新塞回页面中 &#125; &#125; isElementNode (el) &#123; return el.nodeType === 1 &#125; isDirective (attr) &#123; return attr.inculdes('v-') &#125; nodeToFragment (el) &#123; const fragment = document.createDocumentFragment() let firstChild while (firstChild = el.firstChild) &#123; fragment.appendChild(firstChild) &#125; return fragment &#125; compile (fragment) &#123; const nodes = fragment.childNodes Array.from(nodes).forEach(node =&gt; &#123; if (this.isElementNode(node)) &#123; // 判断元素节点与文本节点 this.compileElement(node) this.compile(node) // 元素节点需要递归判断 &#125; else &#123; this.compileText(node) &#125; &#125;) &#125; compileElement (node) &#123; const attrs = node.attributes Array.from(attrs).forEach(attr =&gt; &#123; if (this.isDirective(attr)) &#123; const [, type] = attr.split('-') // 现在这里 type 就是 model CompileUtil[type](node, this.vm, attr.value) &#125; &#125;) &#125; compileText (node) &#123; const expr = node.textContent const reg = /\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g // &#123;&#123; message &#125;&#125; if (reg.test(expr)) &#123; CompileUtil['text'](node, this.vm, expr) &#125; &#125;&#125; 可以看到对于元素或者文本节点的具体处理我们封装了一个 CompileUtil 对象，来实现它: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051CompileUtil = &#123; text (node, vm, expr) &#123; const updateFn = this.updater['textUpdater'] expr.replace(/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g, (...arguments) =&gt; &#123; // Boom~, new Watcher 在这 new Watcher(vm, arguments[1].trim(), newValue =&gt; &#123; updateFn &amp;&amp; updateFn(node, this.getTextVal(vm, expr)) // 数据变化时文本节点需要重新获取依赖属性更新文本内容 &#125;) &#125;) updateFn &amp;&amp; updateFn(node, thie.getTextVal(vm, expr)) // 初始编译 &#125;, model (node, vm, expr) &#123; const udpateFn = this.updater['modelUpdater'] new Watcher(vm, expr, newValue =&gt; &#123; updateFn &amp;&amp; updateFn(node, newValue) &#125;) node.addEventListener('input', e =&gt; &#123; // 监听 input 事件 const newValue = e.target.value this.setVal(vm, expr, newValue) &#125;) updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)) &#125;, updater: &#123; textUpdater (node, value) &#123; node.textContent = value // 文本节点赋值 &#125;, modelUpdater (node, value) &#123; node.value = value // 元素节点赋值 &#125; &#125;, getVal (vm, expr) &#123; // 对嵌套对象值的获取 const attrs = expr.split('.') return attrs.reduce((prev, next) =&gt; &#123; return prev[next] &#125;, vm.$data) &#125;, getTextVal (vm, expr) &#123; return expr.replace(/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g, (...arguemnts) =&gt; &#123; return this.getVal(vm, arguments[1].trim()) &#125;) &#125;, setVal (vm, expr, value) &#123; const attrs = expr.split('.') return attrs.reduce((prev, next, currentIndex) =&gt; &#123; if (currentIndex === attrs.length - 1) &#123; return prev[next] = value // 对最后的非对象赋值 &#125; return prev[next] &#125;, vm.$data) &#125;&#125; 编译时首先将真实DOM节点放入内存中编译 v-model 与 { { } } 两类节点，对于元素节点与文本节点分别以不同的回调函数实例化 Watcher 类，并且完善了对于多层嵌套对象的处理，至此，在编译的过程了关联了对应的 watcher 实例，重新塞回页面后更改属性值便会触发 setter 进而更新页面 扩展: ProxyObject.defineProperty 目前实现的双向绑定的缺陷: 只能对属性进行数据劫持，所以需要深度遍历整个对象 不能监听到数组数据的变化 而对于 Vue 来说，它本身做了一定的 hack 可以检测到数组数据的变化: 123456789101112131415161718192021222324252627282930313233343536373839404142// src/core/observer/array.jsimport &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * 拦截变异方法并且触发事件 */methodsToPatch.forEach(function (method) &#123; // 获得原生函数 const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.call(this, args) // 先调用原生函数 const ob = this.__ob__ let inserted switch (method) &#123; // 获取到插入的值 case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.splice(2) break &#125; if (inserted) ob.observeArray(inserted) // 触发更新 ob.dep.notify() return result &#125;)&#125;) 通过对原生函数的 hack， Vue 可以检测到数据数组的变化，但是还是有局限性： 不能检测到以下变动的数组 利用索引直接设置一个项时，如：vm.items[indexOfItem] = newValue 修改数组的长度时，如：vm.items.length = newLength 什么是Proxy? 原生支持监听数组变化并且可以直接对整个对象进行拦截 12345678910111213141516171819202122232425262728const onWatch = (obj, setBind, getLogger) =&gt; &#123; const handler = &#123; get(target, property, receiver) &#123; getLogger(target, property) return Reflect.get(target, property, receiver) &#125;, set(target, property, value) &#123; setBind(value) return Reflect.set(target, property, value) &#125; &#125; return new Proxy(obj, handler)&#125;const obj = &#123; a: &#123; b: 1 &#125;&#125;const arr = [0, 1]let valueconst pObj = onWatch(obj, v =&gt; &#123; value = v &#125;, (target, property) =&gt; &#123; console.log(`Get '$&#123;property&#125;' = $&#123;target[property]&#125;`)&#125;)pObj.a.b = 2const pArr = onWatch(obj, v =&gt; &#123; value = v &#125;, (target, property) =&gt; &#123; console.log(`Get '$&#123;property&#125;' = $&#123;target[property]&#125;`)&#125;)pArr[0] = 1 如今 Proxy 已经基本被各大浏览器都支持，Vue3.0 的计划中就有基于Proxy实现全语言覆盖的变动侦测 参考链接: Vue.js技术揭秘：检测变化的注意事项 面试图谱：Proxy 与 Object.defineProperty 对比]]></content>
      <tags>
        <tag>Wheels</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(9.30)]]></title>
    <url>%2F2018%2F09%2F29%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-9-30%2F</url>
    <content type="text"><![CDATA[9.23第一周计划总结~ 学习实现Promise发布到轮子项目上，并作博客说明 戳我 基于umi重构react-hackernews 戳我 精听六级听力一篇，完成六级作文一篇 Hmmm… 对于六级实在是有些无奈… 因此决定报了某贝的六级训练营，只要自己挤时间出来完全跟着老师走就行，不过还能退款~ 同时在这周的学习中发现自己还是更应该多专注在基础知识上，并且贴合周计划安排了更多的循序渐进的学习过程 10.7日前完成: 基于 dva &amp; umi &amp; deef 的依赖技术栈尝试开始造自己的Framework 将已经实现的轮子至少选一个作好博客说明 跟上＜数据结构与算法之美＞专栏的进度 至少完成＜你不知道的js＞(中卷)关键部分的阅读 完成本周六级训练营的基本任务 10月内完成＜趣谈网络协议＞专栏的阅读 近期书单：你不知道的JavaScript]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零实现一个Promise]]></title>
    <url>%2F2018%2F09%2F28%2F%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise%2F</url>
    <content type="text"><![CDATA[从暑假开始开发Vue项目，其中使用最频繁的库就是官方推荐的axios，基于Promise的HTTP库，这里参考了几篇优秀的解读文章尝试实现自己的Promise~ Promise 是 ES6 新增的语法，解决了回调地狱的问题 本文将根据 Promise A+ 规范 解读并从零实现一个Promise，通过 promises-aplus/promises-tests 所有测试 Promise 标准解读Promise 表示一个异步操作的最终结果，主要通过 then 方法与之进行交互，该方法注册了两个回调函数，用来接收 Promise resolve 的终值或者 Promise reject 被拒绝的原因 Promises States一个 Promise 必须是以下三个状态之一: pending fulfilled (resolved) rejected 初始状态为 pending, 一旦转为 fulfilled 或 rejected, 就不能再次转为其它状态, 状态确定的过程叫做 settle then 方法 一个 Promise 必须提供一个 then方法，并且接收两个参数，返回的也是一个Promise 1promise.then(onFulfilled, onRejected) The Promise Resolution Procedure不同实现的 Promise 之间可以无缝地相互调用, 比如： 12345new MyPromise((resolve, reject) =&gt; &#123; // MyPromise 表示自己实现的Promise库 resolve(1)&#125;).then(() =&gt; &#123; return Promise.reject(2) // ES6 Promise&#125;) 实现Promise基本构造函数1234567891011121314151617181920212223242526272829303132333435363738394041const PENDING = 'pending'const RESOLVED = 'resolved'const REJECTED = 'rejected'function MyPromise (fn) &#123; var _this = this _this.currentState = PENDING // Promise当前状态 _this.value = undefined // Promise的值 _this.resolvedCallbacks = [] // 用于状态为 pending 时保存 then 中的回调 _this.rejectedCallbacks = [] _this.resolve = function (value) &#123; if (value instanceof MyPromise) &#123; // 若 value 是一个 Promise 则递归执行 return value.then(_this.resolve, _this.reject) &#125; setTimeout(() =&gt; &#123; // 标准3.1: 异步执行 if (_this.currentState === PENDING) &#123; _this.currentState = RESOLVED _this.value = value _this.resolvedCallbacks.forEach(cb =&gt; cb()) &#125; &#125;) &#125; _this.reject = function (reason) &#123; setTimeout(() =&gt; &#123; if (_this.currentState === PENDING) &#123; _this.currentState = REJECTED _this.value = reason _this.rejectedCallbacks.forEach(cb =&gt; cb()) &#125; &#125;) &#125; try &#123; // 考虑到执行fn时可能出错, 所以这里try/catch一下, 并将catch到的值reject回去 fn(_this.resolve, _this.reject) &#125; catch (e) &#123; _this.reject(e) &#125;&#125; then 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859MyPromise.prototype.then = function (onResolved, onRejected) &#123; const self = this // 规范 2.2.7: then 必须返回一个新的Promise let promise2 // 规范 2.2: onResolved 和 onRejected 为可选参数 如果类型不是函数需要忽略并且实现了透传 onResolved = typeof onResolved === 'function' ? onResolved : v =&gt; v onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125; if (self.currentState === RESOLVED) &#123; // promise1(this/self)的状态已经确定并且为resolved, 调用onResolved return promise2 = new MyPromise(function (resolve, reject) &#123; // 规范 2.2.4: 保证 onFulfilled onRjected 异步执行 setTimeout(function () &#123; try &#123; const x = onResolved(self.value) resolutionProcedure(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125; if (self.currentState === REJECTED) &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; const x = onRejected(self.value) resolutionProcedure(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125; if (self.currentState === PENDING) &#123; // 当前Promise还处于pending状态不能确定调用onResolved还是onRejected // 所以需要将 两种情况的判断处理逻辑 作为callback 放入当前Promise对象的回调数组里 return promise2 = new Promise(function (resolve, reject) &#123; self.resolvedCallbacks.push(function (value) &#123; try &#123; const x = onResolved(self.value) resolutionProcedure(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;) self.rejectedCallbacks.push(function (reason) &#123; try &#123; const x = onRejected(self.value) resolutionProcedure(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125;&#125; 不同Promise间的交互then 方法返回 x 可能是一个Promise对象(thenable)，为了确保调用成功，需要实现标准2.3的内容，这样即使实现方式不同，但遵循同样的标准不同的Promise之间也可以无缝地相互调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 规范2.3: 针对不同的Promise实现交互function resolutionProcedure (promise2, x, resolve, reject) &#123; // 规范2.3.1: x与promise2不能相同, 避免循环引用 if (promise2 === x) &#123; return reject(new TypeError('Chaing cycle detected for promise')) &#125; // 规范2.3.2: x是一个Promise 状态为pending则需要继续等待 否则执行 if (x instanceof MyPromise) &#123; if (x.currentState === PENDING) &#123; x.then(function (value) &#123; resolutionProcedure(promise2, value, resolve, reject) &#125;, reject) &#125; else &#123; x.then(resolve, reject) &#125; return &#125; // 2.3.3.3: resolve或reject其中一个执行过则忽略其它的 let thenCalledOrThrow = false if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; // 规范2.3.3 try &#123; // 2.3.3.1: x.then可能是getter（函数）, 如果是函数就执行 let then = x.then if (typeof then === 'function') &#123; // 2.3.3.3 then.call( x, y =&gt; &#123; if (thenCalledOrThrow) return // 2.3.3.3.3 三处谁执行就以谁的为准 thenCalledOrThrow = true resolutionProcedure(promise2, y, resolve, reject) // 2.3.3.3.1 &#125;, r =&gt; &#123; if (thenCalledOrThrow) return // 2.3.3.3.3 三处谁执行就以谁的为准 thenCalledOrThrow = true reject(r) &#125; ) &#125; else &#123; resolve(x) &#125; &#125; catch (e) &#123; if (thenCalledOrThrow) return thenCalledOrThrow = true reject(e) &#125; &#125; else &#123; // 2.3.4 resolve(x) &#125;&#125; 测试在上述完整代码最后加入测试的脚本: 123456789101112MyPromise.deferred = function () &#123; var dfd = &#123;&#125; dfd.promise = new MyPromise(function (resolve, reject) &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd&#125;try &#123; module.exports = MyPromise&#125; catch (e) &#123;&#125; 然后安装 promises-aplus-tests 执行测试 12npm i -g promises-aplus-testspromises-aplus-tests Promise.js Success ! 参考链接： 面试图谱: Promise实现 剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类]]></content>
      <tags>
        <tag>Wheels</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周精进(9.23)]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%AF%8F%E5%91%A8%E7%B2%BE%E8%BF%9B-9-23%2F</url>
    <content type="text"><![CDATA[从暑假结束到现在近一个月, 大部分的时间都在忙课程和组织迎新, 整体的学习感觉并不好, 博客和github都一直在闲置, 趁着放假的机会好好整理一下思绪, 还是希望能利用好最后一个学期上课的时间多做明年春招的准备,争取进入大厂去见识更广阔的世界~ 因此决定坚持开始一个每周有所精进的阶段, 每周日定好下一周的小目标, 下一周最先开始说明目标完成情况,以此督促自己~ 9.30日前完成: 学习实现Promise发布到轮子项目上, 尽量能作博客说明 基于umi重构react-hackernews 精听六级听力一篇. 完成六级作文一篇 近期书单: Node.js: 来一打C++扩展]]></content>
      <tags>
        <tag>周计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端页面开发总结]]></title>
    <url>%2F2018%2F08%2F04%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[工作室暑期集训在带17级成员做官网，这里主要总结一些移动端页面开发的基本知识~ 像素 概念：一个像素就是计算机屏幕所能显示一种特定颜色的最小区域 web前端开发中： 设备像素：设备屏幕的物理像素，对任何设备来说物理像素的数量是固定的 CSS像素：抽象的像素概念，专为web开发者创造 比如：给一个元素设置 width: 200px 即这个元素的宽度跨越了200个CSS像素 跨越的设备像素：取决于手机屏幕和用户的缩放 iPhone的像素密度是普通屏幕的2倍此时200px 跨越了400个设备像素 用户缩小页面到一定程度时，一个CSS像素会明显小于一个设备像素，用户缩放页面就是在缩放CSS像素，设备像素大小数量都是固定的 移动端的视口 视口是html的父元素，也称为初始包含块，即html元素的百分比是基于视口的 布局视口：移动端CSS布局的依据视口 PC浏览器中，视口的宽度 = 浏览器窗口的宽度 移动端中CSS布局会依据布局视口来计算 获取布局视口的宽高： 12document.documentElement.clientWidthdocument.documentElement.clientHeight 视觉视口：用户所看见的网站区域 理想视口：理想的布局视口： 将布局视口设为理想视口 1&lt;meta name="viewport" content="width=device-width" /&gt; width指布局视口的宽度、device-width指理想视口的宽度 设备像素比 Device Pixel Ratio（DPR），计算公式： 前提（缩放比例为1）：DPR = 设备像素个数 / 理想视口CSS像素个数（device-width） 浏览器手机预览模式显示的是理想视口宽高 缩放页面：缩小放大的是CSS像素 meta 标签： 让布局视口和理想视口的宽度匹配，常用属性： width: 设置布局视口的宽 init-scale：设置页面的初始缩放程度 minimum-scale：设置页面的最小缩放程度 maximum-scale：设置页面的最大缩放程度 user-scalable：是否允许用户对页面进行缩放 常用实例： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" 媒体查询： 响应式设计的基础： 检测媒体类型，如 screen、tv等 检测布局视口的特性，如视口的宽高分辨率等 特性相关查询，如检测浏览器是否支持某某特性 语法： 123@media 媒体类型 and (视口特性阈值) &#123; // css code&#125; 从设计图到页面开发 起因：设计图依据设备像素进行设计，而CSS布局依据布局视口的尺寸进行计算 解决方案一： 将布局视口的尺寸设置为和设备像素尺寸相等，在设置meta标签后即需要设置理想视口尺寸 CSS缩放值 = 设备像素比的倒数： 12var scale = 1 / window.devicePixelRatiodocument.querySelector('meta[name="viewport"]').setAttribute('content', 'width=device-width, initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no' 无论任何设备，布局视口的宽度总是等于设备像素 元素跟着设备变化而等比缩放 rem：相对于html标签字体大小的单位 动态设置html字体大小： 1document.documentElement.style.fontSize = document.documentElemet.clientWidth / 10 + 'px' 注意：文字字体大小还是用px 思路：通过js动态修改meta标签使布局视口尺寸等于设计图尺寸（设备像素尺寸），再用rem代替px使得页面在不同设备中等比缩放 解决方案二： 不修改meta标签，正常使用缩放为1:1的meta标签 将页面的总宽度设置为以rem为单位的定值，如750px总宽取100px的font-size即7.5rem 1document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px' 开发页面时通过设计图尺寸/100得到rem尺寸 文字字体大小设置： 1234567891011121314151617@media screen and (max-width: 321px) &#123; body &#123; font-size: 16px &#125;&#125;@media screen and (min-width: 321px) and (max-width: 400px) &#123; body &#123; font-size: 17px &#125;&#125;@media screen and (min-width: 400px) &#123; body &#123; font-size: 19px &#125;&#125; 新的思路 沿用rem布局方案，所有布局元素与属性采用rem做单位 html设置font-size使用vw视口单位 ​]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex核心]]></title>
    <url>%2F2018%2F07%2F13%2FVuex%E6%A0%B8%E5%BF%83%2F</url>
    <content type="text"><![CDATA[在封装Hy-Vue-Admin 的登录逻辑时，对于登录状态的管理设计刚开始利用很直观的全局cookie保存状态，写起来感觉很别扭而且麻烦，参考了成熟的后台管理模板登录的逻辑以后决定使用Vue官方推荐的Vuex进行全局状态的管理： Vuex 是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 —— 官方定义 使用原因 使用Vue开发单页应用时，经常需要操作一些组件间共享的数据或状态： 应用规模较小时，可以使用 props、事件等常用的父子组件的组件间通信方法，单向数据流 应用规模较大时，即多个组件共享状态时，单向数据流的简洁性很容易被破坏： 多个视图依赖于同一状态 不同视图的行为需要变更同一状态 传统解决方式存在的问题： 对问题一：传参的方法在多层嵌套的组件下将会变得十分繁琐并且无法处理兄弟组件间状态传递的情况 对问题二：经常采用父子组件直接引用或者通过事件来变更和同步多个组件间状态的多份拷贝，这种模式非常低效，很容易导致无法维护的代码 新的思路： 将组件的共享状态抽取出来，以一个全局单例模式管理 不管在组件树的哪个位置，任何组件都能直接获取状态或者触发行为 通过定义和隔离状态管理中的各种概念并且强制遵守一定的规则，代码会更结构化且易维护 先放一张官方图~~ 核心概念State单一状态树理念，每个应用只包含一个 store 实例 Vuex 通过 store 选项将状态从根组件注入到每一个子组件中（Vue.use(Vuex)）: 12345const app = new Vue(&#123; el: '#app', store, // 把 store 对象提供给 store 选项 components: &#123; Counter &#125;&#125;) Vue 组件中获取 Vuex 状态：子组件通过 this.$store 访问到 store 实例 12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; Count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; mapState 辅助函数 与 对象展开运算符 组件仍然保有局部状态 使用 Vuex 并不是一定需要将所有的状态放入Vuex 如果有的状态严格属于单个组件，最好还是作为组件的局部状态 Mutation更改 Vuex 中的 store 中的状态的唯一方法是提交 mutation： 每个 mutation 都有一个字符串的 事件类型（type） 和一个 回调函数（handler）。回调函数就是我们实际进行状态更改的地方，并且它会默认接受 state 作为第一个参数 12345678910const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 不能直接调用一个 mutation handler，要以事件注册的理念：当触发一个类型为 increment 的mutation时，调用此函数 1store.commit('increment') 提交载荷：可以向 store.commit 传入额外的参数 Mutation 必须是同步函数：任何由 mutation 事件类型导致的状态变更都应在此刻完成 Action类似于 mutation ，区别： Action 提交的是 mutation，不是直接变更状态 Action 可以包含任意异步操作 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，即可以通过 context.commit 提交一个mutation Action 通过 store.dispatch 方法触发： 1store.dispatch('increment') Module使用单一状态树，应用的所有状态将会集中到一个很大的对象，store对象容易变得臃肿 因此，Vuex允许我们将store分割成模块，每个模块拥有自己的 state、mutation、action甚至是嵌套子模块 解决方案src 目录下写全局状态管理的代码，其中包含了 user 的状态 12345678910111213src|—— api |—— login.js # user login api接口|—— ……|—— ……|—— store |—— modules |—— user.js # store中的user module |—— getters.js |—— index.js|—— utils |—— auth.js # 对user token的相关操作 |—— request.js # axios 登录请求的拦截器 store 中的user module： Login.vue 中 点击登录分发 Action Login： user模块中actions首先调用登录接口，成功返回token后提交commit设置state token并且使用cookie保存token： 至此登录保存token状态的整体逻辑完成 退出的逻辑也与这个类似，点击退出分发action，调用退出接口返回成功状态码后提交commit设置state token为空并删除cookie，可自行阅读实现代码~]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络复习]]></title>
    <url>%2F2018%2F06%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[计算机网络相关知识的复习整理~ 概述单工、半双工、双工、串行和并行通信 单工：只有一个信道，传输方向只能单向 半双工：只有一个信道，传输方向为双向，但同一时刻只能单向传输 全双工：双信道，同时可以双向数据传输 串行通信：一组数据在一条线路上一位一位的传送 并行通信：一组数据在多条线路上同时传送 协议的三要素 语法 语义 同步 比较电路交换、分组交换、报文交换 交换方式 优点（本质/核心思想） 缺点 电路交换 （1）资源独占 （2）提供面向连接的服务 （3）通信相对可靠 （1）成本高 （2）资源利用率低 分组交换 （1）分组 （2）存储转发 （3）资源共享 （4）灵活性高，适合计算机之间的通信 （1）可靠性不高 （2）可能出现延迟和堵塞 报文交换 不分组的分组交换 比较数据报网络和虚电路网络 分组交换方式 数据报网络 虚电路网络 路由模式 源端向目的端发送分组，远端仅根据目标端选择下一条路，分组会在下一结点选择最优的下一条路，同一文件的不同分组可能沿不同的路传输 远端与目的端首先建立一条虚拟电路，结点根据分组标签确定所走的虚电路，同一文件的不同分组沿同一条虚电路传输 可靠性 不强，可能形成环路 较好 路由器工作量 相对较小 较高，需要维护每条虚电路的状态 QoS 不易实现 容易实现 使用范围 因特网 ATM、帧中继网络 特点 灵活、简单 复杂 比较面向连接和无连接服务 服务方式 面向连接 无连接 数据传输 建立连接、数据通信、释放连接 无需连接、直接通信 可靠性 可靠 不可靠，但速度快（尽最大努力服务） 传输层相应协议 TCP，电路交换，虚电路 UDP，IP，Ethernet 比较带宽、吞吐量和传播速度 带宽：网络可通过的最高数据传输速率（bit/s） 吞吐量：网络实际通过的数据传输速率 传播速度：信号在介质上的传播速率（m/s） 详细说明分组交换网的延迟有哪些及造成的原因 延迟类型 定义 原因 传输延迟 数据从结点发送到链路上所消耗的时间 网络带宽，数据大小，链路特性，网络特性 传播延迟 信号从一个结点发送到另一个结点在链路上所消耗的时间 传播介质，链路长度 结点处理延迟（排队延迟和处理延迟） 路由器上排队等待、数据处理和转发至输出链路等所消耗的时间 网络拥塞程度，转发表规模，路由器性能 ping、tracert、ipconfig、nslookup、netstat 的作用 ping和tracert均用以验证简单TCP/IP网络的连通性 ping：默认测试4次，发送ICMP请求数据包，并等待接收方的ICMP应答包，显示RTT（Round-trip time，往返时延）和TTL（Time to live，生存时间） tracert：通过TTL的递增对路由进行跟踪，测试并显示每个结点的往返时延3次 什么是互联网 互联网是网络的网络，它是将全球异构的网络互联起来的网络。互联网由许多终端设备、通信介质和中间设备组成，在TCP/IP协议簇的基础上通过各种应用程序进行通信 双绞线的制作方法（T568B和T568A） T568B：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕 T568A：白绿，绿，白橙，蓝，白蓝，橙白棕，棕 直通线和交叉线的应用 直通线：两端均为T568B，一般用于不同类设备之间 交叉线：一端为T568B、一端为T568A，一般用于相同或相近设备之间 网络为什么要分层，如何分层，分层之后如何发送和接收数据以及分层的理解 分层原因：简单、容易学习与讨论。模块化的设计便于讨论，同时也简化了维护和升级。具体表现在某个层次的服务对系统的其他层次透明，且某个层次的改变只需改变与其相邻层次的接口 OSI体系结构 TCP/IP 体系结构 各分层作用 PDU（协议数据单元） 应用层 应用层 负责各种网络应用、进程与进程之间的通信 消息 表示层 会话层 传输层 传输层 负责端到端数据的传输控制 报文段 网络层 网络层（网际层） 负责选路和不同网段数据的转发 分组 数据链路层 数据链路层 数据在一段链路上相邻结点间的传输 帧 物理层 物理层 负责信号物理通信的规则 比特流 数据的发送与接收：发送端将数据进行层层封装（应用层、传输层、网络层和数据链路层均在上一层的基础上加一首部，同时数据链路层在分组最后加一CRC冗余校验码尾部），接收端则按层次结构由下向上层层解封，获得原始数据 协议分层：协议是对两个对等实体进行通信的规则的集合，其下层为上层提供服务且对上层透明，对某层协议而言，收发双方使用的协议是相同即水平的；而各层协议间下层对上层提供的服务的接口的服务是垂直的 计算机网络通信的分层模型包含哪些地址信息？ 地址 作用 所在分层 端口（源端口、目的端口） 传输层向应用层提供的地址，以区分不同应用程序的数据 传输层 IP地址（源IP地址、目的IP地址） 网络层提供的地址，以区分不同网络间的收发双方 网络层 MAC地址（源MAC地址、目的MAC地址） 数据链路层的地址，以区分同一网络内的收发双方 数据链路层 应用层网络应用的两种模式 C/S：客户端-服务器模式，客户向服务器发送请求，服务器响应并提供服务，双方IP地址不能随意改变 P2P：对等模式，任意的主机既是客户端，又是服务器 套接字的概念 套接字=IP地址+端口号，用以唯一确定某台主机的某个进程 IP地址：IPv4为32位、IPv6为128位，用以唯一确定某台主机在因特网上的位置 端口号：16位，用以唯一确定某台主机的某个通信进程 常见网络应用的端口号（C:\Windows\System32\drivers\etc\services） 协议 端口号 传输层 定义 ftp-data 20 tcp FTP，data ftp 21 tcp FTP，control 22 tcp SSH Remote Login Protocol telnet 23 tcp smtp 25 tcp Simple Mail Transfer DNS 53 tcp、udp Domain Name Server http 80 tcp World Wide Web pop3 110 tcp Post Office protocol Version3 https 443 tcp、udp HTTP over TLS/SSL DNS的查询方式 查询方式 查询模式 区别 递归查询 正向查询 当根域名服务器不能解析时，其会直接向目标域名的授权域名服务器查询，并将结果返回给发送器请求的本地域名服务器 迭代查询 正向查询 当根域名服务器不能解析时，其会直接返回目标域名的授权域名服务器地址给发送请求的本地域名服务器，让请求方自行查询 反向查询 反向查询 通过IP地址获得相应的域名地址 URL的概念 URL，统一资源定位符，用以在整个因特网内唯一标记网上的各种文档和对象 HTTP协议概述，比较HTTP1.0和HTTP1.1 HTTP：超文本传送协议，应用层协议之一，因特网中最重要的协议之一，通常用于进行web页面的传输，采用C/S模式工作，使用TCP作为传输层协议，默认使用80端口，具体包括HTTP1.0和HTTP1.1两类 HTTP1.0：非持续连接，使用多条TCP连接获取对象，在完整收到每个对象后才发送下一个对象的请求 HTTP1.1：持续连接，在同一条TCP连接上同时发送多个页面链接的请求，并依次接收 FTP的基本概念 FTP，文件传输协议，应用层协议之一，采用C/S模式工作，使用TCP作为传输层协议，FTP属于维护状态的协议，默认使用数据端口为20，控制端口为21。使用两条连接的好处在于使FTP的控制更容易，编程更方便，且使整个传输过程中连接都不断开，更有助于状态的维护。同时当FTP传输一个文件结束后，控制连接并不断开，如果要重新下一个新文件，仅需控制连接重新协商建立新的数据连接 了解电子邮件相关的协议：smtp，pop，mime，imapDNS中RR的类型 type value A 域名对应的IP地址 NS 域名对应的权威域名服务器名称 CNAME 域名对应的别名 MX 域名对应的邮件服务器名称 PTR Name对应的名字（反向查询） 电子邮件系统的组成 用户代理：电子邮件客户端软件 邮件服务器：提供邮件服务的主机 邮件发送和接收协议 常用cmd命令 nslookup：域名查询，查询internet域名信息 ftp：传送文件 telnet：远程控制 ping：可以检查网络是否连通 tracert：用于确定IP数据包访问目标所采取的路径 netstat：查看在内核中访问网络及相关信息的程序 ipconfig：可用于显示当前的TCP/IP配置的设置值 arp：可查看局域网内IP与MAC地址的对应，静态配置记录，情况记录等 传输层比较传输层和网络层 传输层负责端到端之间的数据传输的控制。传输层依赖于网络层的服务，传输层向应用层提供服务。网络层主要为主机之间如何选路而到达目的端提供服务，而传输层加强了网络层的服务，在数据能到达对方的前提下，对数据传输进行控制，为进程间的通信提供服务 比较UDP和TCP 传输服务 可靠性 设计理念 面向连接 流量控制 拥塞控制 三次握手 协议首部 UDP 不可靠 尽力而为，可以乱序甚至丢失 否 否 否 否 TCP 可靠 必须保证数据正确、按序到达接收端。采用：序号机制、确认机制、缓存机制、重传机制、滑动窗口机制 是 是 是 是 停止等待协议的实现机制 停止等待协议：SW，发送方每发送一个报文，必须等待接收方确认后才能发送下一个报文 rdt1.0：在信道完全可靠地前提下（数据不会出错和乱序），无需做其它处理即可实现停等协议 rdt2.0：在信道可能出错的前提下（数据乱序但不会丢失），使用ACK/NAK机制，发送方建有数据缓存，当收到ACK后发送下一分组，收到NAK则重传 rdt2.1：在信道可能出错的前提下做了进一步的改进，发送方对每个分组0/1循环编号，接收方将对每个收到的分组进行确认，回复数据所编的序号；如遇到重复分组，接收方丢弃并对分组再次确认（仍回复所编序号即可）；如遇到数据错误，则回复上一次正确的确认序号 rdt3.0：在信道中数据可能乱序甚至出错的前提下，发送方在rdt2.1的基础上，进一步通过“超时”机制发现数据丢失（超时不一定数据丢失，此时编号机制仍能控制传输） 比较GBN和SR GBN和SR都属于滑动窗口协议 滑动窗口协议允许发送方在没有收到接收方的ACK的前提下发送多个数据包，因此有以下三点改变 发送方需要使用发送窗口来限制没有收到ACK情况下最多发送的数据量 发送方和接收方均增加缓存 分组序号必须增大 发送类型 发送方 接收方 累计确认 窗口大小 GBN 连续发送至窗口满，然后等待，收到接收方确认后窗口向后移动。某个分组出错或丢失则重传该分组即其后面所有已发送但未收到确认的分组 对按序到达的分组确认，对乱序或错误的分组丢弃，并发送最后一次正确收到的分组的确认 某一分组的确认意味着之前所有分组均正确 序号个数-1 SR 某个分组出错或丢失仅重传该分组 增加接收缓存（接收窗口），若收到的分组乱序则缓存该分组，等到按序后再一起提交整个缓存（因此接收缓存一般等于发送窗口大小） 不同上 序号个数/2 掌握TCP的首部字段 源端口号、目的端口号：各占2字节，端口是传输层向应用层提供服务的接口 序号：占4字节，TCP连接下数据流中的每一个字节都编上一个号，序号字段的值指的是本报文段所发送的数据的第一个字节的编号 确认号：占4个字节，是期望收到对方的写一个报文段的第一个字节的序号（下一报文段序号字段），当有数据发送给对方时顺便确认，当没有数据发送给对方时单独发一确认报文 首部长度：占4位，表示TCP首部的字节数，该字段限制了TCP首部最大值为60字节 保留：占6位，保留为今后扩展使用，目前全部置为0 特殊标记：各占1位 URG：紧急标志，值为1时有效，通知本报文段有紧急数据，应尽快传送 ACK：确认标记，值为1时有效，正常情况下只有第一次握手时为0 PSH：推送字段，值为1时，接收方在收到该报文段的数据就尽快将其交付给应用进程，而不再等到整个缓存填满 RST：复位标记，值为1时，表明TCP连接中出现严重差错（主机崩溃等），必须强行释放连接，属于单方面强行断开连接 SYN：同步标记，值为1时，表示是一个连接请求报文，正常情况下只有第一次握手和第二次握手时SYN=1，其余均=0 FIN：终止标记，值为1时，表示发送方的报文段数据已发送完毕，请求对方释放该连接，当接收方确认后，发送方将释放发送缓存 窗口：占2字节，窗口字段是流量控制的关键，用来控制对方发送窗口的大小（单位为字节），接收方根据自身的窗口大小确定自己的接收窗口大小，然后通知发送方以确定对方窗口大小的上限 检验和：占2字节，检验范围包括首部和数据两个部分，在计算检验和时，要在报文段前加12个字节的伪首部 紧急指针 选项 填充 掌握TCP的序号和确认机制 序号：TCP首部的序号基于字节。建立连接之初，发送方随机生成初始序号，之后收发双方的每个字节都对应一个编号，而TCP首部中的序号是该报文段第一个字节的编号 确认：TCP首部的确认号是期望对方发送的下一个数据的第一个字节的编号，即对方下一个报文段的序号。如果某个报文段没有携带数据，对方不需要确认即对方确认号不变，但对于特殊报文，如SYN=1的报文（建立连接），FIN=0的报文（断开连接），对方必须做确认 TCP属于累积确认，乱序到达数据会缓存 掌握TCP三次握手和断开连接的详细过程 三次握手： A-&gt;B，第一次：A随机初始化自己的序号SN（A），确认号置0，初始化窗口大小，SYN=1请求建立连接 B-&gt;A，第二次：B随机初始化自己的序号SN（B），确认号为SN（A）+1，初始化窗口大小，ACK=1表示B对A的确认，SYN=1请求建立连接 A-&gt;B，第三次：确认号为SN（B）+1，ACK=1表示A对B的确认，SYN=0 四次挥手： 正常断开 A-&gt;B，第一次：A：确认号为SN。（B）‘+1，ACK=1，FIN=1请求断开连接 B-&gt;A，第二次：B：确认号为SN（A）’+1，ACK=1 B-&gt;A，第三次：B：序号和序列号均与上一次相同，ACK=1，FIN=1请求断开连接 A-&gt;B，第四次：A：确认号为SN（B）‘+1，ACK=1 异常断开 A-&gt;B，第一次：A：确认号为SN。（B）’+1，ACK=1，RST=1请求异常中断 B-&gt;A，第二次：B：确认号为SN（A）‘+1，ACK=1 TCP的流量控制方法 首部定义了窗口大小：接收方明确通过首部窗口字段发送接收窗口大小，从而限制发送方发送窗口的最大值，而发送方保证发送窗口大小不超过对方发送的接收窗口的大小 掌握TCP的拥塞控制思想 五个特征 使用拥塞控制窗口cwnd控制发送窗口大小，发送窗口上限值=MIN（rwnd，cwnd） 分组超时则认为拥塞，反之收到确认则认为网络未拥塞 拥塞则少发（cwnd减少），未拥塞则多发（cwnd增大） 网络未知的情况下，cwnd从最小开始，收到确认后cwnd逐渐增大 为提高效率，开始增加速度快，到了一定阶段后增速变慢 慢启动阶段：窗口初始值（假设为1）指数规律增长，至慢开始门限ssthrest（假设为16），当指数增长结果大于ssthrest时，增长至ssthrest 拥塞避免阶段：从ssthrest（16）起，以线性规律增长N，直至发生超时（重回慢启动） 重回慢启动：重回窗口初始值，慢开始门限ssthrest为N值减半（N/2） 网络层网络层的作用 负责将各种不同的网络互联，负责将数据段封装成数据包，关注于分组从一个节点到另一个节点的选路 数据报网络与虚电路网络的特点与比较 数据报网络（因特网模型） 虚电路网络 是否先建立连接 在网络层无连接建立 发送分组前建立一条虚拟电路 选路 一般分组使用目标IP进行路由选择 每个分组携有标签，由标签决定下一跳 同一文件的不同分组可能走不同路径 在建立连接阶段确定固定路由，所有数据走同一路径 优点 灵活，适应性强，网络成本低 可靠，容易提供QoS，转发速度快 IP地址的发展全分类IP地址-&gt;子网掩码-&gt;无类别域间路由 全分类的IP地址 网络号位数 主机号位数 网络个数 主机个数 地址范围 A类 8 24 2^7-1 2^24-1 1.0.0.0-126.255.255.255 B类 16 16 2^14 2^16-1 128.0.0.0-191.255.255.255 C类 32 8 2^21 2^8-1 192.0.0.0-223.255.255.255 D类 224.0.0.0-239.255.255.255 特殊的IP地址 广播地址：主机号全1的地址 网络地址：主机号全0的地址 内网地址（私有地址）：10.0.0.0-10.255.255.255，172.16.0.0-172.31.255.255，192.168.0.0-192.168.255.255 链路本地地址：169.254.0.0-169.254.255.255（无IP地址时由操作系统临时分配的IP地址） 本地环回地址：127.0.0.0-127.255.255.255 本地链路广播地址：255.255.255.255 IP网络和物理网络的概念 IP网络：IP地址分为网络部分和主机部分，网络部分相同的地址属于同一个IP网络 物理网络：不经过路由器就可以直接到达的主机唯一同一个物理网络。位于同一物理网络的主机可以直接根据链路层的物理地址寻址 IP地址和物理网络的关系是多对一的，即多个IP网络可以用于同一物理网络，但同一个IP网络不可以用于多个物理网络。路由器用于转发不同IP网络的分组 定长掩码的划分和vlsm的划分 子网掩码的作用：划分子网，便于管理，提高IP地址利用率 定长掩码（FLSM）：一连串长度不变的数字，通过子网划分确定一个本地区域网路的边界 确定子网数 确定每个子网的IP数 确定子网掩码 确定每个子网的IP 由于子网定长，而子网内主机数较少，造成IP地址的浪费，当子网数过多或者单个子网内所需IP数过多时，甚至无法完成子网的划分 变长掩码（VLSM）：根据不同网段中不同的主机数使用不同长度的子网掩码，即可在某一子网（如/27）中进一步划分出若干个子网（如/30）来 注意：子网之间通信需要路由器，子网是主机号中划分的，若出现多条路由同时匹配时采用掩码最长前缀匹配原则选择路径 CIDR地址的表示和路由汇总 CIDR（无类别域间选路）：取消IP地址的分类限制，以改善IP地址的分配方式，缓解IP地址的危机。CIDR利用层次网络和路由汇总减小路由器中路由表的规模，提高转发速度 CIDR地址的IP地址由前缀和掩码决定，如10.12.1.1/12其网络号为255.240.0.0，CIDR地址进行路由匹配时采用最长前缀匹配原则 路由汇总：将连续的多个网络地址汇总为一个网络地址，与层次物理网络结合，能极大的减少路由器上路由表的规模，将多个网络汇总成一个CIDR地址块，形成“超网”，属于不精确汇总（所有属于汇总后的地址块都属于汇总前的地址块称为精确汇总，否则称不精确汇总），不精确汇总可能导致错误的路由 掌握IP协议的首部 IP协议是无连接、不可靠的协议，包括IPv4和IPv6两个版本。IPv4包括20个字节的固定首部和长度可变的可选首部 版本：占4位，表示IP协议版本，IPv4版本值为4 首部长度：占4位，表示首部的单位长度（每单位4字节），故首部最大长度为60字节 总长度：占2字节，表示首部和数据的总长度（单位为字节），故数据报的最大分组长度为65535字节（含IP首部），最大数据长度为65515字节（假设首部20字节），但总长度不允许超过MTU（最大传送单元），否则将其分片 标识：占2字节，分组超过MTU时会进行分片，同一分组的不同分片标识相同 标志：占3位，包括DF、MF两个标志。DF=1表示该分组不允许分片，MF=1表示该分组后面还有分片 片偏移：占15位，指出该分片在原分组的位置，以8个字节为单位 生存时间：占1字节，TTL，表示数据报在网络中的寿命，其单位为秒（实际单位为跳），分组每经过一个路由器TTL就减一，当路由器收到TTL=0的分组时会将其丢弃，TTL能有效的避免该分组在网络上无限循环的转发 协议：占1字节，指出数据报携带的数据使用上层的何种协议，从而帮助目的主机的网络层将数据部分上交给哪个处理过程 首部校验和：占2字节，字段只检验数据报的首部，不包括数据部分 源地址、目的地址：各占4字节，表示发送接收方的IP地址，一般路由器不会改变分组的源IP地址和目的IP地址 可选字段 填充 ICMP的基本工作原理 ICMP：Internet控制报文协议，用于因特网的传输控制和拆差错报告，主要用于分组传输过程中的异常报告，包括： 目标地址不可达 网络拥塞 TTL到期 IP分组检验和失败 注意： 对出错的ICMP差错报告报文不再发送ICMP差错报告报文 对某一分片后的分组，仅发送第一个分片的ICMP差错报告报文，后续分片不再发送 组播地址数据不发送ICMP差错报告报文 对特殊地址（如127.0.0.0或0.0.0.0）的数据不发送ICMP差错报告报文 ping使用了ICMP的回送请求与回送响应报文 tracert使用了ICMP的控制协议与TTL NAT的分类和作用 NAT：网络地址转换，用于IP地址的转换 类型 定义 缺点 比较 静态NAT 将内网数据报的源IP地址一对一的转换成外网的IP地址 无法缓解IP地址危机 静态NAT内网IP与外网IP是一一对应的，而动态NAT的地址转换是临时的 动态NAT池 将外网合法的IP地址形成可用的NAT池。内网IP需要上网时，从NAT中取一个可用的IP地址 无法使内网IP同时上网 同上 端口NAT（PAT） 服务器根据TCP/UDP端口号映射 作用： 解决多个用户使用一个公网IP上网的问题，缓解了IP地址危机 实现内部IP地址隐藏及服务器负载均衡 DHCP的基本工作原理 DHCP：动态主机设置协议，采用C/S模式，使用UDP协议工作，服务器端口号为67，客户端端口号为68，用于主机自动获得IP地址、子网掩码、网关地址、DNS服务器地址、租用期的相关信息 工作过程 服务器被动打开UDP端口67，等待客户端发来的报文 客户通过UDP端口68广播DHCP发现报文 服务器发送广播报文声明可以提供IP地址 客户广播请求IP地址 服务器广播发送IP地址、网关等，客户允许租用期内使用IP 租用期即将到期，发送续约请求。如果服务器同意则继续使用该IP，否则返回第2步重新申请 DHCP中继代理：广播DCHPREQUEST请求，中继代理单播向其他网络的DHCP服务器，获取IP地址 路由的概念及分类 概念：根据目标网络选择最“好”路径 分类：从路由获取方式可分为：直连路由、静态路由、动态路由 从路由匹配数量可分为：目标路由、特定主机路由、默认路由 比较距离向量路由算法和链路状态路由算法 距离向量路由算法和链路状态路由算法均属于动态路由协议（让路由器通过交换信息自动获得路由信息） 算法 原理 特点 范围 收敛时间 健壮性 例子 距离向量算法（DV） （1）周期性向邻居通告自己的路由信息 （2）根据邻居通告使用加法更新自己的距离向量表 （3）路由表改变时，继续通告邻居 （4） 网络中所有路由表没有改变时，算法终止 好消息传的快，坏消息传的慢（形成路由环路） 邻居之间 不稳定 不好 RIP、BGP 链路状态路由算法（LS） （1）将自己的链路状态洪泛到网络上的所有路由器 （2）每个路由器最终会知道整个网络的拓扑结构 （3）使用Dijstra最短路径算法计算自己与其他路由器最短路径，更新路由表 可能产生路由震荡 整个网络 稳定 好 OSPF 掌握rip的工作原理与配置方法 RIP使用距离向量路由算法： 使用UDP（端口520）进行传输，按固定的时间间隔交换路由信息（30s） RIP将距离定义为“跳数”，每经过一个路由器跳数加1，规定最大值为15（16即相当于不可达） 使用毒性逆转（即向某条路由对应的出接口通告该路由为无穷大路由）等方法缓解环路影响 RIP包括RIP1和RIP2： RIP1通过广播通告路由信息，不支持验证和CIDR RIP2通过组播通告路由信息，支持验证和CIDR IGP和EGP 为解决路由信息过多，更新缓慢的问题，使用自治系统（AS，由一个管理部门管理的具有相同路由策略的网络系统）管理网络系统。同一AS内的路由器使用相同的路由协议称IGP（内部网关协议），如RIP，OSPF；AS之间的路由器使用的路由协议称为EGP（外部网关协议），如BGP。网关路由器同时运行IGP和EGP OSPF路由协议 使用链路状态路由算法，无路由自环，支持区域划分适用于大规模网络，支持CIDR、VLSM，支持验证，使用组播方式发送协议报文，基于IP，为停等协议，自身可实现可靠传输，收敛速度快，链路代价为10^8/网络带宽 OSPF使用路由器标识（32位无符号整数，整个自治系统唯一）唯一确定OSPF路由器 OSPF划分区域来减少洪泛范围，其中ABR负责区域之间的信息传递，它使用距离矢量算法 OSPF支持的网络拓扑结构：广播式多点接入网络、点到点网络、点到多点网络等 在全连通网络中，选取DR（村长）和BDR，DR负责通告路由 IPv6的基本概念 版本：占4位，指明协议版本号 通信量类：占1字节，区分不同IPv6数据报或类别 流标号 有效载荷长度：占2字节，除首部外的数据长度（包括扩展首部），故最大长度为64KB 下一个首部：占1字节，相当于IPv4中的协议字段 跳数限制：占1字节，远端在数据发出时设置跳数限制，路由器每转发一次跳数减1，跳数为1时将被丢弃 源地址、目的地址：各占4字节 IPv6针对IPv4的改进 增加IP地址范围 尽可能减少路由器的额外工作 提高路由器转发分组的速度 更好的实现路由汇总 更好实现QoS提高协议的灵活性，增加了移动性和安全性 数据链路层比较数据链路层和传输层 数据链路层：负责一段链路的两端之间的通信，由网卡负责数据链路层的协议 服务层 通信 范围 服务对象 传输层 收发双方主机到主机 整个网络 应用层，端口 数据链路层 一段链路端到端 同一局域网内 物理层、MAC地址 网卡的作用 数据的封装与解封： 发送时将收到的上层分组加上首部和尾部形成以太网的帧并通过物理层发出 接收时则将收到的分组剥去首部和尾部形成分组并送交上层 链路管理 实现CSMA/CD：带冲突检测的载波监听多路访问 编码与译码：实现曼彻斯特编码与译码 比较IP地址和MAC地址 地址类型 定义 目的 长度 范围 所在TCP层 获取对方地址方式 IP地址 因特网上不同网络间能够通信的唯一地址 不同网段间的通信 IPv4：32位，IPv6：128位 广域网 网络层 DNS MAC地址 局域网中固化在硬件上的地址 同一网段内结点间通信 48位 局域网 数据链路层 ARP CRC冗余检验的计算方法以及奇偶校验 CRC冗余检验： 待校验数据除以一个约定好的除数，若能除尽则校验正确，否则出错 差错率高，能纠错 具体做法： 数据比特流看出二进制数据作为被除数D 选择一个n位的二进制数作为除数G 发送方采用异或方式D除以G得到余数R，即为CRC冗余校验码 奇偶校验：通过在数据后添加1位，保证新的数据中1有奇数个 一维奇偶校验能查错 二维奇偶校验能纠错（1位） FDMA、TDMA、CDMA 均属于信道分割技术 FDMA：频分复用 信道按频率分割成若干频段，每个站点分得固定的频段，该站点不用时相应频段被闲置浪费 TDMA：时分复用 信道根据时间分成多个固定长度的时间片，每个用户允许在不同的时间片上传输信息，某个时间片上无用户传送信息则导致信道浪费 CDMA：码分复用 大部分用于无线通信场合，用户共享相同频道，每个用户用自己的码片序列对数据编码，允许多用户共存和发送信号，对相互的干扰极小 CSMA/CD的工作原理 CSMA/CD，带冲突检测的载波监听多路访问，核心思想包括： 先听后讲：信道空闲则讲，否则等待 边听边讲：发送信号时不断检测是否碰撞 碰撞即停 退避重传：二进制指数退避算法重传 多次碰撞，放弃发送：最多16次 二进制退避算法： 确定基本退避时间，一般为争用期2τ（端到端的往返时延） 定义重传次数k（k&lt;=10） 从整数集合{0,1，……，2^k-1}中随机取一数记为r，则重传退避时延为r*2τ 重传16次仍不成功则丢弃该帧，并向高层报告 ARP的工作原理 ARP：通过IP地址获得MAC地址 工作原理： 发送方A向接收方B发送数据前，查看本地的ARP缓存表，若没有则广播发送ARP请求包 局域网内主机和网关均将A的MAC地址记入ARP缓存表，但不响应 接收方若在局域网内，B收到广播请求后向A单播发送响应ARP报文 接收方若不在局域网内，则向网关获取B的MAC地址，网关ARP缓存表中有则直接回复响应，没有则继续发送ARP请求报文 最短帧长的作用和计算方法 传统的以太网的最短帧长为64字节，从而确保碰撞帧的检测，小于64字节的帧被认为是碰撞帧，因此实际发送数据小于64字节时会被自动填充 碰撞域和广播域的判断 一个CSMA/CD网络即是一个碰撞域，基于物理层。网络设备中中继器（Repeater）和集线器（Hub）不能隔离碰撞域，网桥、二层交换机、路由器和三层交换机可以隔离碰撞域 广播域是指网段上收听送往所在网段的所有广播的所有设备的集合，基于数据链路层。只有路由器和三层交换机可以隔离广播域 交换机上有多少个端口连到了网络，就有多少个碰撞域；路由器上有多少个端口连到了网络，就有多少个广播域 MAC地址的基本特点 单播MAC地址：固化在网卡上 十六进制表示：AC-DE-48-D0-00-80 二进制表示：第八位必须为0 广播MAC地址：FF-FF-FF-FF-FF-FF 组播MAC地址：组播MAC地址通过组播IP地址后23位映射而成]]></content>
      <tags>
        <tag>Courses</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统复习]]></title>
    <url>%2F2018%2F06%2F24%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[大二下即将结束，这里将操作系统的重点概念整理一下方便复习~ 引论何谓多道程序设计？叙述它的主要特征和优点 多道程序设计是一种软件技术。该技术使同时进入计算机主存的几个相互独立的程序在管理程序控制之下相互交替执行。当某道程序因某种原因不能继续运行下去时，管理程序便将另一道程序投入运行。这样可以使中央处理器及各外部设备尽量处于忙碌状态，从而大大提高计算机的使用效率 单处理器系统中，多道程序运行特征： 多道：即计算机主存中同时存放几道相互独立的程序 宏观上并行：同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行但都未运行完毕 微观上串行：微观上主存中多道程序轮流或分时地占用处理器，即多道程序交替执行 多道程序设计的优点： 可提高CPU的利用率 可提高主存和I/O设备利用率 可增加系统吞吐量 操作系统具有哪几大特征？ 不同的操作系统都具有四个基本特征： 并发：并发性是指两个或多个事件在同一时间间隔内发生。多道程序环境下，并发性指宏观上一段时间内多道程序在同时运行；单处理器系统中，每一时刻只能执行一道程序即微观上交替执行 共享：共享是指系统中的资源可供主存中多个并发执行的进程共同使用 虚拟：指通过某种技术把一个物理实体变成若干个逻辑上的对应物 异步性：多道程序环境下允许多个进程并发执行，但由于资源等因素限制，进程是以异步方式允许的。只要运行环境相同，作业经多次运行都会获得完全相同的结果，因此异步运行是允许的 在交互性、及时性和可靠性方面比较分时系统与实时系统 交互性：分时系统交互性强，实时系统交互性弱。因为交互性强不能满足实时系统响应速度快和高可靠性的要求 及时性：实时系统要求快速响应而及时性强，分时系统相比较弱 可靠性：实时系统要求高可靠性而可靠性强，分时系统相比较弱 处理器管理何谓进程？它有哪些基本状态？列举使进程状态发生变化的事件 进程是可并发执行的程序在一个数据集上的一次执行过程，是系统进行资源分配的基本单位 进程有就绪、执行、等待三个基本状态 状态变化事件 就绪 -&gt; 执行：进程调度程序分配CPU 执行 -&gt; 等待：正在执行的进程因访问I/O设备而无法继续执行时 等待 -&gt; 就绪：因访问I/O设备正在等待的进程在访问I/O设备结束后 执行 -&gt; 就绪：正在执行的进程如因时间片用完而被暂停执行时 吧 比较进程和程序的区别 程序是指令的有序集合，是一个在时间上按严格次序前后相继的操作序列，是一个静态的概念 进程是可并发执行的程序在一个数据集上的一次执行过程，是系统进行资源分配的基本单位，它具有以下五个基本特征： 动态性：进程最基本的特性，表现为：“它由创建而产生，由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡” 并发性：多个进程实体同存于主存中，能在一段时间内同时运行；它是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的正是为了使程序能和其它进程的程序并发执行，而程序不能并发执行 独立性：进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。未建立进程的程序都不能作为一个独立的单位参加运行。进程与程序并非是一一对应的，一个程序运行在不同的数据集上就构成不同的进程 异步性：进程按各自独立的、不可预知的速度向前推进即进程按异步方式运行。这一特征导致程序执行的不可再现性，因此在操作系统中必须采取某种措施来保证各程序之间能协调运行 结构特征：进程实体在结构上由程序段、数据段、及进程控制块三部分组成，有人统称这三部分为“进程映像” 进程调度的功能有哪些？ 记录系统中所有进程的执行情况 选择占有处理器的进程 把处理器分配给进程，即进行进程上下文切换 收回处理器 进程调度的时机有哪几种？ 正在执行的进程执行完毕 执行中的进程自己调用阻塞原语将自己阻塞起来进入等待状态 执行中的进程调用了P原语操作从而因资源不足而被阻塞或调用了V原语操作激活了等待资源的进程队列 执行中的进程提出I/O请求后被阻塞 在分时系统中时间片已经用完 在执行完系统调用等系统程序后返回用户进程即系统进程执行完毕时 在可剥夺CPU执行方式时就绪队列中某进程优先级高于当前执行进程的优先级 在信号量s上作PV操作时，s&gt;0、s=0、s&lt;0时的物理意义是什么？ s &gt; 0：还有s个可用资源 s = 0：已无可用资源 s &lt; 0：已无可用资源并且还有|s|个进程在等待使用资源 若系统有同类资源m个，被n个进程共享，问：m &gt; n 和 m &lt;= n 时每个进程最多可以请求多少个这类资源使系统一定不会发生死锁？ m &gt; n：m / n （向上取整） m &lt;= n：1 何谓死锁？产生死锁的原因和必要条件是什么？ 在系统中存在一组进程（两个以上），每一个进程都占用了某种资源而又都在永久等待其中另一进程所占用的进程所占用的资源 产生原因： 竞争资源：系统中供多个进程所共享的资源不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁 进程推进顺序非法：进程在运行过程中，请求和释放资源的顺序不当导致进程死锁 四个必要条件： 互斥条件：进程应互斥使用资源，任意时刻一个资源仅为一个进程独占，若另一个进程请求一个已被占用的资源时，它被置为等待状态直到占用者释放资源 占有且等待条件：一个进程请求资源得不到满足而等待时，不释放已占有的资源 不剥夺条件：任一进程不能从另一进程那抢夺资源，即已被占用的资源只能由占用进程自己来释放 循环等待条件：存在一个循环等待链，每一个进程分别等待另一个进程所持有的资源，造成永久等待 作业管理解释作业和作业步 把用户在一次解题过程中要求计算机所做工作的集合称为一个作业 任何一个作业都要经过若干加工步骤才能得到结果，每一个加工步骤称为一个“作业步” 作业的状态分成哪几种？各种状态之间是如何转换的 通常作业分成四种状态： 提交状态：一个作业在用户手中经过输入设备进入到外存输入井，系统为其建立作业控制块 后备状态：对于已进入输入井的作业，系统将它插入到输入井后备队列中，等待作业调度程序的调度运行 运行状态：一个处于后备状态的作业，一旦被作业调度程序选中装入主存，系统就为它分配必要的软硬件资源并建立相应的进程插入到进程就绪队列中 完成状态：作业完成其全部运行过程并释放其所占全部资源而正常结束或异常终止时 叙述作业、进程和程序三者的关系 执行作业调度之前的作业是静态的，基本以文件形式存储在外部存储介质中 当作业经过作业调度的高级阶段调度后，其状态即从静态转变为动态执行状态，并为此创建了相应的作业进程，进程在经过若干次状态变更后即可完成作业功能并结束运行撤销 程序作为作业的主体部分，也是以文件形式存储在外部存储介质当中 作业调度的性能指标 CPU利用率：CPU有效运行时间与总运行时间之比 吞吐能力：单位时间内完成作业数量 周转时间：从作业被提交进入输入井开始到作业执行完成的这段时间间隔 平均周转时间：所有作业周转时间的平均值 平均带权周转时间：带权周转时间即作业的周转时间与作业的运行时间之比 存储管理分页式存储管理和分段式存储管理有何区别？ 分页和分段都采用离散分配主存方式，需要通过地址映射机构来实现地址变换 区别： 页是信息的物理单位，是系统管理的需要而不是用户的需要；而段则是信息的逻辑单位，含有一组意义相对完整的信息，分段是为了更好地满足用户的需要 页的大小固定且由系统决定，即一个系统只能有一种大小的页面；而段的长度却不固定，由用户所编写的程序决定，通常由编译程序对源程序进行编译时根据信息的性质来划分 分页式作业的地址空间是一维的，页间的逻辑地址是连续的；而分段式作业的地址空间则是二维的，段间的逻辑地址是不连续的 设备管理简述采用通道技术时，I/O操作的全过程 采用通道技术当进程提出I/O请求后： 系统首先分配通道和外设 然后按照I/O请求编制通道程序并存入主存，将其起始地址送入通道地址寄存器（CAW） 然后CPU发出“启动I/O”指令启动通道工作 启动成功后通道逐条执行通道程序中的通道指令，控制设备实现I/O操作 叙述引入缓冲的主要原因，其实现的基本思想是什么？ 主要原因： 缓和CPU与I/O设备间速度不匹配的矛盾 减少对CPU的中断频率，放宽对CPU中断响应时间的限制 提高CPU和I/O设备之间的并行性 实现方法： 采用专用硬件缓冲器 划分具有n个单元的主存缓冲区 何谓虚拟设备？简述虚拟设备的设计思想 虚拟设备是指采用相应的技术和方法将独占型设备变换为若干台对应的逻辑设备 其设计思想是将独占型设备改造为共享型设备。宏观上虽然十多个进程在同时使用一台独占型设备，但为每一个进程而言，它们都认为自己独占了一个设备 SPOOLing系统由哪些部分组成？简述它们的功能 预输入程序：把一批作业组织在一起形成作业流，由预输入程序把作业流中每个作业的初始信息由输入设备输入到输入井保存，并填写好输入表以便在作业执行中要求输入信息时可以随时找到它们的存放位置以备作业调度 井管理程序 井管理读程序：当作业请求从输入机上读文件信息时就把任务转交给井管理读程序，从输入井读出信息供用户使用 井管理写程序：当作业请求从打印机上输出结果时就把任务转交给井管理写程序，把产生的结果保存到输出井中 缓输出程序：缓输出程序负责查看输出井中是否有等待输出的结果信息，如果有则启动打印机把作业的结果文件打印输出，当一个作业的文件信息输出完毕后，将它占用的井区回收以供其它作业使用 文件管理文件系统应具有哪些功能？ 目录管理 文件的组织 文件存储空间的管理 文件操作 文件的共享、保护和保密 简述文件的结构和组织方式 逻辑结构：用户所观察到的文件组织形式，是用户可以直接处理的数据及结构，独立于物理特性构造而成。由用户构造的文件称文件的逻辑结构 无结构的流式文件 有结构的记录式文件 物理结构：文件在辅存上的存储组织形式，与存储介质的存储性能有关 顺序结构 链接结构 索引结构 文件的存取方式 顺序存取：严格按照文件中的逻辑信息单位排列的逻辑地址顺序依次读取 随机存取：按任意次序随机读写文件中的信息 按键存取：用于复杂文件系统、特别是数据库管理系统中的存取方法 链接法共享文件主要采取哪几种实现技术？比较每种实现技术的特点 目录链接技术：将共享文件的存储地址、长度等文件信息记录在文件目录项中，但链接后的目录结构变成了网状结构，使管理更复杂同时会导致删除异常和更新异常 基于索引结点的链接技术：将共享文件的存储地址、长度等文件信息记录在索引结点中，大大减少了删除异常和更新异常，但也会导致指针悬空及共享文件所有者为等待其他用户完成而付出高昂的代价 符号链接技术：通过调用系统过程“link”来创建一个LINK型新文件登记被链接的文件的路径名，优点主要体现在避免了指针悬空和实现网络环境下任意文件的共享两方面]]></content>
      <tags>
        <tag>Courses</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Nginx]]></title>
    <url>%2F2018%2F05%2F29%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANginx%2F</url>
    <content type="text"><![CDATA[之前在自己的阿里云服务器上部署了Nginx服务主要用作node服务的代理，这里看到一篇不错的文章简记一下~ 前言Nginx是一款轻量级的Web服务器及反向代理服务器，因为内存中占用少、启动极快、高并发能力强的原因，在互联网项目中广泛应用 当下流行的技术架构，nginx有点像入口网关 代理正向代理 平时我们使用梯子访问谷歌就是一个简单的正向代理的例子，正向代理“代理”的是客户端，客户端是知道目标的，但是目标不知道客户端是通过梯子访问的 反向代理 我们在外网访问百度时会进行一个转发代理到内网既是反向代理，反向代理“代理”的是服务器端，这一个过程对于客户端是透明的 Master-Worker模式启动Nginx后，就是在80端口启动了Socket服务进行监听，Nginx涉及Mater进程和Worker进程 Mater进程作用 读取并验证配置文件nginx.conf，管理worker进程 Worker进程作用 Worker进程作用：每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数有关（有利于进程切换） 热部署 热部署：配置文件nginx.conf修改以后不需要stop nginx中断请求，就能让配置文件生效结合worker进程负责处理具体的请求： 方案一：修改nginx.conf后，主进程master负责推送给worker进程更新配置信息，worker进程收到信息后更新进程内部的线程信息 方案二：修改nginx.conf后，重新生成新的worker进程，以新的配置进行处理请求，老的woker进程等它们的请求处理完毕后kill掉即可nginx采用方案二实现热部署 如何做到高并发下的高效处理 上文已经提及nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，的确有助于效率但是不够。同时处理那么多请求的问题在于，有的请求需要发生IO，可能需要很长时间，如果等着它们，就会拖慢worker的处理速度 nginx采用了Linux的epoll模型，这个模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。所以worker只需要从epoll队列循环处理即可 nginx挂了怎么办：nginx作为入口网关，如果出现单点问题显然是不可接受的 解决方案：Keepalived + Nginx keepalived 是一个高可用解决方案，主要用来防止服务器单点发生故障，可以通过和nginx配合来实现Web服务的高可用 思路： 请求不要直接打到nginx上，应该先通过Keepalived (虚拟IP) Keepalived 应该能监控nginx的生命状态（提供一个用户自定义的脚本，定期检查nginx进程状态，进行权重变化，从而实现nginx故障切换） 主战场：nginx.confnginx.conf是典型的分段配置文件 虚拟主机 把nginx作为web server来处理静态资源 location可以进行正则匹配，注意正则的几种形式以及优先级 nginx能提高速度的其中一个特性：动静分离，把静态资源放到nginx上，由nginx管理，动态请求转发给后端 在nginx下将静态资源、日志文件归属到不同域名（目录）下，方便管理维护 nginx可以进行ip访问控制，如有些电商平台，在nginx这一层就做了处理，内置一个黑名单模块反向代理 在location这一段配置中的root替换成proxy_pass即可 root说明是静态资源，可以由nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，如代理到Tomcat上 反向代理过程是透明的，比如在request-&gt;nginx-&gt;Tomcat这里对于Tomcat而言请求的ip就是nginx的地址而不是真实的request地址。好在nginx不仅仅可以反向代理请求，也可以由用户自定义设置HTTP HEADER负载均衡 在反向代理中，通过proxy_pass来指定Tomcat的地址，这里只能指定一台Tomcat，如果想指定多台来达到负载均衡呢？ 通过 upstream 来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（nginx监控这一组Tomcat的状态）等 将proxy_pass换成upstream指定的值即可 带来的问题：用户状态的保存问题，如session信息不能保存到服务器上 缓存 在配置上开启，同时指定目录，让缓存可以存储到磁盘上 参考：http://blog.51cto.com/zhangfengzhe/2064524]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flex-Grid布局]]></title>
    <url>%2F2018%2F03%2F27%2FFlex-Grid%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[关于Flex&amp;Grid布局的语法实例 Flex：更简洁制作智能布局的现代语法 w3c于09年提出的一个新的布局方案，可以方便地实现各种页面布局 移动端开发的主流：H5页面、微信小程序 对比：实现子元素在父元素水平垂直居中的效果传统定位方案：1234567891011.dad &#123; position: relative;&#125;.son &#123; position: absolute; margin: auto; top: 0; left: 0; bottom: 0; right: 0;&#125; 123456789101112131415.par &#123; background-color: red; width: 300px; height: 500px; position: relative;&#125;.child &#123; background-color: blue; width: 200px; height: 200px; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 上面两种方案都需要同时对父元素与子元素设置定位 弹性盒：12345678910111213.par &#123; background-color: red; width: 300px; height: 500px; display: flex; justify-content: center; align-items: center;&#125;.child &#123; background-color: blue; width: 200px; height: 200px;&#125; 语法详解：初始概念：主轴/纵轴(flex-direction)：默认为row：从左到右、水平排列 column：从上到下、竖直排列开始：Flex容器：父元素显式设置：display: flex Flex项目：Flex容器内的子元素实例—简易导航系统的实现：123456789101112131415161718192021222324252627282930313233343536373839404142// css部分参考html, body &#123; margin: 0; padding: 0; list-style: none;&#125;nav &#123; height: 80px; background-color: #646262; display: flex; align-items: center;&#125;ul &#123; display: flex; flex-grow: 1&#125;ul li &#123; width: 100px; margin: 10px; text-align: center; color: white;&#125;ul li:nth-child(1) &#123; margin-left: auto;&#125;ul button &#123; margin-right: auto; margin-left: 5%; width: 70px; color: white; font-size: 1em; background-color: #50cd50; cursor: pointer;&#125;ul button:hover &#123; background-color: green; transition: all .5s ease;&#125;img &#123; width: 20%; margin-left: 5%;&#125; 实例二—自适应的导航栏关键：搜索框自动填满导航栏剩余的位置实现：.search的属性设为flex: 1(flex-grow、flex-shrink、flex-basis的缩写)扩展：媒体查询：12345678910111213141516171819202122@media all and (max-width: 600px) &#123; .container &#123; flex-wrap: wrap; &#125; .container &gt; li &#123; flex: 1 1 50%; &#125; .search-input &#123; text-align: center; &#125;&#125;@media all and (max-width: 400px) &#123; .container &gt; li &#123; flex: 1 1 100%; &#125; .search-input &#123; text-align: center; &#125; .search &#123; order: 1; &#125;&#125; Grid： CSS布局的未来 二维布局 基本概念： 网格线：分界线构成了网格的结构 网格轨道：两个相邻网格线之间的空间 网格单元格：两个相邻行与相邻列之间的网格线空间 网格区域：由任意数量的网格单元格组成 网格容器属性： grid-template-columns/row：利用空格分隔的值定义网格的列与行 grid-template-areas：定义网格区域名称，从而定义网格模板 grid-(column/row)-gap：指定网格线的大小，即行列之间的宽度 justify/align-content/items：沿列/行轴对齐网格项的内容/网格 网格项属性： grid-column/row：使用特定的网格线确定网格项在网格中的位置 grid-area：对应网格模板给网格项命名 justify/align-self：沿列/行轴对应网格项中的内容 实例：自适应的首页布局：123456789101112131415161718.container &#123; height: 100%; display: grid; grid-template-columns: 1fr 5fr; grid-template-rows: 100px auto 100px;&#125;.header &#123; grid-column: 1 / -1;&#125;.menu &#123; grid-row: 2 / 3;&#125;.content &#123; grid-column: 2 / -1;&#125;.footer &#123; grid-column: 1 / -1;&#125; 参考：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.htmlhttps://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.htmlhttps://www.w3cplus.com/css3/a-complete-guide-css-grid-layout.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5&CSS3关键点]]></title>
    <url>%2F2018%2F03%2F13%2FHTML5-CSS3%E5%85%B3%E9%94%AE%E7%82%B9%2F</url>
    <content type="text"><![CDATA[工作室第七期培训第二课主讲了关于前端三大基础的知识，重点落在HTML5与CSS3上，这里做一个记录，类似的知识以后不断更新~ HTML: DOM树：浏览器解析HTML文本的形式，树上的所有节点都可以通过js访问 元素类型： 块级元素与行内元素的区别 区别一： 块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。区别二： 块级：块级元素可以设置宽高 行内：行内元素不可以设置宽高区别三： 块级：块级元素可以设置margin，padding 行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。区别四： 块级：display:block; 行内：display:inline; 可以通过修改display属性来切换块级元素和行内元素 语义化：用正确的标签做正确的事情，不仅仅让浏览器易于理解与搜索引擎解析，也要让人易于阅读 CSS： 盒模型： box-sizing设置盒模型宽度的计算规则，一般设置成border-box（IE传统盒模型） 浮动： 脱离文档流，浮动后横向排列，浮动元素总是保证自己的顶部和上一个元素（标准流中的）的底部对齐；clear只能影响使用清除的元素本身 扩展：BFC（块级格式化上下文） 浮动与清除浮动只会应用于同一个BFC内的元素 计算BFC的高度时，浮动元素也会参与计算（浮动元素的父元素高度塌陷问题） 定位：absolute: 根据最近设置定位的祖先元素排列 怎样居中一个div： 12345678910111213141516171819202122232425262728293031// 传统方案：position + transform .par &#123; background-color: red; width: 300px; height: 500px; position: relative; &#125; .child &#123; background-color: blue; width: 200px; height: 200px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;// 弹性盒（考虑兼容性）：flex .par &#123; background-color: red; width: 300px; height: 500px; display: flex; justify-content: center; align-items: center; &#125; .child &#123; background-color: blue; width: 200px; height: 200px; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Js基础笔记]]></title>
    <url>%2F2018%2F03%2F04%2FJs%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Github关于js面试题的知识整理，这里慢慢积累~ 解释事件委托事件委托是一种利用事件冒泡机制，只监听父元素而不用监听每个子元素的技术。 优点：只有父元素需要一个监听器，不需要每个子元素都去监听，减少了内存占用 ​ 避免了对子元素的繁杂处理，可以只针对父元素进行处理 例子： e.target 点击元素 e.currentTarget 当前元素 1234567891011121314151617181920212223&lt;style&gt; #par &#123; background: blue; width: 100px; height: 600px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;par&quot;&gt; &lt;div id=&quot;child1&quot;&gt;Item 1&lt;/div&gt; &lt;div id=&quot;child2&quot;&gt;Item 2&lt;/div&gt; &lt;div id=&quot;child3&quot;&gt;Item 3&lt;/div&gt; &lt;div id=&quot;child4&quot;&gt;Item 4&lt;/div&gt; &lt;div id=&quot;child5&quot;&gt;Item 5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(&quot;par&quot;) .addEventListener(&quot;click&quot;, function(e) &#123; console.log(e.target); console.log(e.currentTarget); &#125;);&lt;/script&gt; 解释js中的this如何工作关键：this的值取决于函数怎样被调用 使用了 new ，则 this 指向函数内部 123456789function Constructor() &#123; console.log(this); this.value = 10; console.log(this);&#125;new Constructor();// Constructor&#123;&#125;// Constructor&#123;value: 10&#125; 使用了 apply call 或 bind , this 指向作为参数传入的对象 12345678910function fn() &#123; console.log(this);&#125;var obj = &#123; value: 5&#125;;var boundFn = fn.bind(obj);boundFn(); // -&gt; &#123; value: 5 &#125; // 这里bind只是作为定义绑定了thisfn.call(obj); // -&gt; &#123; value: 5 &#125;fn.apply(obj); // -&gt; &#123; value: 5 &#125; 作为方法调用，如 obj.method()，this 指向这个函数属性的对象 1234567var obj = &#123; value: 5, printThis: function() &#123; console.log(this); &#125;&#125;;obj.printThis(); // -&gt; &#123; value: 5, printThis: ƒ &#125; 以上都没有，则 this 指向全局对象即 window，在严格模式下是undefined 1234function fn() &#123; console.log(this);&#125;fn(); // -&gt; Window &#123;stop: ƒ, open: ƒ, alert: ƒ, ...&#125; 以上两种以上方式，则优先级更高的规则决定 this 的值 ES6箭头函数中，this 指向函数创建时作用域的值，忽略以上所有规则 扩展：this 解释原型继承如何工作所有的js对象都有一个 prototype 属性，指向这个对象的原型对象 当一个属性被访问时，如果直接存在这个对象中则输出 如果不存在这个对象中则通过原型链去找它的原型对象，直到找到这个属性或者原型链末端 这个机制模拟了经典的继承但实际上更像是委托 对于AMD和CommonJS如何认识两种方式都是用来实现模块系统，这个概念直到ES6才在js中出现 CommonJS是同步的，为了服务端开发而设计，语法更接近于其它语言的风格，同时使用服务器端与浏览器端开发之间js切换开销也更小 AMD是异步的，支持异步加载模块，更像是为了浏览器端开发而设计，但是语法风格冗杂，而且大部分时候不是必要的，特别是js只放在一个模块包时 ES6中支持同步与异步加载模块，使得我们可以坚持用一种方法，虽然现在并没有在浏览器与Node端完全展开，但我们可以使用转换程序来转换代码 解释function foo(){}() 为什么没有像IIFE一样工作，需要修改哪些内容才能使它成为一个IIFEIIFE 的含义是立即执行函数表达式，js解析器读取 function foo(){}() 成 function foo(){} 和 () ，前者是一个函数声明而后者是一个括号尝试调用一个函数但是并没有特别声明，因此会报错 修改：(function foo() {})() or (function foo() {}()) 它们不会在全局范围内公开，所以我们甚至可以省略 foo null undefined undeclared 之间的区别，怎样检查它们 undeclared 变量是创建一个变量赋值时没有使用 var let 或 const ，这会导致它成为一个全局变量，在严格模式下会报 ReferenceError ，所以尽量避免使用，可以将它放入 try/catch块中检查 123456function foo() &#123; x = 1; // Throws a ReferenceError in strict mode&#125;foo();console.log(x); // 1 undefined 变量是已经被 declared 但是没有赋值，如果一个函数没有任何返回值也是 undefined ，可以使用 === 或者 typeof 去检查，如果使用 == 检查则 null 也会返回 true 12345678910var foo;console.log(foo); // undefinedconsole.log(foo === undefined); // trueconsole.log(typeof foo === &apos;undefined&apos;); // trueconsole.log(foo == null); // true. Wrong, don&apos;t use this to check!function bar() &#123;&#125;var baz = bar();console.log(baz); // undefined null 变量是明确地被赋值为 null 的变量，代表没有值（与undefined不同）,使用 typeof 检查返回 object, 同样必须使用 === 比较检查，否则 undefined 也会返回 true 1234var foo = null;console.log(foo === null); // trueconsole.log(foo == undefined); // true. Wrong, don&apos;t use this to check! 解释闭包，如何使用闭包是函数与函数声明时词法作用域的结合，词法的意思是词汇范围界定使用在源代码声明变量的位置来确定变量的位置(?)，闭包就是在外部函数返回以后也可以访问外部函数中变量作用域链的函数 使用场景： 用闭包实现数据隐私或是模拟private方法，模块模式中经常用到 部分应用程序嵌套调用的场合 ​ 描述 forEach 和 map 循环的区别，如何抉择forEach 遍历数组中的所有元素 每个元素都执行回调函数 没有返回值 123456const a = [1, 2, 3];const doubled = a.forEach((num, index) =&gt; &#123; // Do something with num and/or index.&#125;);// doubled = undefined map 遍历数组中的所有元素 每个元素都执行回调函数返回一个新元素，最终结果返回一个新数组 123456const a = [1, 2, 3];const doubled = a.map(num =&gt; &#123; return num * 2;&#125;);// doubled = [2, 4, 6] 主要区别：map 返回一个新数组而 forEach 不返回，即如果需要不影响原有数组的结果使用 map 更好，如果不在意原有数组的影响可以使用forEach 扩展： filter 遍历数组所有元素 每个元素执行回调函数做判断，true保留，false取出，最终返回一个过滤的数组 123let ages = data.filter((animal) =&gt; &#123; return animal.type === &apos;dog&apos;;&#125;) reduce 遍历数组所有元素 每个元素执行回调函数，至少接收两个参数，专为累加这类操作而设计，最终返回一个相加的总和 123.reduce((sum, animal) =&gt; &#123; return sum + animal.age;&#125;); 扩展阅读：map、filter、reduce 匿名函数的典例 IIFE，避免变量泄露到全局 123(function() &#123; // some code.&#125;)(); 一次性使用的回调，在调用它们的代码内部进行声明时会更具有可读与自包含性 123setTimeout(function() &#123; console.log(&quot;hei&quot;);&#125;, 1000); 函数式编程或者Loadsh的参数（类似于回调） 12345const arr = [1, 2, 3];const double = arr.map(funtion(e) &#123; return e*2;&#125;);console.log(double); 怎样组织自己的代码，比如模块模式或者经典继承一开始会使用面向对象的方式创建Backbobe模型并添加方法 但现在更好的趋势是使用基于React/Redux鼓励单向函数编程方式的Flux体系结构，使用普通对象与编写实用纯函数来操作这些对象，并且使用 actions 和 reducers 来处理状态 关于经典继承的扩展阅读 new rules 后续学深入再重新理解这个问题 ==]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP5博客搭建知识汇总]]></title>
    <url>%2F2018%2F02%2F26%2FThinkPHP5%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[工作室第七期培训后期主要以TP5搭建个人博客为主，这里将需要用到的知识笔记做个整理再加一些扩展~ ThinkPHP的核心就是MVC思想： Controller： 控制器，整个应用逻辑交互的处理 Model：模型，数据库操作的逻辑处理 View：视图，页面数据的呈现 控制器新建控制器 前台控制器目录下（application/index/controller）新建控制器文件User.php 书写User.php 12345678910&lt;?php // 声明命名空间 namespace app\index\controller; // 声明控制器 class User &#123; public function index() &#123; return &quot;User控制器下的index方法&quot;; &#125; &#125;?&gt; 地址栏访问：域名/index.php/index/User/index 注意： 控制器文件名必须首字母大写，驼峰式命名 控制器名必须跟文件名一一对应 命名空间必须和文件名对应 如果控制器名为驼峰式 UserInfo.php 1域名/index.php/index/user_info/index 控制器如何加载页面 系统View类 123456$view = new \think\View;return $view-&gt;fetch();use think\View;$view = new View();return $view-&gt;fetch(); 系统Controller类 继承系统控制器类 12use think\Controller;class User extends Controller 直接使用系统控制器类的方法 1return $this-&gt;fetch(); 系统函数 1return view(); 控制器的初始化 初始化方法必须继承系统控制器 123public function _initialize() &#123; echo &quot;初始化方法&quot;;&#125; 只要调用控制器下的任意方法，都会先找初始化方法 控制器初始化方法的使用 用来提取控制器下公共的代码 后台权限把控 页面跳转 页面跳转基于系统控制器类，所以控制器必须继承系统控制器 方法所在路径： 1www/tp5/thinkphp/library/traits/controller/Jump.php 跳转方式 成功跳转： 123// $this-&gt;success(提示信息,跳转地址,用户自定义数据,跳转跳转,header信息);// 跳转地址未设置时 默认返回上一个页面$this-&gt;success(&apos;跳转成功&apos;,url(&apos;index/index&apos;)); 失败跳转： 1$this-&gt;error(&apos;跳转失败&apos;); 跳转方法给模板页面的数据 $code 返回的状态码 1 0 $msg 页面提示信息 $wait 等待时间 $url 指定跳转页面，默认返回上一个页面 $data 用户自定义返回的数据 相关配置文件 123// 默认跳转页面对应的模板文件&apos;dispatch_success_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_jump.tpl&apos;,&apos;dispatch_error_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_jump.tpl&apos;, 修改成功、失败的模板页面 文件目录：www/tp5/thinkphp/tpl/dispatch_jump.tpl 修改成功、失败模板页面 用户自定义页面跳转模板 修改配置文件 123// 默认跳转页面对应的模板文件&apos;dispatch_success_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;success.tpl&apos;,&apos;dispatch_error_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;error.tpl&apos;, 在tpl目录下新建 success.tpl 和 error.tpl 模板 自定义书写跳转页面 重定向 作用：重定向(Redirect)就是通过各种方法将各种网络请求重新定向到其它位置 使用：12redirect(&apos;跳转地址&apos;, &apos;其他参数&apos;, code, &apos;隐式参数&apos;);$this-&gt;redirect(&apos;index/index&apos;, [&apos;id&apos;=&gt;100, &apos;name&apos;=&gt;&apos;abc&apos;]); 空操作和空控制器 空操作 1234// 主要解决一些用户恶意的地址栏输入，导致报错影响交互public function _empty() &#123; $this-&gt;redirect(&apos;index/index);&#125; 空控制器：controller目录下新建Error.php 123456789101112namespace app\index\controller;use think\Controller;class Error extends Controller &#123; public function index() &#123; $this-&gt;redirect(&apos;index/index&apos;); &#125; public function _empty() &#123; $this-&gt;redirect(&apos;index/index&apos;); &#125;&#125; 注意： 网站上线时每一个控制器都必须添加空操作 不论前台后台都需要写一个空控制器 模型新建数据模型 手动新建 打开前台模块（www/tp5/application/index） 新建model目录 在model目录下新建User.php 命令新建 切换到项目目录1php think make:model app\index\model\Users 注意 数据模型的名字建议和表名一致 如果表名与模型名不一致，可以设置表名 1protected $table = &quot;user&quot;; 如果表名有下划线，模型名使用驼峰法命名 模型的实例化 调用静态方法 123use app\index\model\User;$res=User::get(1);dump($res-&gt;toArray()); 实例化数据模型 123$user=new \app\index\model\User();$res=$user::get(2);dump($res-&gt;toArray()); 使用loader 12345use think\Loader;$user=Loader::model(&quot;user&quot;);$res=$user::get(3);dump($res-&gt;toArray()); 使用助手函数 123$user=model(&quot;user&quot;);$res=$user::get(4);dump($res-&gt;toArray()); 查询操作 单条数据 1234567891011// get方法 // 使用数字 $res=User::get(1); // 默认主键 // 使用数组 $res=User::get([&quot;name&quot;=&gt;&apos;zgg&apos;]); // 默认查找用户名 // 使用闭包函数 $res=User::get(function($query)&#123; $query-&gt;where(&quot;id&quot;,15); &#125;);// find方法 $res=User::where(&quot;id&quot;,13)-&gt;find(); 多条数据 123456789101112131415161718// all // 所有数据 $res=User::all(); // 字符串 $res=User::all(&quot;1,2,3&quot;); // 数组 $res=User::all([5,6,7]); // 数组 $res=User::all([&apos;pass&apos;=&gt;&apos;123&apos;]); // 闭包 $res=User::all(function($query)&#123; $query-&gt;where(&quot;pass&quot;,&quot;123&quot;) -&gt;whereOr(&quot;pass&quot;,&quot;456&quot;) -&gt;order(&quot;id&quot;,&quot;desc&quot;); &#125;);// select 和 all 基本类似 $res=User::select(); $res=User::limit(2)-&gt;select(); 获取值 1234// 获取某个值$res=User::where(&quot;id&quot;,5)-&gt;value(&quot;name&quot;);// 获取某列值$res=User::column(&quot;name&quot;,&quot;id&quot;); 动态查询 123// getBy字段名, 查询出第一条数据$res = User::getByName(&quot;user&quot;);dump($res-&gt;toArray()); 增加操作 设置属性 123456// 设置属性$user = new User();$user-&gt;name = &quot;user&quot;;$user-&gt;pass = 13;$user-&gt;age = 22;$user-&gt;save(); // 返回影响行数 通过data方法 1234567$user=new User();$user-&gt;data([ &quot;name&quot;=&gt;&quot;yzmedu22&quot;, &quot;age&quot;=&gt;&quot;22&quot;, &quot;pass&quot;=&gt;&quot;qwe&quot;, ]);$user-&gt;save(); // 返回影响行数 实例化时 1234567891011$user=new User([ &quot;name&quot;=&gt;&quot;yzmedu23&quot;, &quot;pass&quot;=&gt;&apos;zxc&apos;, &quot;age&quot;=&gt;20 ]);// 返回影响行数$user-&gt;save();// allowField 屏蔽掉数据库中不存在的字段$user-&gt;allowField(true)-&gt;save();// 指定插入数据库的字段$user-&gt;allowField([&apos;name&apos;,&apos;age&apos;])-&gt;save(); 获取自增的id 1dump($user-&gt;id); 增加多条数据 123456$user=new User();$list=[ [&apos;name&apos;=&gt;&quot;yzmedu33&quot;,&quot;age&quot;=&gt;33], [&apos;name&apos;=&gt;&quot;yzmedu34&quot;,&quot;age&quot;=&gt;34]];$user-&gt;saveAll($list); create方法 123$user=User::create([ &quot;name&quot;=&gt;&quot;yzmedu35&quot;, &quot;age&quot;=&gt;35 删除操作12345678910111213141516171819202122232425// $user=User::get(1);// 返回影响行数// dump($user-&gt;delete());// 删除主键2$user=User::destroy(2);// 删除主键3,4,5$user=User::destroy(&quot;3,4,5&quot;);$user=User::destroy([6,7,8]);// 删除name$user=User::destroy([&apos;name&apos;=&gt;&quot;yzmedu23&quot;]);// 删除多个条件$user=User::destroy([&apos;name&apos;=&gt;&apos;yzmedu33&apos;,&apos;age&apos;=&gt;33]);// 使用闭包$user=User::destroy(function($query)&#123; $query-&gt;where(&quot;id&quot;,&quot;&lt;&quot;,&quot;15&quot;);&#125;);// 删除数据$user=User::where(&quot;id&quot;,&quot;&gt;&quot;,&quot;19&quot;)-&gt;delete();dump($user); 修改操作123456789101112131415161718192021222324252627282930313233343536373839404142// 设置字段更新数据 $user=User::get(15); $user-&gt;age=19; $res=$user-&gt;save(); // 直接数组修改 $user=new User; $res=$user-&gt;save( [ &quot;pass&quot;=&gt;&quot;qweasd&quot;, &quot;age&quot;=&gt;16, ],[&quot;id&quot;=&gt;16]); // 修改数据 $_POST[&apos;name&apos;]=&quot;yzmedu55&quot;; $_POST[&apos;pass&apos;]=&quot;pass55&quot;; $_POST[&apos;age&apos;]=&quot;55&quot;; $_POST[&apos;sex&apos;]=&quot;nan&quot;; $_POST[&apos;id&apos;]=17; $user=new User; $res=$user-&gt;allowField([&apos;name&apos;,&apos;pass&apos;,&apos;age&apos;])-&gt;save($_POST,[&apos;id&apos;=&gt;17]); // 批量更新 $data=[ [&apos;id&apos;=&gt;15,&apos;name&apos;=&gt;&quot;abc&quot;,&apos;pass&apos;=&gt;456], [&apos;id&apos;=&gt;17,&apos;name&apos;=&gt;&quot;abc&quot;,&apos;pass&apos;=&gt;456], ]; $user=new User; $res=$user-&gt;saveAll($data); echo User::getLastSql(); // 更新操作 $user=new User; $res=$user-&gt;where(&quot;id&quot;,&apos;&gt;&apos;,&apos;17&apos;)-&gt;update([&apos;age&apos;=&gt;18]); $res=User::where(&quot;id&quot;,&quot;&lt;&quot;,&quot;18&quot;)-&gt;update([&apos;pass&apos;=&gt;&apos;zxc&apos;]); // 闭包更新数据 $user=new User; $res=$user-&gt;save([&apos;name&apos;=&gt;&apos;yunzhimeng&apos;],function($query)&#123; $query-&gt;where(&quot;id&quot;,&quot;15&quot;); &#125;); 聚合1234567891011121314151617181920212223// 统计数据条数$tot=User::count();dump($tot);// 条件判断$tot=User::where(&quot;age&quot;,&quot;&gt;&quot;,18)-&gt;count();dump($tot);// 统计最大值$max=User::max(&apos;age&apos;);dump($max);// 统计最小值$min=User::min(&quot;age&quot;);dump($min);// 平均值$avg=User::avg(&apos;age&apos;);dump($avg);// 求和$sum=User::sum(&apos;age&apos;);dump($sum); 获取器 数据模型 1234567891011121314151617// sex 的获取器public function getSexAttr($val) &#123; $status = [ &apos;0&apos; =&gt; &apos;男&apos;, &apos;1&apos; =&gt; &apos;女&apos; ]; return $status[$val];&#125;// status 获取器public function getStatusAttr($value) &#123; $status = [ &apos;0&apos; =&gt; &apos;禁用&apos;, &apos;1&apos; =&gt; &apos;正常&apos; ]; return $status[$value];&#125; 控制器 123456$user = User::all();foreach ($user as $key =&gt; $value) &#123; dump($value-&gt;toArray()); dump($value-&gt;sex); // 经过获取器的操作 dump($value-&gt;getData()); // 不经过获取器的操作&#125; 注意 字段为user_status 修改器名字为getUserStatusAttr 字段为status 修改器名字为getStatusAttr 修改器 数据模型 1234// 密码 修改器public function setPassAttr($value) &#123; return md5($value);&#125; 控制器 12345// 修改器public function setPass() &#123; $user = new User(); $res = $user-&gt;save([&apos;pass&apos;=&gt;&apos;123&apos;], [&apos;id&apos;=&gt;&apos;1&apos;]);&#125; 注意 修改器的触发条件是 save 方法 自动完成 修改器与自动完成的区别 修改器：数据赋值时自动进行转换处理 自动完成：没有手动赋值的情况下手动进行处理 自动完成123456789101112131415// 设置自动完成 无论更新操作和添加操作都会执行// protected $auto = [&apos;time&apos;, &apos;sex&apos;];protected $auto = [];protected $insert = [&apos;create_time&apos;];protected $update = [&apos;update_time&apos;];// 书写自动完成protected function setSexAttr() &#123; return 1;&#125;protected function setCreateTimeAttr() &#123; return time();&#125;protected function setUpdateTimeAttr() &#123; return time();&#125; 时间戳 系统支持自动写入创建和更新的时间戳字段 配置文件中设置 12// 自动写入时间戳字段&apos;auto_timestamp&apos; =&gt; true, 数据模型中设置 12// 设置自动写入时间戳protected $autoWriteTimestamp=true; 可以设置字段默认值 1234// 增加时间的字段protected $createTime=&apos;create_times&apos;;// 更新时间的字段protected $updateTime=&apos;update_times&apos;; 取消更新时间戳设置 1protected $updateTime=false; 视图和模板视图加载页面 继承系统控制器类param1（字符串）：模板渲染param2（数组）：模板赋值param3（数组）：模板替换param4（数组）： 1return $this-&gt;fetch(param1, 2, 3, 4); 使用助手函数：param与fetch相同 1return view(); 使用View类（不建议） 12$view = new View();return $view-&gt;fetch(); 模板赋值 控制器类中的assign方法 123$this-&gt;assign(&apos;name&apos;, $name);$this-&gt;assign(&apos;city&apos;, $city);return view(); // 加载页面 通过fetch方法 1return $this-&gt;fetch(&apos;&apos;, [&apos;name&apos;=&gt;$name, &apos;city&apos;=&gt;$city]); 助手函数 1return view(&apos;&apos;, [&apos;name&apos;=&gt;$name, &apos;city&apos;=&gt;$city]); 对象赋值 123$this-&gt;view-&gt;name = &quot;zgg&quot;;$this-&gt;view-&gt;city = &quot;ganzhou&quot;;return view(); 模板替换 配置文件更改（全局替换） 12345// 视图输出字符串内容替换&apos;view_replace_str&apos; =&gt; [ &apos;__HOMES__&apos;=&gt;&apos;/static/home/public&apos;, &apos;__ADMINS__&apos;=&gt;&apos;/static/admin/public&apos;,], 部分替换 fetch 方法 1return $this-&gt;fetch(&apos;&apos;, [], [&apos;__HOMES__&apos;=&gt;&apos;/static/home/public&apos;]); view 函数 1return view(&apos;&apos;, [], [&apos;__HOMES__&apos;=&gt;&apos;/static/home/public&apos;]); 模板渲染 12345678// 默认加载当前模块 当前控制器 当前方法对应的页面 return $this-&gt;fetch(); // 加载当前模块 当前控制器下的 用户定义页面 return $this-&gt;fetch(&apos;jiazai&apos;); // 加载当前模块 User控制器 jiazai页面 return $this-&gt;fetch(&apos;User/jiazai&apos;); 模板模板标签 普通标签 1234// 模板引擎普通标签开始标记&apos;tpl_begin&apos; =&gt; &apos;&lt;&#123;&apos;,// 模板引擎普通标签结束标记&apos;tpl_end&apos; =&gt; &apos;&#125;&gt;&apos;, 1&lt;h2&gt;&#123;$str&#125;&lt;/h2&gt; 标签库标签 1234// 标签库标签开始标记&apos;taglib_begin&apos; =&gt; &apos;&#123;&apos;,// 标签库标签结束标记&apos;taglib_end&apos; =&gt; &apos;&#125;&apos;, 123&#123;for start=&quot;1&quot; end=&quot;10&quot;&#125; &#123;$i&#125;&#123;/for&#125; 变量输出 字符串 12// 分配字符串$this-&gt;assign(&quot;str&quot;, &quot;TP5.0&quot;); 数组 123456// 分配数组$data = [ &quot;name&quot; =&gt; &quot;zgg&quot;, &quot;age&quot; =&gt; 19,];$this-&gt;assign(&quot;data&quot;, $data); 使用函数 竖线 12345678&lt;h2&gt;&#123;$pass|md5&#125;&lt;/h2&gt;&lt;!-- &lt;h2&gt;&lt;?php echo md5($pass); ?&gt;&lt;/h2&gt; --&gt;&lt;h2&gt;&#123;$time|date=&quot;Y-m-d H:i:s&quot;,###&#125;&lt;/h2&gt;&lt;!-- &lt;?php echo date(&quot;Y-m-d H:i:s&quot;,$time);?&gt; --&gt;&lt;h2&gt;&#123;$pass|md5|strtoupper|substr=0,10&#125;&lt;/h2&gt;&lt;!-- &lt;h2&gt;&lt;?php echo substr(strtoupper(md5($pass)),0,10); ?&gt;&lt;/h2&gt; --&gt; 冒号开始 12&lt;h2&gt;&#123;:md5($pass)&#125;&lt;/h2&gt;&lt;h2&gt;&#123;:date(&apos;Y-m-d H:i:s&apos;,$time)&#125;&lt;/h2&gt; 默认值 12&lt;h2&gt;&#123;$name|default=&quot;小云&quot;&#125;&lt;/h2&gt;&lt;h2&gt;&lt;?php echo (isset($name) &amp;&amp; ($name !== &apos;&apos;)?$name:&quot;小云&quot;); ?&gt;&lt;/h2&gt; 三元运算符 123&lt;h2&gt;&#123;$status?&apos;正常&apos;:&apos;错误&apos;&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$status&gt;2?&apos;正常&apos;:&apos;错误&apos;&#125;&lt;/h2&gt;&lt;h2&gt;&lt;?php echo !empty($status) &amp;&amp; $status&gt;2?&apos;正常&apos;:&apos;错误&apos;; ?&gt;&lt;/h2&gt; 运算符 1234567&lt;h2&gt;&#123;$a&#125;+&#123;$b&#125;=&#123;$a+$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a&#125;-&#123;$b&#125;=&#123;$a-$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a&#125;*&#123;$b&#125;=&#123;$a*$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a&#125;/&#123;$b&#125;=&#123;$a/$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a&#125;%&#123;$b&#125;=&#123;$a%$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a++&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$b--&#125;&lt;/h2&gt; 原样输出 123&#123;literal&#125; &lt;h2&gt;hello &#123;$name&#125;&lt;/h2&gt;&#123;/literal&#125; 系统变量 系统变量：支持输出 $_SERVER、$_ENV、$_POST、$_GET、$_REQUEST、$_SESSION、$_COOKIE 1234&lt;h1&gt;&#123;$_GET[&apos;id&apos;]&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.get.id&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$_SERVER[&apos;HTTP_HOST&apos;]&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.SERVER.http_host&#125;&lt;/h1&gt; 常量输出：详见附录 123456&lt;h1&gt;&#123;$Think.const.app_path&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.app_path&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.ds&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.think_path&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.IS_WIN&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.THINK_VERSION&#125;&lt;/h1&gt; 配置文件输出：常看配置文件 12&lt;h2&gt;&#123;$Think.config.app_namespace&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$Think.config.default_lang&#125;&lt;/h2&gt; 模板注释 12&lt;h1&gt;&#123;//$_GET[&apos;id&apos;]&#125;&lt;/h1&gt;&lt;h1&gt;&#123;/*$Think.get.id*/&#125;&lt;/h1&gt; 包含文件 12&#123;include file=&quot;Public/header&quot;&#125;&#123;include file=&quot;Public/footer,Public/footer&quot;&#125; 模板布局 视图目录下新建 layout.html layout.html 页面中将所有的公共部分保留，非公共部分使用 {__CONTENT__} 替代 {__CONTENT__} 只能存在一个 页面中如何书写123456789101112# 引入模板布局&#123;layout name=&quot;layout&quot;/&#125;# 非公共区域内容&lt;!-- 内容 --&gt;&lt;div class=&quot;col-md-10&quot;&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;img src=&quot;__ADMINS__/img/4.jpg&quot;height=&quot;310px&quot; width=&quot;100%&quot;alt=&quot;&quot;&gt; &lt;h2&gt;联想 后台管理系统&lt;/h2&gt; &lt;p&gt;开发者 ： 赵丰泰&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 模板继承 视图目录下新建 base.html base.html 中对页面进行分割 1234567&lt;div class=&quot;container&quot;&gt; &#123;block name=&quot;nav&quot;&#125;&#123;/block&#125; &lt;div class=&quot;row body&quot;&gt; &#123;block name=&quot;menu&quot;&#125;&#123;/block&#125; &#123;block name=&quot;main&quot;&#125;&#123;/block&#125; &lt;/div&gt;&lt;/div&gt; 使用继承 123456789101112&#123;extend name=&quot;base&quot; /&#125;&#123;block name=&quot;nav&quot;&#125; &#123;include file=&quot;public/nav&quot; /&#125;&#123;/block&#125;&#123;block name=&quot;main&quot;&#125; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h2&gt;联想 后台管理系统&lt;/h2&gt; &lt;p&gt;开发者 ： 赵丰泰&lt;/p&gt; &lt;/div&gt;&#123;/block&#125; 内置标签 volist 循环 name：需要遍历的数据 id：类似 foreach 中 value offset：截取数据的起始位置 length：截取数据的个数 mod：奇偶数 empty：数据为空的使用 key：编号 foreach 循环 name：需要遍历的数据 item：类似 foreach 中 value key：类似 foreach 中 key123&#123;foreach name=&quot;data&quot; item=&quot;val&quot; key=&quot;abc&quot;&#125; &lt;p&gt; &#123;$abc&#125; &#123;$val.id&#125; &#123;$val.name&#125;&lt;/p&gt;&#123;/foreach&#125; for 循环 start：开始值 end：结束值 comparison：比较条件 step：步数 name：循环变量名 默认 i1234567&#123;for start=&quot;0&quot; end=&quot;10&quot; comparison=&quot;elt&quot; step=&quot;2&quot; name=&quot;abc&quot;&#125; &lt;p&gt;&#123;$abc&#125;&lt;/p&gt;&#123;/for&#125;&#123;for start=&quot;10&quot; end=&quot;0&quot; comparison=&quot;gt&quot; step=&quot;-1&quot;&#125; &lt;p&gt;&#123;$i&#125;&lt;/p&gt;&#123;/for&#125; 比较标签 12345678&#123;eq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/eq&#125;&#123;neq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/neq&#125;&#123;lt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/lt&#125;&#123;gt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/gt&#125;&#123;egt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/egt&#125;&#123;elt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/elt&#125;&#123;heq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/heq&#125;&#123;nheq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/nheq&#125; if 12345&#123;if condition=&quot;$a eq $b&quot;&#125; &lt;p&gt;a和b数值相等&lt;/p&gt;&#123;else /&#125; &lt;p&gt;a和b数值不相等&lt;/p&gt;&#123;/if&#125; switch 12345&#123;switch name=&quot;week&quot;&#125; &#123;case value=&apos;1&apos;&#125;周一&#123;/case&#125; &#123;case value=&apos;2&apos;&#125;周二&#123;/case&#125; &#123;default /&#125; 周日&#123;/switch&#125; in 和 notin 12345&#123;in name=&quot;week&quot; value=&quot;0,1,2,3,4,5,6&quot;&#125; 合法的数据&#123;else /&#125; 不合法数据&#123;/in&#125; between 和 notbetween 12345&#123;between name=&quot;week&quot; value=&quot;0,6&quot;&#125; 合法数据&#123;else/&#125; 非法数据&#123;/between&#125; 原生PHP 123456&#123;php&#125; echo &quot;123&quot;;&#123;/php&#125;&lt;?php echo &quot;456&quot;; ?&gt; Session与CookieSession 设置 Session 12Session::set(&apos;name&apos;, &apos;zgg&apos;);session(&apos;name&apos;, &apos;100&apos;); 获取 Session 12Session::get(&apos;name&apos;);session(&apos;name&apos;); // 返回 获取到的值 NULL 判断是否设置 12Session::has(&apos;name&apos;);session(&quot;?name&quot;); // 返回 true false 删除 Session 12Session::delete(&quot;data&quot;);session(&apos;name&apos;, null); // 无返回值 清空 Session 12Session::clear();session(null); Cookie 设置 Cookie 12Cookie::set(&apos;name&apos;, &apos;zgg&apos;, 3600);cookie(&apos;name&apos;, &apos;100&apos;, 3600); 获取 Cookie 12Cookie::get(&apos;name&apos;);cookie(&apos;name&apos;); // 返回 获取到的值 NULL 判断是否设置 12Cookie::has(&apos;name&apos;);cookie(&quot;?name&quot;); // 返回 true false 删除 Cookie 12Cookie::delete(&quot;data&quot;);cookie(&apos;name&apos;, null); // 无返回值 清空 Cookie 12Cookie::clear();cookie(null); 验证器控制器中使用验证器// 实例化验证器类 $validate=new Validate( [ &quot;username&quot;=&gt;&quot;require|length:6,12&quot;, &quot;password&quot;=&gt;&quot;require|confirm:repassword&quot; ], [ &quot;username.require&quot;=&gt;&apos;用户名不存在&apos;, &quot;username.length&quot;=&gt;&apos;用户名长度不满足&apos;, &quot;password.require&quot;=&gt;&apos;密码不存在&apos;, &quot;password.confirm&quot;=&gt;&apos;两次密码不一致&apos;, ] ); // 接收用户提交的数据 $data=input(&quot;post.&quot;); // 进行验证 if ($validate-&gt;check($data)) { }else{ dump($validate-&gt;getError()); } 分页 控制器中书写： 12345$data = Db::table(&quot;user&quot;)-&gt;paginate(3);$data = Db::table(&quot;user&quot;)-&gt;paginate(3, true); // 简化版效果$this-&gt;assign(&quot;data&quot;, $data);return $this-&gt;fetch(); 页面中书写 12345678910&#123;volist name=&quot;data&quot; id=&quot;val&quot;&#125; &lt;tr&gt; &lt;td&gt;&#123;$val.id&#125;&lt;/td&gt; &lt;td&gt;&#123;$val.name&#125;&lt;/td&gt; &lt;td&gt;&#123;$val.pass&#125;&lt;/td&gt; &lt;/tr&gt; &#123;/volist&#125;&#123;$data-&gt;render()&#125;]]></content>
      <tags>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket实践]]></title>
    <url>%2F2018%2F02%2F02%2FWebSocket%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[做小程序项目的时候有实时通信的需求，这里就整理一下WebSocket的知识 关于WebSocket 前言：Web应用的信息交互过程一般是客户端通过浏览器发出一个请求，服务器端接收完请求后进行处理并且返回结果给客户端，然后客户端浏览器解析信息，这样的机制对于实时要求比较高的应用来说就有很大的受限了，因此需要有一种高效节能的双向通信机制来保证数据的实时传输，WebSocket应运而生 概念： MDN: WebSocket是一个可以创建和服务器间进行双向会话的高级技术，通过这个API你可以向服务器发送消息并接受基于事件驱动的响应，这样就不用向服务器轮询获取数据了 WebSocket有web TCP之称，顾名思义是用来通信的，作为HTML5中新增的一种通信协议，由TCP协议与编程API组成，可以在浏览器与服务器之间建立双向连接，以基于事件的方式，赋予浏览器原生的实时通信能力，从而扩展我们的web应用，提升应用性能与用户体验 为什么使用：在WebSocket出现之前有一些其它的实时通讯方案，比如轮询、长轮询、服务器发送事件 轮询(Polling)：客户端以一定的时间间隔向服务器发送请求，通过频繁请求的方式来保持客户端和服务器端的数据同步。通常采取setInterval或者setTimeout实现。问题：客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，这样很多请求就是没有必要的，浪费带宽，低效率 长轮询(Long Polling)：对定时轮询的改进和提高，当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，以此减少无效的客户端与服务器间的交互。问题：如果服务端的数据变更非常频繁的话，与定时轮询比较起来没有本质上性能的提高 服务器发送事件(Server-Sent Event)：是HTML5规范的一个组成部分，可以实现服务器到客户端的单向数据通信，通过SSE，客户端可以自动获取数据更新，而不用重复发送HTTP请求。问题：只支持到服务器到客户端单向的事件推送，而且所有版本的IE都不支持SSE WebSocket：在流量与负载量增大的情况下，相比于传统的Ajax轮询方案有极大的性能优势，在开发方面也不算复杂，只需要实例化WebSocket创建连接，成功后就可以发送相应消息了 Node实现这里采用Node的ws库来实现简单的WebSocket服务器 服务器： 1234567891011121314var WebSocketServer = require(&quot;ws&quot;).Server;var wss = new WebSocketServer(&#123; port: 3001&#125;);wss.on(&quot;connection&quot;, function(ws) &#123; ws.on(&quot;message&quot;, function(msg) &#123; console.log(msg); ws.send(&quot;Nice to meet you!&quot;); &#125;); ws.on(&quot;close&quot;, function() &#123; console.log(&quot;Stop client&quot;); &#125;);&#125;); 小程序客户端： 1234567891011121314151617181920wx.connectSocket(&#123; url: &apos;服务器的链接:3001&apos;, data: &#123;&#125;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, method: &apos;GET&apos;, success: function() &#123; console.log(&quot;客户端连接成功&quot;); &#125;&#125;),wx.onSocketOpen(function() &#123; console.log(&quot;WebSocket连接已打开&quot;); wx.sendSocketMessage(&#123; data: &apos;Hello!&apos; &#125;);&#125;),wx.onSocketMessage(function(msg) &#123; console.log(&quot;接收到：&quot;+ msg);&#125;); 这里特别提一下wx.onSocketMessage()，因为它只接收字符串和二进制类型的数据，因此如果需要发送json格式的数据就需要转换一下，只要是支持WebSocket肯定支持原生window.JSON，所以可以直接使用JSON.parse()和JSON.stringify()来转换 这样一个双向通信的实例基本就完成了]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2018%2F01%2F22%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[浏览公众号时看到一篇介绍HTTP较全的文章，这里做一个摘录总结，后续学习会不断完善改进~ 简单介绍 HTTP协议：超文本传输协议，用于从万维网服务器传输超文本到本地浏览器的传送协议，是互联网上应用最为广泛的一种网络协议，所有www文件都必须遵守的这个标准 HTTP基于TCP/IP通信协议来传送数据（HTML文件、图片文件、查询结果等） HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。于1990年提出，不断地完善和扩展 HTTP协议以客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即Web服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息 HTTP协议版本 HTTP0.9是第一个版本，请求(Request)只有一行，比如：GET www.baidu.com HTTP1.0最早于1996年在网页中使用，只是使用一些较为简单的网页和网络请求上 HTTP1.1在1999年开始广泛应用于现在的各大浏览器网络请求中，同时它也是当前使用最为广泛的协议 HTTP1.1的升级部分 缓存处理：HTTP1.0主要使用header里的If-Modified-Since,Expires来作为缓存判断的标准，而HTTP1.1则引入了更多的缓存控制策略如Entity tag,If-Unmodified-Since,If-Match,If-None-Match等更多可供选择的缓存头来控制缓存策略 带宽优化及网络连接：HTTP1.0中存在浪费带宽的现象，比如客户端只是需要某个对象的一部分但 服务器却将整个对象传送过来了，并且不支持断点续传功能；HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206(Partial Content) ，这样就方便了开发者自有的选择以便于充分利用带宽和连接 错误通知的管理：HTTP1.1中新增了24个错误状态响应码，如409(Conflict) 表示请求的资源与资源的当前状态发生冲突，410(Gone)表示服务器上的某个资源被永久性的删除 Host头处理：HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的URL并没有传递主机名(hostname),但随着虚拟主机技术的发展，一台物理服务器上可以存在多个虚拟主机，并且共享一个IP地址；HTTP1.1的请求消息和响应消息都应支持Host头域，并且请求消息中如果没有Host头域就会报告400(Bad Request)错误 长连接：HTTP1.1支持长连接(PersistentConnection)和请求的流水线(Pipelining)处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中 默认开启Connection：Keep-alive,一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点 如何建立连接(三次握手)HTTP是基于TCP协议的，浏览器最快也要在第三次握手时才能捎带HTTP请求报文，真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动，三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号 第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包,此时服务器进入SYN_RECV状态 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕后，客户端和服务器进入ESTABLISHED(TCP连接成功)状态,完成三次握手 如何关闭连接(四次挥手) 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，另一方执行被动关闭 TCP连接的拆除需要发送四个包，客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作 客户端发送一个FIN，用来关闭客户端到服务器的数据传送 服务器收到这个FIN，发回一个ACK，确认序号为收到的序号+1，和SYN一样，一个FIN将占用一个序号 服务器关闭与客户端的连接，发送一个FIN给客户端 客户端发回ACK报文确认，并将确认序号设置为收到序号+1 浏览器阻塞 浏览器对于同一个域名，一般PC端浏览器针对单个域名的server同时建立6~8个连接，手机端的连接数则控制在4~6个(根据浏览器内核的不同可能会有所差异)，超过浏览器最大连接数限制，后续请求就会被阻塞 HTTP2前述概念 SPDYSPDY协议是Google提出的基于传输控制协议(TCP)的应用层协议，通过压缩、多路复用和优先级来缩短加载时间，是一种更快加速的内容传输协议，于2009年年中发布，Chrome、FireFox、Oprea已默认开启SPDY SPDY协议设定目标 页面加载时间降低50% 无需网站作者修改任何内容 最小化配置复杂度，无需变更网络基础设施注：为了降低50%的页面加载时间，SPDY引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层TCP连接 HTTP2：SPDY升级版 HTTP-WG在2012年初提议了HTTP2.0，并吸收SPDY的经验教训在此基础上制定官方标准 HTTP2的主要目标是改进传输性能，更有效地利用网络资源，实现低延迟和高吞吐量 HTTP2致力于突破上一代标准的性能限制，也是一个扩展，之所以要递增一个大版本，主要是因为改变了客户端与服务器之间交换数据的方式 HTTP2如何提高效率 二进制分帧：HTTP2.0所有帧都采用二进制编码 帧：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位 消息：指逻辑上的HTTP消息，比如请求、响应等，由一个或多个帧组成 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符 多路复用：允许通过单一的HTTP/2连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP2不再依赖多个TCP连接去实现多流并行。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错(乱序发送)，还可以分优先级，最后再在另一端把它们重新组合。HTTP2.0连接都是持久化的，而且客户端与服务器之间只需要一个连接(一个域名一个连接)即可 请求优先级： 将HTTP消息分解为很多个独立的帧后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个31比特的优先值：0表示最高优先级，2的-31次方表示最低优先级 服务器可以根据流的优先级，控制资源分配(CPU、内存、带宽)，而在响应数据准备好之后，优先将最高优先级的帧发送给客户端 HTTP2.0解决了所有低效的问题：浏览器可以在发现资源时立即分配请求，指定每个流的优先级，让服务器决定最优的响应次序，这样请求不用排队，既节省了时间也最大限度地利用了每个连接 header压缩：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2使用encoder来减少需要传输的header大小，通讯双方各自cache一份headerfields表，既避免了重复header的传输，又减小了需要传输的大小 服务端推送： 服务器可以对一个客户端请求发送多个响应并且服务器向客户端推送资源无需客户端明确地请求 HTTP2.0连接后，客户端与服务器交换SET-TINGS帧，借此可以限定双向并发的流的最大数量 所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认猜想 服务器必须遵循请求-响应的循环，只能借着对请求的响应推送资源 服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤 HTTP2的多路复用与HTTP1.1的长连接复用有什么区别 HTTP1.0一次请求-响应，建立一个连接，用完关闭，每一个请求都要建立一个连接 HTTP1.1Pipeling解决方式为：若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等情况，后续请求只能被阻塞，毫无办法，即线头阻塞 HTTP2多个请求可同时在一个连接上并行执行，某个请求任务耗时严重也不会影响到其它连接的正常执行 如何应用到自己的项目现有任何网站和应用，无需做任何修改都可以在HTTP2.0上跑起来，HTTP服务器必须运行HTTP2.0协议，但大部分用户都不会因此受影响，NGINX的话只要在配置文件中启动相应的协议就可以了]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建Web服务器]]></title>
    <url>%2F2018%2F01%2F18%2FCentos7%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[最近在虚拟机里装了centos7来配置lamp服务器，其中踩了好多好多……坑o(╥﹏╥)o，必须做个记录 更新：nginx 与 node 的安装 centos7安装 这里就是网上下好iso镜像，然后一步步装好，建议初学者选GNONE桌面版方便操作 Apache、Mysql、PHP安装 Apacheapache软件包名称叫做httpdyum install httpd出现提示时一路 y+回车 就好 启动Apache并将其设置为开机启动 systemctl start httpd.service systemctl enable httpd.service 检查httpd服务状态： systemctl status httpd.service 看到绿色的active(running)表示httpd服务正在运行中，enabled 表示httpd服务已设为开机启动 这样HTTP协议就启动了，因为它要用到端口80，因此防火墙要放通80，这里直接就关掉它 systemctl stop firewalld.service 停止firewall systemctl disable firewalld.service 禁止开机启动 现在可以通过ip addr查询当前系统ip地址，在浏览器访问就可以看到apache页面 Tips: 这里可以将虚拟机内部ip配置为静态的，然后修改主机hosts文件对应别名如myserver之后即可通过http://myserver直接访问 PHPyum install php这里有需要的话可以进入/etc/php.ini做一些配置的修改测试Apache能不能正常调用php，在/var/www/html目录下新建一个输出phpinfo的文件vim /var/www/html/phpinfo.php使用浏览器打开可以看到php信息页则说明正常然后安装常用的扩展yum -y install php-mysql php-gd php-imap php-ldap php-mbstring php-odbc php-pear php-xml php-xmlrpc Mysql这里推荐安装MariaDB(从RHEL 7开始Red Hat公司推荐使用它替换Mysql)yum install mariadb-server mariadbsystemctl start mariadb 启动mariadbsystemctl enable mariadb 设置为开机启动 这里可以启动数据库守护进程 mysql_secure_installation 用来设置root密码，允许远程root登录等等 mysql -u root -p使用root账号登录mariadb show mysql切换到mysql GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION; 修改登录权限设置为允许远程登录 配置apache虚拟目录apache默认工程目录是在/var/www下的，而编辑该目录必须是root用户，因此我们有必要自定义一个目录，让apache也能识别vim /etc/httpd/conf/httpd.conf打开apache配置文件找到&lt;dir alias_module&gt;，在内部添加1234567示例：Alias /myweb &quot;/home/daybreak/www&quot;&lt;Directory &quot;/home/daybreak/www&quot;&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt; 这里我的自定义路径为/home/daybreak/www，对应别名是myweb，在浏览器输入http&quot;//myserver/myweb就能对真实目录/home/daybreak/www下文件进行访问 注意：这里直接访问后很可能会出现403forbidden的错误，解决方案如下 确保配置虚拟目录时设置了目录访问权限即Require all granted 到这里可能是网站目录的权限问题，apache要求目录具有执行权限，也就是x，所以要确保访问的目录树都具有这些权限，例如我的目录时/home/daybreak/www，则需要 1234chmod 755 /homechmod 755 /home/daybreakchmod 755 /home/daybreak/www或者直接 chmod 755 -R /home 如果依然是403，那就是selinux的问题，把目录进行一下selinux权限设置chcon -R -t httpd_sys_content_t /home 这样访问成功后就可以通过自定义的目录访问web文档 扩展：nginx 与 node 的安装nginx 安装 添加 centos7 nginx yum 资源库： 1sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm yum 安装： 1sudo yum install -y nginx 启动并且开机启动nginx： 1sudo systemctl start nginx &amp;&amp; sudo systemctl enable nginx 测试nginx配置文件（查看nginx配置位置）： 1nginx -t node 安装 使用官方编译的二进制数据包安装： 进入官网下载链接，选择想要下载的版本链接与版本(*-linux-x64.tar.gz)，进入用户主目录使用 wget 命令下载： 1wget https://nodejs.org/download/release/v8.9.4/node-v8.9.4-linux-x64.tar.gz 下载完成后解压到 /usr/local 目录并安装： 1sudo tar --strip-components 1 -xzvf node-v* -C /usr/local 安装完成后验证安装： 12node -vv8.9.4 源码安装： 使用源码安装与二进制数据包安装的区别在于源码安装还需要编译源码才能安装 进入官网下载链接，选择版本(node-v*.tar.gz)： 1wget https://nodejs.org/download/release/v8.9.4/node-v8.9.4.tar.gz 下载完成后，解压并进入解压后的目录 1tar xzvf node-v8.9.4.tar.gz &amp;&amp; cd node-v8.9.4 编译源码需要安装 gcc 和 gcc-c++ (可先使用yum info package_name 检查是否已安装)： 1sudo yum install gcc gcc-c++ 安装完成后运行 configure 文件并编译，编译完成后安装： 1./configure &amp;&amp; make &amp;&amp; make install ​]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步JavaScript请求]]></title>
    <url>%2F2017%2F12%2F29%2F%E5%BC%82%E6%AD%A5JavaScript%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[在Udacity上系统学了异步JavaScript请求的课程，这里结合之前自己的理解做一个总结~ Ajax与XHR在JavaSctipt中发出异步HTTP请求的步骤： 使用XMLHttpRequest构造函数创建XHR对象 使用.open()方法-设置HTTP方法和要获取的资源的URL 设置.onload()属性-将此属性设为成功获取数据后将运行的函数 设置.onerror()属性-将此属性设为出现错误后将运行的函数 使用.send()方法-发送请求 使用响应： 使用.responseText属性-存储异步请求响应的文本 XMLHttpRequest：简称XHR，它提供了向服务器发送请求和解析服务器响应流畅的接口，可以以异步方式从服务器获得更多的信息IE6及以下不能直接通过XHR对象实例化XMLHttpRequest，兼容性实现如下：1234567891011121314151617181920function createXHR() &#123; if(typeof XMLHttpRequest != &apos;undefined&apos;) &#123; return new XMLHttpRequest(); &#125; else if(typeof ActiveXObject != &apos;undefined&apos;) &#123; var versions = [ &apos;MSXML2.XMLHttp.6.0&apos;, &apos;MSXML2.XMLHttp.3.0&apos;, &apos;MSXML2.XMLHttp&apos; ]; for(var i = 0; i &lt; versions.length; i++) &#123; try&#123; return new ActiveXObject(versions[i]); &#125; catch(e) &#123; // 跳过 &#125; &#125; &#125; else &#123; throw new Error(&apos;你的浏览器不支持XHR对象！&apos;); &#125;&#125; GET与POST： Ajax使用时，GET的使用频率高于POST，了解一下HTTP头部信息，包含服务器返回的响应头信息和客户端发出去的请求头信息 GET请求： 最常用的请求类型，常用于向服务器查询某些信息，在.open()方法的第二个参数可以通过URL后的问号给服务器传递键值对数据，服务器接收到以后就会返回响应数据，用encodeURIComponent()进行编码处理解决特殊字符传参产生的问题POST请求： 多用于表单提交时，通过.send()方法向服务器提交数据，同时一般POST请求还需要用XHR来模仿表单提交xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); 性能上说POST请求比GET请求消耗更多，相同数据下，GET请求最多比POST快两倍 封装Ajax：1234567891011121314151617181920212223242526272829303132333435363738394041// 名值对编码function params(data) &#123; var arr = []; for(var i in data) &#123; arr.push(encodeURIComponent(i) + &apos;=&apos; + encodeURIComponent(data[i])); &#125; return arr.join(&apos;&amp;&apos;);&#125;function ajax(obj) &#123; var xhr = new createXHR(); obj.url = obj.url + &apos;?rand=&apos; + Math.random(); obj.data = params(obj.data); if(obj.method === &apos;get&apos;) &#123; obj.url = obj.url.indexOf(&apos;?&apos;) == -1 ? obj.url + &apos;?&apos; + obj.data : obj.url + &apos;&amp;&apos; + obj.data; &#125; if(obj.async === true) &#123; xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) callback(); &#125; &#125; xhr.open(obj.method, obj.url, obj.async); if(obj.method === &apos;post&apos;) &#123; xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;); xhr.send(obj.data); &#125; else &#123; xhr.send(); &#125; if(obj.async === false) callback(); function callback() &#123; if(xhr.status == 200) &#123; obj.success(xhr.responseText); &#125; else &#123; console.log(&apos;数据返回失败！状态代码：&apos; + xhr.status + &apos;，状态信息：&apos; + xhr.statusText); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Web性能优化]]></title>
    <url>%2F2017%2F12%2F02%2FWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在书上看到了关于Web性能优化方面的知识，这里先记录下来，方便以后加以实践~ Web性能优化分为服务器端和浏览器端两个方面： 压缩源码和图片► JavaScript文件源代码可以采用混淆压缩的方式► CSS文件源码可以进行普通压缩► JPG图片可以根据具体质量来压缩为50%-70%► PNG可以使用一些开源压缩软件来压缩，比如24色变成8色、去掉一些PNG格式信息等 选择合适的图片格式► 如果图片颜色数较多就使用JPG格式► 如果图片颜色数较少就使用PNG格式► 如果能够通过服务器端判断浏览器支持WebP，就使用WebP格式和SVG格式 合并静态资源► 包括CSS、JavaScript和小图片，减少HTTP请求 开启服务器端的Gzip压缩► 对于文本资源非常有效，对图片资源则没那么大的压缩比率 使用CDN► 或者一些公开库使用第三方提供的静态资源地址（比如jQuery、normalize、css）。一方面增加并发下载量，另一方面能够和其他网站共享缓存 延长静态资源缓存时间► 这样频繁访问网站的访客就可以更快地访问。但是这里要通过修改文件名的方式，确保资源更新的时候，用户会拉取到最新的内容 把CSS放在页面头部，JavaScript放在页面底部► 这样就不会阻塞页面渲染，让页面出现长时间的空白]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作]]></title>
    <url>%2F2017%2F11%2F30%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[随着做项目的深入，对Git的使用也越来越频繁，这里就做一个常用操作的总结，不断更新~ Git理念► 工作区（即本地文件）► 暂存区► 本地仓库► 远程仓库 使用Git项目的文件都是在上面四个地方传递 本地项目关联远程仓库远程库建好以后就可以运行这条命令关联到本地项目：git remote add origin your-remote-repository-url 如果是直接克隆远程仓库到本地的话：git clone your-remote-repository-url 可以运行以下命令查看结果： git remote -v 查看当前项目的远程库git branch -a 查看当前项目的所有分支 远程库同步到本地► 在提交更新以前都要先同步一下本地仓库1git pull 等同于 git fetch + git merge 如果需要放弃本地修改，强制覆盖本地版本的话（即保持与远程库一致）：123git fetch --allgit reset --hard origin/mastergit pull 提交本地更新到远程库git status 检查当前项目状态 然后对于未跟踪的文件执行以下命令： 123git add untrack-file-path 跟踪单个本地文件，提交到暂存区git commit -m &quot;your commit&quot; 将跟踪过的文件即在暂存区的文件提交到本地仓库git push 将本地仓库提交到远程库 提交到远程库常用的命令还有： git add . 跟踪本地所有未跟踪的文件git push -f 强制提交更新，覆盖远程库 — 慎用！！！ 版本回退► 将当前版本回退到已提交的版本历史中git reset --hard HEAD^ 一个^号代表回退一个版本 更多时候我们都会找到对应的版本号进行回退：首先 git log 显示最近到最远的提交日志如果只想显示版本号和评论信息的话可以加上 --pretty=oneline 参数现在就可以 git reset --hard version number 回退到对应的版本 这里还有一个常用命令：git reflog 显示你的每一次命令，对于自己命令的整理很有帮助 检查修改► 已修改，未暂存git diff ► 已暂存，未提交git diff --cached ► 已提交，未推送git diff master origin/master 撤销修改► 向commit中添加忘记的文件(即更新最近的commit) 编辑文件 保存文件 暂存文件 git commit --amend ► 还原commitgit revert &lt;SHA&gt; 撤销目标commit做出的更改，同时创建一个新的commit记录这一更改 ► 重置commitgit reset &lt;reference&gt; 清除commit 将HEAD和当前分支指针移到引用的commit 使用--hard选项清除commit 使用--sort选项将commit的更改移至暂存区 使用--mixed选项取消暂存已被commit的更改 ► 已修改，未暂存git checkout -- file-path ► 已暂存，未提交git reset HEAD file-path 先撤销暂存区的修改git checkout -- file-path 再撤销工作区的修改 PS: 以上两个步骤都可以用 git reset --hard 完成，一步到位将修改完全恢复到未修改的状态 ► 已提交，未推送git reset --hard origin/master 从远程库将代码取回 ► 已推送git reset --hard HEAD^ 先回退本地库的版本git push -f 再强制推送到远程库 分支与合并git branch ： 列出仓库中所有的分支名称 — 活跃分支旁会显示一个星号 创建新的分支 删除分支 — 无法删除当前所在的分支 git checkout 切换分支，可以创建新的分支，-b选项可以附加切换到该分支 git log --oneline --decorate 显示日志中的分支git log --oneline --decorate --graph --all 显示实际的所有分支 git merge &lt;other-branch&gt; 合并分支 发生合并时，git将： 查看将合并的分支 查看分支的历史记录并寻找两个分支的commit历史记录都有的单个commit 将单个分支上更改的代码行合并到一起 提交一个commit来记录合并操作 合并有以下两种类型： 快进合并-要合并的分支位于检出分支前面。检出分支的指针将向前移动，指向另一分支所指向的同一commit 普通类型的合并 两个完全不同的分支被合并 创建一个合并commit 合并冲突：当相同的行在要合并的不同分支上做出了更改时，就会出现合并冲突。解决： 找到并删掉存在合并冲突指示符的所有行 决定保留哪些行 保存文件 暂存文件 提交commit]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验参考]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[逐步补上之前的数据结构实验代码，之后也会不断完善，仅供参考(^▽^) 顺序表链表的创建输出及两种有序表的合并 对于顺序表和单链表定义不同的结构体，顺序表通过下标创建并输出链表为带头结点的单链表，使用尾插法创建并输出 从头开始遍历两个升序表，将更大的存入第三个表中，并将其标记后移对于单链表，需要使用头插法插入第三个单链表中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 顺序表的创建输出及两个升序表合并成一个升序顺序表*/#include&lt;stdio.h&gt;#include&lt;math.h&gt;typedef struct &#123; int a[100]; int len;&#125;list;void inputList(list *L) &#123; int x, i = 0; printf(&quot;输入一串数(以-1结束)：&quot;); while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123; L-&gt;a[i] = x; i++; &#125; L-&gt;len = i;&#125;void printList(list *L) &#123; printf(&quot;\n线性表为：&quot;); int i; for(i = 0; i &lt; L-&gt;len ; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125; printf(&quot;\n&quot;);&#125;void insertList(list *L, int x) &#123; int i; for(i = L-&gt;len-1; i &gt; 0 &amp;&amp; L-&gt;a[i] &gt; x; i--) &#123; L-&gt;a[i+1] = L-&gt;a[i]; &#125; L-&gt;a[i+1] = x; L-&gt;len++;&#125;void mergeDoubleUp(list *L1, list *L2, list *L3) &#123; int i = 0, j = 0, tail = 0; while(i &lt; L1-&gt;len &amp;&amp; j &lt; L2-&gt;len) &#123; if(L1-&gt;a[i] &lt; L2-&gt;a[j]) &#123; L3-&gt;a[tail] = L1-&gt;a[i]; i++; &#125; else &#123; L3-&gt;a[tail] = L2-&gt;a[j]; j++; &#125; tail++; &#125; while(i &lt; L1-&gt;len) &#123; L3-&gt;a[tail] = L1-&gt;a[i]; i++; tail++; &#125; while(j &lt; L2-&gt;len) &#123; L3-&gt;a[tail] = L2-&gt;a[j]; j++; tail++; &#125; L3-&gt;len = tail;&#125;int main() &#123; list L1, L2, L3; inputList(&amp;L1); inputList(&amp;L2); mergeDoubleUp(&amp;L1, &amp;L2, &amp;L3); printList(&amp;L3); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* 单链表的创建输出、两个升序链表合并为一个降序链表*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct k &#123; int data; struct k *next;&#125;node;void createList(node *h) &#123; node *p, *tail; tail = h; int x; printf(&quot;输入一串数(以-1结束)：&quot;); while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123; p = (node *)malloc(sizeof(node)); p-&gt;data = x; p-&gt;next = NULL; tail-&gt;next = p; tail = p; &#125;&#125;void printList(node *h) &#123; node *p; for(p = h-&gt;next; p != NULL; p = p-&gt;next) &#123; printf(&quot;%d &quot;, p-&gt;data); &#125;&#125;void mergeDoubleDown(node *h1, node *h2, node *h3) &#123; node *i, *j, *head; i = h1-&gt;next; j = h2-&gt;next; while(i != NULL &amp;&amp; j != NULL) &#123; if(i-&gt;data &lt; j-&gt;data) &#123; head = i; i = i-&gt;next; &#125; else &#123; head = j; j = j-&gt;next; &#125; // 头插法建立h3链表 head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125; // 尾部处理 while(i != NULL) &#123; head = (node *)malloc(sizeof(node)); head-&gt;data = i-&gt;data; i = i-&gt;next; head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125; while(j != NULL) &#123; head = (node *)malloc(sizeof(node)); head-&gt;data = j-&gt;data; j = j-&gt;next; head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125;&#125;int main()&#123; node h1, h2, h3; h1.next = NULL; h2.next = NULL; h3.next = NULL; createList(&amp;h1); createList(&amp;h2); printf(&quot;\n链表1为&quot;);printList(&amp;h1); printf(&quot;\n链表2为&quot;);printList(&amp;h2); mergeDoubleDown(&amp;h1, &amp;h2, &amp;h3); printf(&quot;\n链表3为&quot;);printList(&amp;h3); return 0;&#125; 顺序表的排序及单链表求最值 通过两次循环，默认为升序，如果第一次循环出现降序则进入第二次循环，第二次循环若出现升序则说明无序 设置两个标记分别从两边遍历，左为奇数时左标记继续，右为偶数时右标记继续，直到左为偶数右为奇数时则交换 设置当前标记和前驱标记遍历整个单链表，并通过预设的最大标记指针和最大前驱标记指针不断比较，遍历完最大标记指针就指向最大值 123456789101112131415161718192021222324252627282930313233343536373839404142/* 判断顺序表是否有序、实现奇偶分开、实现选择排序算法*/int isSort(sort *L) &#123; // 返回-1说明无序，1则有序 int i, j; // 两次循环判断 for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123; if(L-&gt;a[i] &gt; L-&gt;a[j]) &#123; for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123; if(L-&gt;a[i] &lt; L-&gt;a[j]) return -1; &#125; &#125; &#125; return 1;&#125;void divert(sort *L) &#123; int i = 0, j = L-&gt;len-1; while(i &lt; j) &#123; while(L-&gt;a[i] % 2 != 0) i++; while(L-&gt;a[j] % 2 == 0) j--; if(i &lt; j) &#123; int temp = L-&gt;a[i]; L-&gt;a[i] = L-&gt;a[j]; L-&gt;a[j] = temp; &#125; else break; &#125;&#125;void selectSort(sort *L) &#123; int i; for(i = 0; i &lt; L-&gt;len; i++) &#123; int min = i, j; for(j = i; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] &lt; L-&gt;a[min]) min = j; &#125; int temp = L-&gt;a[min]; L-&gt;a[min] = L-&gt;a[i]; L-&gt;a[i] = temp; &#125;&#125; 123456789101112131415161718/* 选出单链表的最大值并移至末尾*/void removeMax(node *h) &#123; node *pre, *p, *preMax, *max; preMax = h; max = preMax-&gt;next; pre = preMax-&gt;next; p = max-&gt;next; for(; p != NULL; p = p-&gt;next, pre = pre-&gt;next) &#123; if(p-&gt;data &gt; max-&gt;data) &#123; preMax = pre; max = p; &#125; &#125; preMax-&gt;next = max-&gt;next; pre-&gt;next = max; max-&gt;next = NULL;&#125; 带头指针型单链表及模式匹配算法 头指针型单链表创建时对于第一个输入单独造头结点，之后与带头结点型单链表相同 采用递归不断分解直到达最后一个结点输出 从头开始遍历文本串t，同时不断跟模式串p匹配直到成功或遍历结束匹配失败 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 创建输出头指针型单链表、合并两个升序头指针型单链表为降序、将单链表从尾至首输出*/node *createList() &#123; int x; node *h, *p, *tail; printf(&quot;输入一串数(以-1结束)：&quot;); /* 造头结点 */ scanf(&quot;%d&quot;, &amp;x); if(x == -1) return; h = (node *)malloc(sizeof(node)); h-&gt;data = x; h-&gt;next = NULL; tail = h; scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; p = (node *)malloc(sizeof(node)); p-&gt;data = x; p-&gt;next = NULL; tail-&gt;next = p; tail = p; scanf(&quot;%d&quot;, &amp;x); &#125; return h;&#125;void printList(node *h) &#123; printf(&quot;链表为：&quot;); node *p; for(p = h; p != NULL; p = p-&gt;next) &#123; printf(&quot;%d &quot;, p-&gt;data); &#125; printf(&quot;\n&quot;);&#125;node *mergeDoubleDown(node *h1, node *h2, node *h3) &#123; node *i, *j, *k; i = h1; j = h2; while(i != NULL &amp;&amp; j != NULL) &#123; if(i-&gt;data &lt; j-&gt;data) &#123; k = i; i = i-&gt;next; k-&gt;next = h3; h3 = k; &#125; else &#123; k = j; j = j-&gt;next; k-&gt;next = h3; h3 = k; &#125; &#125; // 尾部处理 while(i != NULL) &#123; k = i; i = i-&gt;next; k-&gt;next = h3; h3 = k; &#125; while(j != NULL) &#123; k = j; j = j-&gt;next; k-&gt;next = h3; h3 = k; &#125; return h3;&#125;void revPrintList(node *h) &#123; if(h-&gt;next != NULL) &#123; revPrintList(h-&gt;next); &#125; printf(&quot;%d &quot;, h-&gt;data);&#125; 12345678910111213141516171819202122232425262728/* 朴素的模式匹配算法*/void creStr(seqString *s) &#123; char x; int i = 0; while((x = getchar()) != &apos;\n&apos;) &#123; s-&gt;str[i] = x; i++; &#125; s-&gt;len = i;&#125;int simpleMatch(seqString t, seqString p) &#123; int i; for(i = 0; i &lt; t.len; i++) &#123; if(success(t, p, i)) return i; &#125; return -1;&#125;int success(seqString t, seqString p, int i) &#123; int j; for(j = 0; j &lt; p.len; j++) &#123; if(t.str[i+j] != p.str[j]) return 0; &#125; return 1;&#125; 稀疏矩阵的转置与递归程序设计 首先将行列数与非零元数存入第一个三元组，再根据输入将非零元存入对应位置快速转置时需要一遍扫描填入非零元所在的新位置数组，之后一步转置 递归时传入空格的个数作为参数，将空格作为数字 递归分解整体成第一个和其余个数为两部分进行比较返回比较结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* 稀疏矩阵的创建输出、朴素转置与快速转置*/typedef struct &#123; int r, c, e;&#125;SYZ; void inputMatrix(SYZ ma[]) &#123; int i = 0, m = 0, n = 0, r = 0, c = 0, e = 0; printf(&quot;输入行数和列数(m n)：&quot;); scanf(&quot;%d %d&quot;, &amp;m, &amp;n); ma[0].r = m; ma[0].c = n; printf(&quot;\n输入三元组(格式如3 4 5), 以回车分隔, 输入0 0 0结束：\n&quot;); scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e); while(r != 0) &#123; i++; ma[i].r = r; ma[i].c = c; ma[i].e = e; scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e); &#125; ma[0].e = i;&#125;void printMatrix(SYZ m[]) &#123; int i, j; int k = 1; printf(&quot;\n矩阵为：\n&quot;); for(i = 1; i &lt;= m[0].r; i++) &#123; for(j = 1; j &lt;= m[0].c; j++) &#123; if(k &lt;= m[0].e &amp;&amp; m[k].r == i &amp;&amp; m[k].c == j) &#123; printf(&quot; %d &quot;, m[k].e); k++; &#125; else printf(&quot; 0 &quot;); &#125; printf(&quot;\n&quot;); &#125;&#125;void generalTrans(SYZ ma[], SYZ mb[]) &#123; if(ma[0].e == 0) return; // 行列维数互换 mb[0].r = ma[0].c; mb[0].c = ma[0].r; mb[0].e = ma[0].e; // 扫描ma三元组,依次加到mb中 int k, col, e; for(k = 1, col = 1; col &lt;= ma[0].c; col++) &#123; for(e = 1; e &lt;= ma[0].e; e++) &#123; if(ma[e].c == col) &#123; mb[k].r = ma[e].c; mb[k].c = ma[e].r; mb[k].e = ma[e].e; k++; &#125; &#125; &#125;&#125;void fillNum(SYZ m[], int num[]) &#123; // 计算不同元素的个数, 存入num[] int i, k; for(i = 0; i &lt;= m[0].c; i++) num[i] = 0; for(i = 0; i &lt;= m[0].e; i++) &#123; k = m[i].c; num[k]++; &#125;&#125;void fillPos(int num[], int pos[], int len) &#123; pos[1] = 1; int k; // 从2到原列数 for(k = 2; k &lt;= len; k++) pos[k] = pos[k-1]+ num[k-1];&#125;void quickTrans(SYZ ma[], SYZ mb[]) &#123; // 一遍扫描，获取num[]和pos[] int num[20], pos[20]; fillNum(ma, num); fillPos(num, pos, ma[0].c); // 一步转置 int i, k, c; mb[0].r = ma[0].c; mb[0].c = mb[0].r; mb[0].e = mb[0].e; for(i = 1; i &lt;= ma[0].e; i++) &#123; c = ma[i].c; k = pos[c]; mb[k].r = ma[i].c; mb[k].c = ma[i].r; mb[k].e = ma[i].e; pos[c]++; &#125;&#125; 123456789101112131415/* 递归打印数字金字塔*/void printTriangle(int j, int n) &#123; if(n &lt;= 0) return; printTriangle(j+1, n-1); // 打印第n行 int i; printf(&quot;\n&quot;); for(i = 0; i &lt; j; i++) printf(&quot; &quot;); for(i = 1; i &lt;= n; i++) printf(&quot;%3d&quot;, i); for(i = n-1; i &gt;0; i--) printf(&quot;%3d&quot;, i);&#125; 1234567891011121314151617/* 递归查找顺序表元素下标、最大值下标*/int find(List L, int i, int j, int x) &#123; if(i &gt; j) return -1; if(L.arr[i] == x) return i; else return find(L, i+1, j, x);&#125;int findMax(List L, int i, int j) &#123; if(i &gt; j) return -1; if(i == j) return i; int k = findMax(L, i+1, j); if(L.arr[i] &gt; L.arr[k]) return i; else return k;&#125; 创建二叉树及前中后序遍历输出 输入字母，#代表NULL，然后先建左子树，再建右子树 前序递归先输出根的值再遍历左子树，最后遍历右子树；中序递归先遍历左子树，再输出根值，再遍历右子树；后序递归先遍历左、右子树，再输出根值 前序非递归需要先输出根值，然后保存回溯点，再进入左子树，到底后根据回溯点进入右子树；而后序非递归需要先保存回溯点，进入左子树，然后再输出回溯点值，进入右子树 1234567891011121314151617181920/* 创建二叉树*/typedef struct k&#123; char data; struct k *L, *R;&#125;bTree;bTree *creaTree() &#123; bTree *t; char c = getchar(); if(c == &apos;#&apos;) return NULL; t = malloc(sizeof(bTree)); t-&gt;data = c; t-&gt;L = creaTree(); t-&gt;R = creaTree(); return t;&#125; 12345678910111213141516171819202122/* 前中后序递归算法*/void preTraverse(bTree *t) &#123; if(t == NULL) return; printf(&quot;%c &quot;, t-&gt;data); preTraverse(t-&gt;L); preTraverse(t-&gt;R);&#125;void midTraverse(bTree *t) &#123; if(t == NULL) return; midTraverse(t-&gt;L); printf(&quot;%c &quot;, t-&gt;data); midTraverse(t-&gt;R);&#125;void postTraverse(bTree *t) &#123; if(t == NULL) return; postTraverse(t-&gt;L); postTraverse(t-&gt;R); printf(&quot;%c &quot;, t-&gt;data);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 前序、中序非递归算法*/typedef struct &#123; bTree *a[Max]; int top;&#125;Stack;void initStack(Stack *S) &#123; S-&gt;top = 0; &#125;void push(Stack *S, bTree *t) &#123; if(t == NULL || S-&gt;top == Max-1) return; S-&gt;a[S-&gt;top] = t; S-&gt;top++;&#125;bTree *pop(Stack *S) &#123; bTree *t; if(S-&gt;top == 0) return NULL; S-&gt;top--; t = S-&gt;a[S-&gt;top]; return t;&#125;int empty(Stack *S) &#123; if(S-&gt;top == 0) return 1; return 0;&#125;void preDisplay(bTree *t) &#123; Stack S; initStack(&amp;S); while(t != NULL || !empty(&amp;S)) &#123; if(t != NULL) &#123; printf(&quot;%c &quot;, t-&gt;data); push(&amp;S, t); t = t-&gt;L; &#125; else &#123; t = pop(&amp;S); t = t-&gt;R; &#125; &#125;&#125;void midDisplay(bTree *t) &#123; Stack S; initStack(&amp;S); while(t != NULL || !empty(&amp;S)) &#123; if(t != NULL) &#123; push(&amp;S, t); t = t-&gt;L; &#125; else &#123; t = pop(&amp;S); printf(&quot;%c &quot;, t-&gt;data); t = t-&gt;R; &#125; &#125;&#125; 有向网络邻接表的创建及优先遍历 先初始化结点数和边数，再输入顶点信息初始化顶点表，最后输入两边结点和权值信息利用头插法将新边表结点逐个插入到顶点头部 出度直接找到对应顶点计算边表结点个数，入度需要通过遍历整个顶点表找到边表结点值为该值的结点计算个数 从任意结点开始深度优先遍历即访问对应顶点下的未访问过的邻接点，根据邻接点的值访问对应的顶点，直至为空；广度优先遍历类似于二叉树的层次遍历，利用队列操作，默认从0开始，没访问过则访问并将顶点入队，然后顶点出队并依次访问该顶点下的邻接点，邻接点未访问过则访问并入队，直至为空 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 创建有向网络邻接表*/typedef struct k1 &#123; int eData; // 边点下标 int weight; struct k1 *next;&#125;eNode; // 边表结点typedef struct k2 &#123; int vData; // 顶点下标 eNode *first; // 边表头指针&#125;vNode; // 顶点表结点typedef struct&#123; vNode adjList[Max]; int numV, numE;&#125;ALGraph;int visited[Max] = &#123;0&#125;; // 访问状态数组void creaALGraph(ALGraph *G) &#123; int i, j, vi, vj, weight; eNode *e; printf(&quot;请输入结点数n和边数e&lt;n,e&gt;：&quot;); scanf(&quot;&lt;%d,%d&gt;&quot;, &amp;G-&gt;numV, &amp;G-&gt;numE); // 建立顶点表 printf(&quot;请连续输入顶点信息&lt;V&gt;：\n&quot;); fflush(stdin); for(i = 0; i &lt; G-&gt;numV; i++) &#123; scanf(&quot;&lt;%d&gt;&quot;, &amp;(G-&gt;adjList[i].vData)); G-&gt;adjList[i].first = NULL; &#125; // 建立边表 printf(&quot;连续输入两边结点和权值&lt;vi,vj,weight&gt;：\n&quot;); fflush(stdin); for(j = 0; j &lt; G-&gt;numE; j++) &#123; scanf(&quot;&lt;%d,%d,%d&gt;&quot;, &amp;vi, &amp;vj, &amp;weight); e = (eNode *)malloc(sizeof(eNode)); e-&gt;eData = vj; e-&gt;weight = weight; e-&gt;next = G-&gt;adjList[vi].first; // 将新边表结点插入到顶点Vi头部 G-&gt;adjList[vi].first = e; // 头插法 &#125;&#125;void printALGraph(ALGraph *G) &#123; int i, j; eNode *p; for(i = 0; i &lt; G-&gt;numV; i++) &#123; printf(&quot;%3d-&gt;&quot;, G-&gt;adjList[i].vData); p = G-&gt;adjList[i].first; while(p) &#123; printf(&quot;%3d&quot;, p-&gt;eData); p = p-&gt;next; &#125; printf(&quot;\n&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132/* 输出指定结点的入度和出度*/int getInDegree(ALGraph *G, int n) &#123; int count = 0, i; eNode *e; for(i = 0; i &lt; G-&gt;numV; i++) &#123; if(G-&gt;adjList[i].vData != n) &#123; e = G-&gt;adjList[i].first; while(e != NULL) &#123; if(e-&gt;eData == n) count++; e = e-&gt;next; &#125; &#125; &#125; return count;&#125;int getOutDegree(ALGraph *G, int n) &#123; int count = 0, i; eNode *e; for(i = 0; i &lt; G-&gt;numV; i++) &#123; if(G-&gt;adjList[i].vData == n) &#123; e = G-&gt;adjList[i].first; while(e != NULL) &#123; count++; e = e-&gt;next; &#125; break; &#125; &#125; return count;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 输出深度优先遍历和广度优先遍历结果*/typedef struct &#123; int f, r; int a[Max];&#125;Queue;void DFS(ALGraph *G, int i) &#123; eNode *p; if(visited[i]) return; printf(&quot;%d &quot;, G-&gt;adjList[i].vData); visited[i] = 1; p = G-&gt;adjList[i].first; while(p) &#123; if(visited[p-&gt;eData] == 0) DFS(G, p-&gt;eData); p = p-&gt;next; &#125;&#125;void initQueue(Queue *Q) &#123; Q-&gt;f = 0; Q-&gt;r = 0; &#125;void inQueue(Queue *Q, int i) &#123; if((Q-&gt;r+1)%Max == Q-&gt;f) return; Q-&gt;a[Q-&gt;r] = i; Q-&gt;r = (Q-&gt;r+1)%Max;&#125;int outQueue(Queue *Q) &#123; int i; if(Q-&gt;f == Q-&gt;r) return; i = Q-&gt;a[Q-&gt;f]; Q-&gt;f = (Q-&gt;f+1)%Max; return i;&#125;int isEmpty(Queue *Q) &#123; if(Q-&gt;f == Q-&gt;r) return 1; return 0;&#125;void BFS(ALGraph *G) &#123; int i; eNode *p; Queue Q; for(i = 0; i &lt; G-&gt;numV; i++) visited[i] = 0; // 初始化访问状态 initQueue(&amp;Q); for(i = 0; i &lt; G-&gt;numV; i++) &#123; // 默认从0开始遍历 if(visited[i] == 0) &#123; visited[i] = 1; printf(&quot;%d &quot;, G-&gt;adjList[i].vData); // 没访问过则访问并将顶点入队 inQueue(&amp;Q, i); while(!isEmpty(&amp;Q)) &#123; int i = outQueue(&amp;Q); p = G-&gt;adjList[i].first; // 顶点出队, 依次访问该顶点下的邻接点 while(p) &#123; if(visited[p-&gt;eData] == 0) &#123; // 邻接点未访问过则访问并入队 visited[p-&gt;eData] = 1; printf(&quot;%d &quot;, G-&gt;adjList[p-&gt;eData].vData); inQueue(&amp;Q, p-&gt;eData); &#125; p = p-&gt;next; &#125; &#125; &#125; &#125;&#125; 二分查找与二叉排序树 递归的划分判断对应下标值与key的大小而调整递归对应区间返回结果，非递归的划分通过while循环判断调整区间返回相等时的下标值，基于x:y的划分只是公式特殊一些 二叉排序树的创建就是不断插入结点的过程，使用递归时需要注意真正插入到子树，删除结点需要分度数：0度结点直接删除，1度结点由孙代子，2度结点找到前驱交换值后再删除1度结点 分块索引表的前提是数据分块有序，以界限为下标，对应的key为块的最大值，从而可以通过索引表快速查找到值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 递归与非递归实现基于x:y的划分查找 */typedef struct &#123; int a[100]; int len;&#125;list;void inputList(list *L) &#123; int x, i = 0; printf(&quot;输入一串数(以-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; L-&gt;a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; L-&gt;len = i;&#125;void printList(list *L) &#123; printf(&quot;\n线性表为：&quot;); int i; for(i = 0; i &lt; L-&gt;len ; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125; printf(&quot;\n&quot;);&#125;int BinSearchCurison(list *L, int Low, int High, int key, int X, int Y) &#123; int m; if(Low &gt; High) return -1; m = Low + (High-Low)*X/(X+Y); // 按比例划分 if(L-&gt;a[m] == key) return m; if(L-&gt;a[m] &gt; key) return BinSearch(L, Low, m-1, key, X, Y); else return BinSearch(L, m+1, High, key, X, Y);&#125;int BinSearch(list *L, int Low, int High, int key, int X, int Y) &#123; int m; while(Low &lt;= High) &#123; m = Low + (High-Low)*X/(X+Y); if(L-&gt;a[m] == key) return m; else if(L-&gt;a[m] &gt; key) High = m-1; else Low = m+1; &#125; return -1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 创建二叉排序树并对其进行查找、插入和删除，使用中序遍历验证 */#define Max 100typedef struct k&#123; int data; struct k *L, *R;&#125;bTree;typedef struct &#123; bTree *a[Max]; int top;&#125;Stack;bTree *insertBSTree(bTree *t, int x) &#123; bTree *p; p = malloc(sizeof(bTree)); p-&gt;data = x; p-&gt;L = NULL; p-&gt;R = NULL; if(t == NULL) return p; if(x &lt;= t-&gt;data) t-&gt;L = insertBSTree(t-&gt;L, x); else t-&gt;R = insertBSTree(t-&gt;R, x); return t;&#125;bTree *creaTree() &#123; bTree *t; int x; t = NULL; scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; t = insertBSTree(t, x); scanf(&quot;%d&quot;, &amp;x); &#125; return t;&#125;void midTraverse(bTree *t) &#123; if(t == NULL) return; midTraverse(t-&gt;L); printf(&quot;%d &quot;, t-&gt;data); midTraverse(t-&gt;R);&#125;bTree *searchBST(bTree *t, int x) &#123; if(t == NULL) return NULL; if(x == t-&gt;data) return t; if(x &lt; t-&gt;data) return searchBST(t-&gt;L, x); else return searchBST(t-&gt;R, x);&#125;void FindBST(bTree **t, bTree **pre, bTree **p, int x) &#123; *pre = NULL; *p = *t; while((*p) != NULL) &#123; // 查找到对应的结点，p指向它，pre指向p的双亲 if((*p)-&gt;data == x) break; if(x &lt; (*p)-&gt;data) &#123; (*pre) = (*p); (*p) = (*p)-&gt;L; &#125; else &#123; (*pre) = (*p); (*p) = (*p)-&gt;R; &#125; &#125;&#125;void del_0(bTree **pre, bTree **p) &#123; if((*pre)-&gt;L == *p) (*pre)-&gt;L = NULL; else if((*pre)-&gt;R == *p) (*pre)-&gt;R = NULL; free(*p);&#125;void del_1(bTree **pre, bTree **p) &#123; if((*pre)-&gt;L == *p) &#123; // 判断p是左子树还是右子树 if((*p)-&gt;L != NULL) (*pre)-&gt;L = (*p)-&gt;L; else (*pre)-&gt;L = (*p)-&gt;R; &#125; else &#123; if((*p)-&gt;L != NULL) (*pre)-&gt;R = (*p)-&gt;L; else (*pre)-&gt;R = (*p)-&gt;R; &#125; free(*p);&#125;void del_2(bTree **p) &#123; // 前驱替换 bTree *preQ, *q; int temp; preQ = (*p); q = (*p)-&gt;L; while(q-&gt;R != NULL) &#123; preQ = q; q = q-&gt;R; &#125;; // 找到p的前驱q, q的双亲preQ temp = (*p)-&gt;data; // p、q值互换 (*p)-&gt;data = q-&gt;data; q-&gt;data = temp; if(preQ-&gt;L == q) &#123; // 删除1度结点q if(q-&gt;L != NULL) preQ-&gt;L = q-&gt;L; else preQ-&gt;L = q-&gt;R; &#125; else &#123; if(q-&gt;L != NULL) preQ-&gt;R = q-&gt;L; else preQ-&gt;R = q-&gt;R; &#125; free(q);&#125;bTree *delBST(bTree *t, int x) &#123; bTree *pre, *p; if(t == NULL) return NULL; FindBST(&amp;t, &amp;pre, &amp;p, x); // 删除0度结点 if(p-&gt;L == NULL &amp;&amp; p-&gt;R == NULL) del_0(&amp;pre, &amp;p); // 删除1度结点 else if((p-&gt;L == NULL) != (p-&gt;R == NULL)) del_1(&amp;pre, &amp;p); // 删除2度结点 else if(p-&gt;L != NULL &amp;&amp; p-&gt;R != NULL) del_2(&amp;p); return t;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 创建分块索引表，并进行查找 */#define M 30#define DIS 7typedef struct &#123; int a[M]; int len;&#125;List;typedef struct &#123; int addr; // 地址 int key; // 关键字&#125;sNode;typedef struct &#123; sNode s[M]; int len;&#125;sList;void creaList(List *L) &#123; int x, i = 0; printf(&quot;输入一串数(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; L-&gt;a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; L-&gt;len = i;&#125;void printList(List *L) &#123; int i; for(i = 0; i &lt; L-&gt;len; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125;&#125;void creaSList(sList *S, List *L) &#123; int i, j, max, k = 0; for(i = 0; i &lt; L-&gt;len; i=i+DIS) &#123; max = L-&gt;a[i]; for(j = i; j &lt; i+DIS &amp;&amp; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] &gt; max) max = L-&gt;a[j]; &#125; S-&gt;s[k].addr = i; S-&gt;s[k].key = max; k++; &#125; S-&gt;len = k;&#125;void printSList(sList *S) &#123; int i; for(i = 0; i &lt; S-&gt;len; i++) &#123; printf(&quot;%d--%d &quot;, S-&gt;s[i].addr, S-&gt;s[i].key); &#125;&#125;int sListFind(sList *S, List *L, int x) &#123; int i, j; for(i = 0; i &lt; S-&gt;len; i++) &#123; if(S-&gt;s[i].key == x) return S-&gt;s[i].addr; else if(S-&gt;s[i].key &gt; x) &#123; // 进入顺序表 for(j = S-&gt;s[i].addr; j &lt; S-&gt;s[i].addr+DIS &amp;&amp; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] == x) return j; &#125; return -1; &#125; &#125; return -1;&#125; 常用排序算法 首先从最后一个双亲开始进行堆调整，然后将堆顶与堆的末尾位置（哨位）交换，之后去掉哨位，重复进行堆调整、交换过程直至排序完成，根据大根堆还是小根堆实现升序或降序排序 以最开始的元素x为基准，从最后一位开始设标志位，违反大小规则就交换头尾两边，将数据集分成左边小于x和右边大于x两个集合，重复这样的过程直至有序 从头至尾，归并所有相邻有序段，类似于两个升序表合并，利用辅助的数组保存归并结果，最终一趟归并完成所有归并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 堆排序 */#define M 30int initArray(int a[]) &#123; int x, i; i = 0; a[i] = -1; i++; printf(&quot;输入关键字(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; return i-1;&#125;int minChildPos(int a[], int i, int n) &#123; int k = i*2; if(k &gt; n) return -1; if(k+1 &gt; n || a[k] &lt; a[k+1]) return k; return k+1;&#125;void adjustHeap(int a[], int i, int n) &#123; int t, k; t = a[i]; k = minChildPos(a, i, n); while(k != -1 &amp;&amp; t &gt; a[k]) &#123; a[i] = a[k]; i = k; k = minChildPos(a, i, n); &#125; a[i] = t;&#125;void heapSort(int a[], int n) &#123; int t, i; // 第一次堆调整 for(i = n/2; i &gt;= 1; i--) &#123; adjustHeap(a, i, n); &#125; // 极值交换排序 for(i = n; i &gt; 1; i--) &#123; t = a[i]; a[i] = a[1]; a[1] = t; adjustHeap(a, 1, i-1); &#125;&#125; 1234567891011121314151617181920212223242526272829/* 快速排序 */#define M 30int initArray(int a[]) &#123; int x, i = 0; printf(&quot;输入关键字(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; return i-1;&#125;void quickSort(int a[], int L, int H) &#123; int i, j, t; i = L, j = H; t = a[i]; if(i &gt; j) return; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; a[j] &gt;= t) j--; if(i &lt; j) &#123; a[i] = a[j]; i++; &#125; while(i &lt; j &amp;&amp; a[i] &lt;= t) i++; if(i &lt; j) &#123; a[j] = a[i]; j--; &#125; &#125; a[i] = t; quickSort(a, L, j-1); quickSort(a, i+1, H);&#125; 123456789101112131415161718192021222324252627282930313233343536373839/* 归并排序 */#define M 30int initArray(int a[]) &#123; int x, i = 0; printf(&quot;输入关键字(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; return i-1;&#125;void mergeOne(int a[], int b[], int len, int staPos, int step) &#123; int i, j, k, endi, endj; i = staPos; j = i + step; k = i; if(j &gt;= len) &#123; for(j = i; j &lt; len; j++) b[j] = a[j]; return; &#125; endi = j-1; endj = (j+step-1&lt;len)?j+step-1:len-1; while(i &lt;= endi &amp;&amp; j &lt;= endj) &#123; if(a[i] &lt;= a[j]) &#123; b[k] = a[i]; i++; &#125; else &#123; b[k] = a[j]; j++; &#125; k++; &#125; while(i &lt;= endi) &#123; b[k] = a[i]; k++; i++; &#125; while(j &lt;= endj) &#123; b[k] = a[j]; k++; j++; &#125;&#125;void mergeAll(int a[], int b[], int len, int step) &#123; int i; for(i = 0; i &lt; len; i=i+2*step) mergeOne(a, b, len, i, step); for(i = 0; i &lt; len; i++) a[i] = b[i];&#125;void mergeSort(int a[], int b[], int len) &#123; int step; for(step = 1; step &lt; len; step=step*2) mergeAll(a, b, len, step);&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数防抖与函数节流]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[前言► 实际开发中以下场景往往由于事件频繁被触发，从而频繁执行DOM操作、资源加载等行为，导致页面卡顿甚至浏览器崩溃： window对象的 resize、scroll 事件 拖拽时的 mousemove 事件 射击游戏中的 mousedown、keydown 事件 文字输入、自动完成的 keyup 事件 ► 对于 window 的 resize 事件，实际需求一般是停止改变大小n毫秒后执行；而其它事件一般是以一定的频率执行。 ► 针对这两种需求就出现了 debounce (防抖) 和 throttle (节流) 两种解决办法 函数防抖► 如果用手一直按住一个弹簧，它将不会弹起直到你松手为止，也就是调用动作n毫秒后才会执行该动作，如果n毫秒内再次调用则重新计算执行时间 简单实现： debounce 方法接收两个参数，一个是需要防抖动的函数 fn ，另一个是延迟时间 delay 函数节流► 将水龙头拧到水以水滴的形式流出，每隔一段时间就有一滴水流出，也就是预先设定一个执行周期，调用动作的时刻不小于这个执行周期就执行它 简单实现：throttle 方法也是接收两个参数，一个是需要节流的函数 fn ，另一个是函数执行间隔阈值 threshhold 总结可以参考一下防抖和节流与正常触发的对比效果图： ► debounce 可以想象成把很多事件压缩成了一个事件，throttle 可以想象成像阀门一样定时打开调节流量 ► 简单来说，debounce 适合只执行一次的情况，比如 搜索框的自动完成：在停止输入后才提交一次ajax请求； throttle 适合每隔一定时间间隔内执行不超过一次的情况，比如 拖动滚动条、移动鼠标、滚轮事件的处理等]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6基础概念]]></title>
    <url>%2F2017%2F11%2F23%2FES6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[let命令基本用法► 用来声明变量，类似于 var，但只在 let 命令所在的代码块内有效 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceErrorb // 1 ► 使用 let ，声明的变量只在块级作用域内有效，因此 for 循环的计数器很适合用 let 命令 ► for 循环还有一个特别之处，设置循环变量的那部分是一个副作用域，而循环体内部是一个单独的子作用域 1234for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abs&apos;; console.log(i);&#125; 不存在变量提升► var 命令会有变量提升，也就是变量可以在声明之前使用，值为 undefined ► let 命令改变了这种语法行为，它所声明的变量一定要在声明后使用，否则就报错 暂时性死区► 只要块级作用域内存在 let 命令，它所声明的变量就绑定这个区域，不受外部的影响 123456var tmp = 123;if(true) &#123; tmp = &apos;abc&apos;; //ReferenceError let temp;&#125; ► 上述代码中虽然存在全局变量 tmp,但是块级作用域内 let 又声明了一个局部变量 tmp，导致后者绑定了这个块级作用域，所以在 let 声明变量之前，对 tmp 赋值都会报错 ► ES6 明确规定，区块中如果存在 let 和 const 命令，在语法上，这个区块就形成了”暂时性死区” ► 这也意味着 typeof 命令不再是一个百分百安全的操作，这样规定暂时性死区和 let、const 语句不出现变量提升，主要就是为了防止变量在声明前就使用它从而减少错误 不可重复声明► let 不允许在相同作用域内，重复声明同一个变量，也即不能在函数内部重新声明参数 123456789function func(arg) &#123; let arg; //执行会报错&#125;function func(arg) &#123; &#123; let arg; //不会报错 &#125;&#125; const命令基本用法► 用来声明一个只读的常量，一旦声明，值就不能改变，这也意味着，const 一旦声明变量就必须立即初始化，不能留到之后再赋值，其它与 let 命令类似 本质► const 实际保证的，不是变量的值不能改动，而是变量所指向的内存地址不能改动 12345678const foo = &#123;&#125;;//添加属性可以成功foo.prop = 123;foo.prop;//指向另一个对象就会报错foo = &#123;&#125;; 箭头函数基本用法► ES6 允许使用“箭头”（=&gt;）定义函数 123456var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;; ► 如果箭头函数不需要参数或者需要多个参数，就使用圆括号 1234567891011var f = () =&gt; 5;//等同于var f = function() &#123; return 5;&#125;;var sum = (num1,num2) =&gt; num1 + num2;//等同于var sum = function(num1,num2) &#123; return num1 + num2;&#125; ► 代码块多于一条语句的话就要用大括号括起来并且使用 return 语句返回 ► 由于大括号被解释为代码块，所以箭头函数返回的是一个对象的话，必须在对象外面加上括号 12345var getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot;&#125;);//等同于var getTempItem = function(id) &#123; return &#123; id: id, name: &quot;Temp&quot;&#125;;&#125;; ► 箭头函数使表达式更简洁12const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n; ► 其它用途… 使用注意点► 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象 ► 不可以当作构造函数，即不能使用 new 命令 ► 没有 arguments 对象，需要的话可以用 rest 参数代替 ► 不能使用 yield 命令，所以箭头函数不能用作 Generator 函数 尤其注意第一点，在箭头函数中 this 对象的指向是固定的 123456789function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;,100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); // id: 42 ► 上例中 setTimeout 的参数是一个箭头函数，它的定义生效在 foo 函数生成时，真正执行就要等到100ms后，如果是普通函数的话，执行时 this 应该指向全局对象 window ，即输出 21 ，但箭头函数导致this总是指向函数定义生效时所在的对象( {id: 42} )，所以输出 42 . ► this 指向的固定化，不是箭头函数内部有这样的机制，而是它没有自己的 this，所以它内部的 this 就是外层代码块的 this ,这也是它不能用作构造函数的原因 所以箭头函数转换成ES5的代码如下： 123456789101112function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id: &apos;,this.id); &#125;,100);&#125;function foo() &#123; var _this = this; setTimeout(function() &#123; console.log(&apos;id: &apos;,_this.id); &#125;,100);&#125; 对象和数组数组的解构赋值► ES6 允许按照一定模式，从数组和对象中提取值同时对变量进行赋值，这被称为 解构 1let [a,b,c] = [1,2,3]; 上面的代码中从数组中提取值并按照对应位置对变量赋值 本质上这种写法属于”模式匹配”, 只要等号两边的模式相同，左边的变量就会被赋予对应的值, 如果不完全解构即左边的模式只匹配一部分的右边的数组，解构也成功 一些例子：1234567891011121314151617/*完全解构*/let [ , , third] = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;];third // &apos;baz&apos;let [head, ...tail] = [1,2,3,4];head // 1tail // [2,3,4]/*不完全解构*/let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4]a // 1b // 2d // 4 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值 对象的解构赋值► 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名才能正确取到值 12345678910let &#123; bar, foo &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;foo // &quot;aa&quot;bar // &quot;cc&quot;let &#123; baz &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;baz // undefined/*变量名与属性名不一致的写法*/let &#123; foo: baz &#125; = &#123; foo: &apos;aa&apos;, bar: &apos;cc&apos; &#125;;baz // &quot;aa&quot; 变量名与属性名不一致的写法实际上说明，对象的解构赋值是下面形式的简写： 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aa&quot;, bar: &apos;cc&apos; &#125;; 即对象的解构赋值是先找到同名属性，再赋给对应的变量。真正被赋值的是后者而不是前者 ► 对象的解构赋值，可以很方便地将现有对象的方法赋值给对应的变量 1let &#123; log, sin, cos &#125; = Math; 解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象 用途12345/*交换变量的值*/let x = 1;let y = 2;[x, y] = [y, x] 12345678910111213141516/*从函数返回多个值*/// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();//返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 12345/*函数参数的定义*/// 参数是一组无次序的值时function f(&#123; x, y, z &#125;) &#123; ... &#125;f(&#123; z: 3, y: 5, x: 0 &#125;) 1234567/*提取JSON数据*/let jsonData = &#123; id: 42, data: [860, 504]&#125;;let &#123; id, data: number &#125; = jsonData; 123456789jQuery.ajax = function(url, &#123; async = true, beforeSend = function() &#123;&#125;, cache = true, complete = function() &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123;&#125;; 123/* 输入模块的指定方法 */const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础]]></title>
    <url>%2F2017%2F11%2F23%2FjQuery%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础核心代码风格‘$’： jQuery 当中最重要并且独有的对象：jQuery对象1234567$(function() &#123;&#125;); //执行一个匿名函数$(&apos;#box&apos;); //进行执行的ID元素选择$(&apos;#box&apos;).css(&apos;color&apos;,&apos;red&apos;); //执行功能函数/*等同于*/jQuery(function() &#123;&#125;);jQuery(&apos;#box&apos;); 执行功能函数时，先获取元素返回 jQuery 对象后再调用功能函数，同时返回的还是 jQuery 对象，所以可以连缀不停的调用功能函数 1$(&apos;#box&apos;).css(&apos;color&apos;,&apos;red&apos;).css(&apos;font-size&apos;,&apos;50px&apos;); 加载模式jQuery 等待加载： 1$(document).ready(function () &#123;&#125;); 它的执行时机只需等待网页中的DOM结构加载完毕就可以执行包裹的代码，并且可以执行多次不会覆盖 window.onload 需要等待图片之类的大型元素加载完毕后才能执行JS代码，在网速慢的情况下，图片还在缓慢加载时，页面上任何的JS交互功能都会处在假死状态，同时只能执行一次，会给实际开发带来困难 对象互换jQuery 对象是 jQuery 库独有的对象，通过JS封装而来，可以直接输出得到它的信息 只要使用代码包裹以后，最终返回的都是 jQuery 对象，好处就是可以连缀处理，如果需要返回原生的DOM对象的话，可以这么处理： 1$(&apos;#box&apos;).get(0); //ID元素的第一个原生DOM 从get(0)的索引看出， jQuery 可以批量处理DOM，在循环遍历上会更方便 多个库之间的冲突同一个项目中引入多个第三方库时，由于没有命名空间的约束，不同库之间很容易发生冲突 对于同样使用’$’作为基准起始符的库(如 Base 库)，想和 jQuery 共存的话有两种办法： 先引入 jQuery 库，这样’$’的所有权就归之后的库所有， jQuery 可以直接用jQuery对象调用，或者创建一个新符(‘$$’)给它用： 12345var $$ = jQuery;$(function () &#123; $(&apos;#box&apos;).get(0); // 都是Base的$ $$(&apos;#box&apos;).width(0); // jQuery的$$&#125;); 后引入 jQuery 库，’$’归 jQuery 库，jQuery 有一个方法可以放弃： 12345jQuery.noConflict(); // 将$符所有权剔除var $$ = jQuery;$(function () &#123; ... // $属于Bae, $$属于jQuery&#125;); 工具函数字符串操作12var str = &apos; sad&apos;;$.trim(str); //去除字符串左右空格 数组和对象操作12345678910/*$.each()遍历数组*/var arr = [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;];$.each(arr,function(index, value) &#123; $(&apos;#box&apos;).html($(&apos;#box&apos;).html + index + &apos;.&apos; + value + &apos;&lt;br&gt;&apos;);&#125;);/*遍历对象*/$.each($.ajax(), function(name, fn) &#123; $(&apos;#box&apos;).html($(&apos;#box&apos;).html() + name + &apos;.&apos; + &apos;&lt;br&gt;&lt;br&gt;&apos;);&#125;) 123456/*$.grep()数据筛选*/var arr = [5,3,5,7,45,98,23,10];$.grep(arr, function(element, index) &#123; return element &lt; 6 &amp;&amp; index &lt; 5;&#125;);/*index从0开始计算*/ 1234567/*$.map()修改数据*/var arr = [5,6,87,54,32,4,10];$.map(arr, function(element, index) &#123; if(element &lt; 6 &amp;&amp; index &lt; 5) &#123; return element + 1; &#125;&#125;); ► $.merge() 合并两个数组 ► $.unique() 删除重复的DOM元素 ► .toArray() 合并多个DOM元素组成数组 … 测试操作 URL操作123456/*$.param()将对象键值对转换为URL字符串键值对*/var obj = &#123; name : &apos;Lee&apos;, age : &apos;20&apos;&#125;;$.param(obj); 其它操作jQuery提供了一个预备绑定函数上下文的工具函数: $.proxy(),可以解决如外部事件触发调用对象方法时this的指向问题 12345678910111213141516171819/*$.proxy()调整this指向*/var obj = &#123; name : &apos;Lee&apos;, test: function() &#123; alert(this.name); &#125;&#125;$(&apos;#box&apos;).click(obj.test); //this指向为#box元素，undefined$(&apos;#box&apos;).click($.proxy(obj,&apos;test&apos;)); //this指向为对象box，Lee/*等效于*/var obj = &#123; name : &apos;Lee&apos;, test : function() &#123; var _this = obj; alert(_this.name); &#125;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象与原型]]></title>
    <url>%2F2017%2F11%2F23%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这里会先把之前已经写好的总结陆续放上来，主要也是有一个时间顺序记录自己的学习过程（(#^.^#)） 面向对象与原型一.创建对象：1.最基本的创建一个对象并添加属性和方法 缺点：每创建一个类似对象，都会产生大量代码 解决：工厂模式解决实例化对象产生大量重复代码，即设计一个实例化的函数 2.工厂模式： 新问题：无法区别实例的来源对象 解决：用构造函数来创建特定的对象 3.构造函数 重复实例化和对象识别的问题都得到解决 规范：1.函数名和实例化名相同并且首字母大写（有助于区分构造函数和普通函数） 2.必须用new运算符创建对象（与普通函数的区别） 与工厂模式的区别：1.构造函数没有显式地创建对象 2.直接把属性方法赋给this对象 3.没有return语句 小问题：在对run方法的引用上每次实例化的地址都不同，即alert(person1.run == person2.run)的结果是false 二.原型创建的每个函数都有一个prototype属性（对象）。包含可以由特定类型的所有实例共享的属性和方法 1.构造函数与原型模式的声明方式： 通过两种方式的对比可以明白为什么它们在对方法的引用地址上会有区别 2.原型模式的执行流程：构造函数实例里有属性或方法的话就返回，没有就去它的原型对象中找 对属性是在构造函数的实例里还是原型里的判断：hasOwnProperty()---&gt;实例有返回true in操作符 ---&gt;只要存在就返回true ---&gt;两种方法结合判断原型中是否存在属性 3.原型模式创建对象的缺点：共享—–如果某次实例化时改变了原型中的属性，则会影响到之后的实例化对象 —–如果有传入参数的话，之后的实例化对象属性会覆盖掉之前的，无法独立 即用相同原型创建的对象访问原型中的属性时，访问的都是同一个对象解决：构造函数+原型模式的组合模式： 构造函数适合封装属性 原型模式适合封装方法 组合模式： 解决了传参和共享的难题，进一步的优化是把构造函数和原型封装到一起 动态原型模式： 以上两种是JS创建对象时使用较多的方式，优先考虑动态原型模式 4.补充：寄生构造函数：工厂模式+构造函数模式 —&gt;需要创建一个具有额外方法的引用类型 稳妥构造函数： —&gt;构造函数中不用this,外部实例化函数时不用new 三.继承1.原型链正统面向对象语言实现继承的方式：接口实现和继承 ECMAScript只支持继承，实现的方式是依靠原型链 实质：通过原型让一个引用类型继承另一个引用类型的属性和方法 被继承的函数称为超类型（父类、基类）;继承的函数称为子类型（子类、派生类） 继承存在的问题： 字面量重写原型会中断关系 子类型无法给超类型传递参数 2.借用构造函数（对象冒充）—&gt;解决引用共享和不能给超类型传参的问题 新问题：没有原型，无法复用 3.组合继承（最常用）—&gt;通过原型链继承原型的属性方法 —&gt;通过借用构造函数继承实例的属性 —&gt;既实现了函数复用，又保证每个实例的独立性 4.原型式继承—&gt;借助原型并基于已有的对象创建新对象，不用再创建自定义类型 5.寄生式继承（原型式+工厂模式）—&gt;为了封装创建对象的过程 6.寄生组合式继承—&gt;处理组合式继承的问题：超类型在使用过程中被调用了两次： 创建子类型时 在子类型构造函数内部 通过原型链的混成形式调用方法，解决了两次调用的问题 总结：1.创建对象： 工厂模式：用简单的函数创建对象，添加属性方法然后返回它 构造函数模式：可以创建特定的对象，但是它的成员包括函数都不能复用 原型模式：利用函数的prototype属性来指定应该共享的方法和属性 组合模式：利用构造函数定义实例属性，利用原型定义共享方法 2.继承： 原型链继承：通过原型让一个引用类型继承另一个引用类型的属性和方法 借用构造函数（对象冒充）：解决引用共享和超类型不能传参的问题 组合继承：通过原型链继承原型的属性方法，通过借用构造函数继承实例的属性，最常用，但有多次调用超类型构造函数导致的低效率问题 原型式继承：在已有对象上借助原型创建新对象，新对象可以进一步添加属性方法 寄生式继承：封装了创建对象的过程，基于这个可以进一步增强对象 寄生组合式继承：通过原型链的混成形式调用方法，避免多次调用超类型构造函数，基于类型继承的最有效方式]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建你的博客]]></title>
    <url>%2F2017%2F11%2F23%2FHexo-blog%2F</url>
    <content type="text"><![CDATA[一开始自己用hexo搭博客的时候踩了比较多坑，在这里想总结一下做一个简单的搭建教程，后续使用再慢慢完善 初始配置环境 node 作用：生成静态页面 Git 作用：将本地的hexo内容提交到github上 申请Github 作用：作为博客的远程仓库和服务器 Hexo的安装及初始化环境配置好后，创建一个文件夹，进入后执行以下命令： npm install hexo-cli -g 安装hexo hexo init 初始化 npm install hexo generate 生成静态页面 hexo server 启动本地服务之后浏览器输入localhost:4000 就可以看到一个默认的hexo博客啦 Github上的配置进入Github新建一个仓库，这里特别要强调的是仓库名的格式必须为yourusername.github.io，yourusername就是你的Github用户名，这里错误的话，之后直接访问就会404（我就是这样o(╥﹏╥)o）,建好以后就clone一下HTTPS形式的url（这里先不用SSH） 本地Hexo文件的修改进入Hexo文件根目录下的_config.yml，打开以后拉到最下面的deploy那里，改成如下形式：1234deploy: type: git repo: https://github.com/fxbabys/fxbabys.github.io.git branch: master 这里也特别要强调的是冒号后面一定要加空格 然后执行命令安装: npm install hexo-deployer-git --save再执行配置命令: hexo deploy这样本地文件就上传到Github远程库上了，访问https://fxbabys.github.io/就行了 之后每次部署发布文章可以按下面的步骤进行： hexo new &quot;文章名称&quot; 这样会在source/_posts下生成一个md文档 hexo server(hexo s) 上传前本地先预览一下效果 hexo generate(hexo g) hexo deploy(hexo d) 到这里搭建一个hexo博客和发布新文章就完成啦！更个性化的设置可以自己去Hexo官方文档上查看，介绍的都很详细，也可以去网上找教程再多折腾一些自己的喜好（(^▽^)）]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome]]></title>
    <url>%2F2017%2F11%2F19%2Fwelcome%2F</url>
    <content type="text"><![CDATA[Welcome to my technology blog !This is the first blog I built myself and I will update my study and thinking life in it later.I hope it can also help others who read this blog，let’s step forward together！]]></content>
  </entry>
</search>

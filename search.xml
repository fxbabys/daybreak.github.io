<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git常用操作]]></title>
    <url>%2F2017%2F11%2F30%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[随着做项目的深入，对Git的使用也越来越频繁，这里就做一个常用操作的总结，不断更新~ Git理念► 工作区（即本地文件）► 暂存区► 本地仓库► 远程仓库 使用Git项目的文件都是在上面四个地方传递 本地项目关联远程仓库远程库建好以后就可以运行这条命令关联到本地项目：git remote add origin your-remote-repository-url 如果是直接克隆远程仓库到本地的话：git clone your-remote-repository-url 可以运行以下命令查看结果： git remote -v 查看当前项目的远程库git branch -a 查看当前项目的所有分支 远程库同步到本地► 在提交更新以前都要先同步一下本地仓库1git pull // 等同于 git fetch + git merge 如果需要放弃本地修改，强制覆盖本地版本的话（即保持与远程库一致）：123git fetch --allgit reset --hard origin/mastergit pull 提交本地更新到远程库git status 检查当前项目状态 然后对于未跟踪的文件执行以下命令： 123git add un-track-file-path // 跟踪本地文件，提交到暂存区git commit -m &quot;your commit&quot; // 将跟踪过的文件即在暂存区的文件提交到本地仓库git push // 将本地仓库提交到远程库 提交到远程库常用的命令还有：12git add . // 跟踪本地所有未跟踪的文件git push --f // 强制提交更新，覆盖远程库 版本回退► 将当前版本回退到已提交的版本历史中git reset --hard HEAD^ 一个^号代表回退一个版本 更多时候我们都会找到对应的版本号进行回退：首先 git log 显示最近到最远的提交日志如果只想显示版本号和评论信息的话可以加上 --pretty=oneline 参数现在就可以 git reset --hard version number 回退到对应的版本 这里还有一个常用命令：git reflog 显示你的每一次命令，对于自己命令的整理很有帮助 撤销修改► 分情况执行123456// 在工作区修改并且未跟踪git checkout -- file-path// 在工作区修改并且已跟踪git reset HEAD file-path // 先撤销暂存区的修改git checkout -- file-path // 再撤销工作区的修改]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验参考]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[逐步补上之前的数据结构实验代码，之后也会不断完善，仅供参考(^▽^) 顺序表链表的创建输出及两种有序表的合并► 对于顺序表和单链表定义不同的结构体，顺序表通过下标创建并输出 链表为带头结点的单链表，使用尾插法创建并输出► 从头开始遍历两个升序表，将更大的存入第三个表中，并将其标记后移 对于单链表，需要使用头插法插入第三个单链表中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 顺序表的创建输出及两个升序表合并成一个升序顺序表*/#include&lt;stdio.h&gt;#include&lt;math.h&gt;typedef struct &#123; int a[100]; int len;&#125;list;void inputList(list *L) &#123; int x, i = 0; printf(&quot;输入一串数(以-1结束)：&quot;); while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123; L-&gt;a[i] = x; i++; &#125; L-&gt;len = i;&#125;void printList(list *L) &#123; printf(&quot;\n线性表为：&quot;); int i; for(i = 0; i &lt; L-&gt;len ; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125; printf(&quot;\n&quot;);&#125;void insertList(list *L, int x) &#123; int i; for(i = L-&gt;len-1; i &gt; 0 &amp;&amp; L-&gt;a[i] &gt; x; i--) &#123; L-&gt;a[i+1] = L-&gt;a[i]; &#125; L-&gt;a[i+1] = x; L-&gt;len++;&#125;void mergeDoubleUp(list *L1, list *L2, list *L3) &#123; int i = 0, j = 0, tail = 0; while(i &lt; L1-&gt;len &amp;&amp; j &lt; L2-&gt;len) &#123; if(L1-&gt;a[i] &lt; L2-&gt;a[j]) &#123; L3-&gt;a[tail] = L1-&gt;a[i]; i++; &#125; else &#123; L3-&gt;a[tail] = L2-&gt;a[j]; j++; &#125; tail++; &#125; while(i &lt; L1-&gt;len) &#123; L3-&gt;a[tail] = L1-&gt;a[i]; i++; tail++; &#125; while(j &lt; L2-&gt;len) &#123; L3-&gt;a[tail] = L2-&gt;a[j]; j++; tail++; &#125; L3-&gt;len = tail;&#125;int main() &#123; list L1, L2, L3; inputList(&amp;L1); inputList(&amp;L2); mergeDoubleUp(&amp;L1, &amp;L2, &amp;L3); printList(&amp;L3); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* 单链表的创建输出、两个升序链表合并为一个降序链表*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct k &#123; int data; struct k *next;&#125;node;void createList(node *h) &#123; node *p, *tail; tail = h; int x; printf(&quot;输入一串数(以-1结束)：&quot;); while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123; p = (node *)malloc(sizeof(node)); p-&gt;data = x; p-&gt;next = NULL; tail-&gt;next = p; tail = p; &#125;&#125;void printList(node *h) &#123; node *p; for(p = h-&gt;next; p != NULL; p = p-&gt;next) &#123; printf(&quot;%d &quot;, p-&gt;data); &#125;&#125;void mergeDoubleDown(node *h1, node *h2, node *h3) &#123; node *i, *j, *head; i = h1-&gt;next; j = h2-&gt;next; while(i != NULL &amp;&amp; j != NULL) &#123; if(i-&gt;data &lt; j-&gt;data) &#123; head = i; i = i-&gt;next; &#125; else &#123; head = j; j = j-&gt;next; &#125; // 头插法建立h3链表 head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125; // 尾部处理 while(i != NULL) &#123; head = (node *)malloc(sizeof(node)); head-&gt;data = i-&gt;data; i = i-&gt;next; head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125; while(j != NULL) &#123; head = (node *)malloc(sizeof(node)); head-&gt;data = j-&gt;data; j = j-&gt;next; head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125;&#125;int main()&#123; node h1, h2, h3; h1.next = NULL; h2.next = NULL; h3.next = NULL; createList(&amp;h1); createList(&amp;h2); printf(&quot;\n链表1为&quot;);printList(&amp;h1); printf(&quot;\n链表2为&quot;);printList(&amp;h2); mergeDoubleDown(&amp;h1, &amp;h2, &amp;h3); printf(&quot;\n链表3为&quot;);printList(&amp;h3); return 0;&#125; 顺序表的排序及单链表求最值► 通过两次循环，默认为升序，如果第一次循环出现降序则进入第二次循环，第二次循环若出现升序则说明无序► 设置两个标记分别从两边遍历，左为奇数时左标记继续，右为偶数时右标记继续，直到左为偶数右为奇数时则交换► 设置当前标记和前驱标记遍历整个单链表，并通过预设的最大标记指针和最大前驱标记指针不断比较，遍历完最大标记指针就指向最大值 123456789101112131415161718192021222324252627282930313233343536373839404142/* 判断顺序表是否有序、实现奇偶分开、实现选择排序算法*/int isSort(sort *L) &#123; // 返回-1说明无序，1则有序 int i, j; // 两次循环判断 for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123; if(L-&gt;a[i] &gt; L-&gt;a[j]) &#123; for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123; if(L-&gt;a[i] &lt; L-&gt;a[j]) return -1; &#125; &#125; &#125; return 1;&#125;void divert(sort *L) &#123; int i = 0, j = L-&gt;len-1; while(i &lt; j) &#123; while(L-&gt;a[i] % 2 != 0) i++; while(L-&gt;a[j] % 2 == 0) j--; if(i &lt; j) &#123; int temp = L-&gt;a[i]; L-&gt;a[i] = L-&gt;a[j]; L-&gt;a[j] = temp; &#125; else break; &#125;&#125;void selectSort(sort *L) &#123; int i; for(i = 0; i &lt; L-&gt;len; i++) &#123; int min = i, j; for(j = i; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] &lt; L-&gt;a[min]) min = j; &#125; int temp = L-&gt;a[min]; L-&gt;a[min] = L-&gt;a[i]; L-&gt;a[i] = temp; &#125;&#125; 123456789101112131415161718/* 选出单链表的最大值并移至末尾*/void removeMax(node *h) &#123; node *pre, *p, *preMax, *max; preMax = h; max = preMax-&gt;next; pre = preMax-&gt;next; p = max-&gt;next; for(; p != NULL; p = p-&gt;next, pre = pre-&gt;next) &#123; if(p-&gt;data &gt; max-&gt;data) &#123; preMax = pre; max = p; &#125; &#125; preMax-&gt;next = max-&gt;next; pre-&gt;next = max; max-&gt;next = NULL;&#125; 带头指针型单链表及模式匹配算法► 头指针型单链表创建时对于第一个输入单独造头结点，之后与带头结点型单链表相同► 采用递归不断分解直到达最后一个结点输出► 从头开始遍历文本串t，同时不断跟模式串p匹配直到成功或遍历结束匹配失败 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 创建输出头指针型单链表、合并两个升序头指针型单链表为降序、将单链表从尾至首输出*/node *createList() &#123; int x; node *h, *p, *tail; printf(&quot;输入一串数(以-1结束)：&quot;); /* 造头结点 */ scanf(&quot;%d&quot;, &amp;x); if(x == -1) return; h = (node *)malloc(sizeof(node)); h-&gt;data = x; h-&gt;next = NULL; tail = h; scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; p = (node *)malloc(sizeof(node)); p-&gt;data = x; p-&gt;next = NULL; tail-&gt;next = p; tail = p; scanf(&quot;%d&quot;, &amp;x); &#125; return h;&#125;void printList(node *h) &#123; printf(&quot;链表为：&quot;); node *p; for(p = h; p != NULL; p = p-&gt;next) &#123; printf(&quot;%d &quot;, p-&gt;data); &#125; printf(&quot;\n&quot;);&#125;node *mergeDoubleDown(node *h1, node *h2, node *h3) &#123; node *i, *j, *k; i = h1; j = h2; while(i != NULL &amp;&amp; j != NULL) &#123; if(i-&gt;data &lt; j-&gt;data) &#123; k = i; i = i-&gt;next; k-&gt;next = h3; h3 = k; &#125; else &#123; k = j; j = j-&gt;next; k-&gt;next = h3; h3 = k; &#125; &#125; // 尾部处理 while(i != NULL) &#123; k = i; i = i-&gt;next; k-&gt;next = h3; h3 = k; &#125; while(j != NULL) &#123; k = j; j = j-&gt;next; k-&gt;next = h3; h3 = k; &#125; return h3;&#125;void revPrintList(node *h) &#123; if(h-&gt;next != NULL) &#123; revPrintList(h-&gt;next); &#125; printf(&quot;%d &quot;, h-&gt;data);&#125; 12345678910111213141516171819202122232425262728/* 朴素的模式匹配算法*/void creStr(seqString *s) &#123; char x; int i = 0; while((x = getchar()) != &apos;\n&apos;) &#123; s-&gt;str[i] = x; i++; &#125; s-&gt;len = i;&#125;int simpleMatch(seqString t, seqString p) &#123; int i; for(i = 0; i &lt; t.len; i++) &#123; if(success(t, p, i)) return i; &#125; return -1;&#125;int success(seqString t, seqString p, int i) &#123; int j; for(j = 0; j &lt; p.len; j++) &#123; if(t.str[i+j] != p.str[j]) return 0; &#125; return 1;&#125; 稀疏矩阵的转置与递归程序设计► 首先将行列数与非零元数存入第一个三元组，再根据输入将非零元存入对应位置快速转置时需要一遍扫描填入非零元所在的新位置数组，之后一步转置► 递归时传入空格的个数作为参数，将空格作为数字► 递归分解整体成第一个和其余个数为两部分进行比较返回比较结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* 稀疏矩阵的创建输出、朴素转置与快速转置*/typedef struct &#123; int r, c, e;&#125;SYZ; void inputMatrix(SYZ ma[]) &#123; int i = 0, m = 0, n = 0, r = 0, c = 0, e = 0; printf(&quot;输入行数和列数(m n)：&quot;); scanf(&quot;%d %d&quot;, &amp;m, &amp;n); ma[0].r = m; ma[0].c = n; printf(&quot;\n输入三元组(格式如3 4 5), 以回车分隔, 输入0 0 0结束：\n&quot;); scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e); while(r != 0) &#123; i++; ma[i].r = r; ma[i].c = c; ma[i].e = e; scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e); &#125; ma[0].e = i;&#125;void printMatrix(SYZ m[]) &#123; int i, j; int k = 1; printf(&quot;\n矩阵为：\n&quot;); for(i = 1; i &lt;= m[0].r; i++) &#123; for(j = 1; j &lt;= m[0].c; j++) &#123; if(k &lt;= m[0].e &amp;&amp; m[k].r == i &amp;&amp; m[k].c == j) &#123; printf(&quot; %d &quot;, m[k].e); k++; &#125; else printf(&quot; 0 &quot;); &#125; printf(&quot;\n&quot;); &#125;&#125;void generalTrans(SYZ ma[], SYZ mb[]) &#123; if(ma[0].e == 0) return; // 行列维数互换 mb[0].r = ma[0].c; mb[0].c = ma[0].r; mb[0].e = ma[0].e; // 扫描ma三元组,依次加到mb中 int k, col, e; for(k = 1, col = 1; col &lt;= ma[0].c; col++) &#123; for(e = 1; e &lt;= ma[0].e; e++) &#123; if(ma[e].c == col) &#123; mb[k].r = ma[e].c; mb[k].c = ma[e].r; mb[k].e = ma[e].e; k++; &#125; &#125; &#125;&#125;void fillNum(SYZ m[], int num[]) &#123; // 计算不同元素的个数, 存入num[] int i, k; for(i = 0; i &lt;= m[0].c; i++) num[i] = 0; for(i = 0; i &lt;= m[0].e; i++) &#123; k = m[i].c; num[k]++; &#125;&#125;void fillPos(int num[], int pos[], int len) &#123; pos[1] = 1; int k; // 从2到原列数 for(k = 2; k &lt;= len; k++) pos[k] = pos[k-1]+ num[k-1];&#125;void quickTrans(SYZ ma[], SYZ mb[]) &#123; // 一遍扫描，获取num[]和pos[] int num[20], pos[20]; fillNum(ma, num); fillPos(num, pos, ma[0].c); // 一步转置 int i, k, c; mb[0].r = ma[0].c; mb[0].c = mb[0].r; mb[0].e = mb[0].e; for(i = 1; i &lt;= ma[0].e; i++) &#123; c = ma[i].c; k = pos[c]; mb[k].r = ma[i].c; mb[k].c = ma[i].r; mb[k].e = ma[i].e; pos[c]++; &#125;&#125; 123456789101112131415/* 递归打印数字金字塔*/void printTriangle(int j, int n) &#123; if(n &lt;= 0) return; printTriangle(j+1, n-1); // 打印第n行 int i; printf(&quot;\n&quot;); for(i = 0; i &lt; j; i++) printf(&quot; &quot;); for(i = 1; i &lt;= n; i++) printf(&quot;%3d&quot;, i); for(i = n-1; i &gt;0; i--) printf(&quot;%3d&quot;, i);&#125; 1234567891011121314151617/* 递归查找顺序表元素下标、最大值下标*/int find(List L, int i, int j, int x) &#123; if(i &gt; j) return -1; if(L.arr[i] == x) return i; else return find(L, i+1, j, x);&#125;int findMax(List L, int i, int j) &#123; if(i &gt; j) return -1; if(i == j) return i; int k = findMax(L, i+1, j); if(L.arr[i] &gt; L.arr[k]) return i; else return k;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数防抖与函数节流]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[前言► 实际开发中以下场景往往由于事件频繁被触发，从而频繁执行DOM操作、资源加载等行为，导致页面卡顿甚至浏览器崩溃： window对象的 resize、scroll 事件 拖拽时的 mousemove 事件 射击游戏中的 mousedown、keydown 事件 文字输入、自动完成的 keyup 事件 ► 对于 window 的 resize 事件，实际需求一般是停止改变大小n毫秒后执行；而其它事件一般是以一定的频率执行。 ► 针对这两种需求就出现了 debounce (防抖) 和 throttle (节流) 两种解决办法 函数防抖► 如果用手一直按住一个弹簧，它将不会弹起直到你松手为止，也就是调用动作n毫秒后才会执行该动作，如果n毫秒内再次调用则重新计算执行时间 简单实现： debounce 方法接收两个参数，一个是需要防抖动的函数 fn ，另一个是延迟时间 delay 函数节流► 将水龙头拧到水以水滴的形式流出，每隔一段时间就有一滴水流出，也就是预先设定一个执行周期，调用动作的时刻不小于这个执行周期就执行它 简单实现：throttle 方法也是接收两个参数，一个是需要节流的函数 fn ，另一个是函数执行间隔阈值 threshhold 总结可以参考一下防抖和节流与正常触发的对比效果图： ► debounce 可以想象成把很多事件压缩成了一个事件，throttle 可以想象成像阀门一样定时打开调节流量 ► 简单来说，debounce 适合只执行一次的情况，比如 搜索框的自动完成：在停止输入后才提交一次ajax请求； throttle 适合每隔一定时间间隔内执行不超过一次的情况，比如 拖动滚动条、移动鼠标、滚轮事件的处理等]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6基础概念]]></title>
    <url>%2F2017%2F11%2F23%2FES6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[let命令基本用法►用来声明变量，类似于 var，但只在 let 命令所在的代码块内有效 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceErrorb // 1 ►使用 let ，声明的变量只在块级作用域内有效，因此 for 循环的计数器很适合用 let 命令 ►for 循环还有一个特别之处，设置循环变量的那部分是一个副作用域，而循环体内部是一个单独的子作用域 1234for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abs&apos;; console.log(i);&#125; 不存在变量提升►var 命令会有变量提升，也就是变量可以在声明之前使用，值为 undefined ►let 命令改变了这种语法行为，它所声明的变量一定要在声明后使用，否则就报错 暂时性死区►只要块级作用域内存在 let 命令，它所声明的变量就绑定这个区域，不受外部的影响 123456var tmp = 123;if(true) &#123; tmp = &apos;abc&apos;; //ReferenceError let temp;&#125; ►上述代码中虽然存在全局变量 tmp,但是块级作用域内 let 又声明了一个局部变量 tmp，导致后者绑定了这个块级作用域，所以在 let 声明变量之前，对 tmp 赋值都会报错 ►ES6 明确规定，区块中如果存在 let 和 const 命令，在语法上，这个区块就形成了”暂时性死区” ►这也意味着 typeof 命令不再是一个百分百安全的操作，这样规定暂时性死区和 let、const 语句不出现变量提升，主要就是为了防止变量在声明前就使用它从而减少错误 不可重复声明► let 不允许在相同作用域内，重复声明同一个变量，也即不能在函数内部重新声明参数 123456789function func(arg) &#123; let arg; //执行会报错&#125;function func(arg) &#123; &#123; let arg; //不会报错 &#125;&#125; const命令基本用法►用来声明一个只读的常量，一旦声明，值就不能改变，这也意味着，const 一旦声明变量就必须立即初始化，不能留到之后再赋值，其它与 let 命令类似 本质►const 实际保证的，不是变量的值不能改动，而是变量所指向的内存地址不能改动 12345678const foo = &#123;&#125;;//添加属性可以成功foo.prop = 123;foo.prop;//指向另一个对象就会报错foo = &#123;&#125;; 箭头函数基本用法►ES6 允许使用“箭头”（=&gt;）定义函数 123456var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;; ►如果箭头函数不需要参数或者需要多个参数，就使用圆括号 1234567891011var f = () =&gt; 5;//等同于var f = function() &#123; return 5;&#125;;var sum = (num1,num2) =&gt; num1 + num2;//等同于var sum = function(num1,num2) &#123; return num1 + num2;&#125; ►代码块多于一条语句的话就要用大括号括起来并且使用 return 语句返回 ►由于大括号被解释为代码块，所以箭头函数返回的是一个对象的话，必须在对象外面加上括号 12345var getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot;&#125;);//等同于var getTempItem = function(id) &#123; return &#123; id: id, name: &quot;Temp&quot;&#125;;&#125;; ►箭头函数使表达式更简洁12const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n; ►其它用途… 使用注意点►函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象 ►不可以当作构造函数，即不能使用 new 命令 ►没有 arguments 对象，需要的话可以用 rest 参数代替 ►不能使用 yield 命令，所以箭头函数不能用作 Generator 函数 尤其注意第一点，在箭头函数中 this 对象的指向是固定的 123456789function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;,100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); // id: 42 ►上例中 setTimeout 的参数是一个箭头函数，它的定义生效在 foo 函数生成时，真正执行就要等到100ms后，如果是普通函数的话，执行时 this 应该指向全局对象 window ，即输出 21 ，但箭头函数导致this总是指向函数定义生效时所在的对象( {id: 42} )，所以输出 42 . ► this 指向的固定化，不是箭头函数内部有这样的机制，而是它没有自己的 this，所以它内部的 this 就是外层代码块的 this ,这也是它不能用作构造函数的原因 所以箭头函数转换成ES5的代码如下： 123456789101112function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id: &apos;,this.id); &#125;,100);&#125;function foo() &#123; var _this = this; setTimeout(function() &#123; console.log(&apos;id: &apos;,_this.id); &#125;,100);&#125; 对象和数组数组的解构赋值► ES6 允许按照一定模式，从数组和对象中提取值同时对变量进行赋值，这被称为 解构 1let [a,b,c] = [1,2,3]; 上面的代码中从数组中提取值并按照对应位置对变量赋值 本质上这种写法属于”模式匹配”, 只要等号两边的模式相同，左边的变量就会被赋予对应的值, 如果不完全解构即左边的模式只匹配一部分的右边的数组，解构也成功 一些例子：1234567891011121314151617/*完全解构*/let [ , , third] = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;];third // &apos;baz&apos;let [head, ...tail] = [1,2,3,4];head // 1tail // [2,3,4]/*不完全解构*/let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4]a // 1b // 2d // 4 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值 对象的解构赋值► 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名才能正确取到值 12345678910let &#123; bar, foo &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;foo // &quot;aa&quot;bar // &quot;cc&quot;let &#123; baz &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;baz // undefined/*变量名与属性名不一致的写法*/let &#123; foo: baz &#125; = &#123; foo: &apos;aa&apos;, bar: &apos;cc&apos; &#125;;baz // &quot;aa&quot; 变量名与属性名不一致的写法实际上说明，对象的解构赋值是下面形式的简写： 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aa&quot;, bar: &apos;cc&apos; &#125;; 即对象的解构赋值是先找到同名属性，再赋给对应的变量。真正被赋值的是后者而不是前者 ► 对象的解构赋值，可以很方便地将现有对象的方法赋值给对应的变量 1let &#123; log, sin, cos &#125; = Math; 解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象 用途12345/*交换变量的值*/let x = 1;let y = 2;[x, y] = [y, x] 12345678910111213141516/*从函数返回多个值*/// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();//返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 12345/*函数参数的定义*/// 参数是一组无次序的值时function f(&#123; x, y, z &#125;) &#123; ... &#125;f(&#123; z: 3, y: 5, x: 0 &#125;) 1234567/*提取JSON数据*/let jsonData = &#123; id: 42, data: [860, 504]&#125;;let &#123; id, data: number &#125; = jsonData; 123456789jQuery.ajax = function(url, &#123; async = true, beforeSend = function() &#123;&#125;, cache = true, complete = function() &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123;&#125;; 123/* 输入模块的指定方法 */const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础]]></title>
    <url>%2F2017%2F11%2F23%2FjQuery%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础核心代码风格‘$’： jQuery 当中最重要并且独有的对象：jQuery对象1234567$(function() &#123;&#125;); //执行一个匿名函数$(&apos;#box&apos;); //进行执行的ID元素选择$(&apos;#box&apos;).css(&apos;color&apos;,&apos;red&apos;); //执行功能函数/*等同于*/jQuery(function() &#123;&#125;);jQuery(&apos;#box&apos;); 执行功能函数时，先获取元素返回 jQuery 对象后再调用功能函数，同时返回的还是 jQuery 对象，所以可以连缀不停的调用功能函数 1$(&apos;#box&apos;).css(&apos;color&apos;,&apos;red&apos;).css(&apos;font-size&apos;,&apos;50px&apos;); 加载模式jQuery 等待加载： 1$(document).ready(function () &#123;&#125;); 它的执行时机只需等待网页中的DOM结构加载完毕就可以执行包裹的代码，并且可以执行多次不会覆盖 window.onload 需要等待图片之类的大型元素加载完毕后才能执行JS代码，在网速慢的情况下，图片还在缓慢加载时，页面上任何的JS交互功能都会处在假死状态，同时只能执行一次，会给实际开发带来困难 对象互换jQuery 对象是 jQuery 库独有的对象，通过JS封装而来，可以直接输出得到它的信息 只要使用代码包裹以后，最终返回的都是 jQuery 对象，好处就是可以连缀处理，如果需要返回原生的DOM对象的话，可以这么处理： 1$(&apos;#box&apos;).get(0); //ID元素的第一个原生DOM 从get(0)的索引看出， jQuery 可以批量处理DOM，在循环遍历上会更方便 多个库之间的冲突同一个项目中引入多个第三方库时，由于没有命名空间的约束，不同库之间很容易发生冲突 对于同样使用’$’作为基准起始符的库(如 Base 库)，想和 jQuery 共存的话有两种办法： 先引入 jQuery 库，这样’$’的所有权就归之后的库所有， jQuery 可以直接用jQuery对象调用，或者创建一个新符(‘$$’)给它用： 12345var $$ = jQuery;$(function () &#123; $(&apos;#box&apos;).get(0); // 都是Base的$ $$(&apos;#box&apos;).width(0); // jQuery的$$&#125;); 后引入 jQuery 库，’$’归 jQuery 库，jQuery 有一个方法可以放弃： 12345jQuery.noConflict(); // 将$符所有权剔除var $$ = jQuery;$(function () &#123; ... // $属于Bae, $$属于jQuery&#125;); 工具函数字符串操作12var str = &apos; sad&apos;;$.trim(str); //去除字符串左右空格 数组和对象操作12345678910/*$.each()遍历数组*/var arr = [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;];$.each(arr,function(index, value) &#123; $(&apos;#box&apos;).html($(&apos;#box&apos;).html + index + &apos;.&apos; + value + &apos;&lt;br&gt;&apos;);&#125;);/*遍历对象*/$.each($.ajax(), function(name, fn) &#123; $(&apos;#box&apos;).html($(&apos;#box&apos;).html() + name + &apos;.&apos; + &apos;&lt;br&gt;&lt;br&gt;&apos;);&#125;) 123456/*$.grep()数据筛选*/var arr = [5,3,5,7,45,98,23,10];$.grep(arr, function(element, index) &#123; return element &lt; 6 &amp;&amp; index &lt; 5;&#125;);/*index从0开始计算*/ 1234567/*$.map()修改数据*/var arr = [5,6,87,54,32,4,10];$.map(arr, function(element, index) &#123; if(element &lt; 6 &amp;&amp; index &lt; 5) &#123; return element + 1; &#125;&#125;); ► $.merge() 合并两个数组 ► $.unique() 删除重复的DOM元素 ► .toArray() 合并多个DOM元素组成数组 … 测试操作 URL操作123456/*$.param()将对象键值对转换为URL字符串键值对*/var obj = &#123; name : &apos;Lee&apos;, age : &apos;20&apos;&#125;;$.param(obj); 其它操作jQuery提供了一个预备绑定函数上下文的工具函数: $.proxy(),可以解决如外部事件触发调用对象方法时this的指向问题 12345678910111213141516171819/*$.proxy()调整this指向*/var obj = &#123; name : &apos;Lee&apos;, test: function() &#123; alert(this.name); &#125;&#125;$(&apos;#box&apos;).click(obj.test); //this指向为#box元素，undefined$(&apos;#box&apos;).click($.proxy(obj,&apos;test&apos;)); //this指向为对象box，Lee/*等效于*/var obj = &#123; name : &apos;Lee&apos;, test : function() &#123; var _this = obj; alert(_this.name); &#125;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象与原型]]></title>
    <url>%2F2017%2F11%2F23%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这里会先把之前已经写好的总结陆续放上来，主要也是有一个时间顺序记录自己的学习过程（(#^.^#)） 面向对象与原型一.创建对象：1.最基本的创建一个对象并添加属性和方法 缺点：每创建一个类似对象，都会产生大量代码 解决：工厂模式解决实例化对象产生大量重复代码，即设计一个实例化的函数 2.工厂模式： 新问题：无法区别实例的来源对象 解决：用构造函数来创建特定的对象 3.构造函数 重复实例化和对象识别的问题都得到解决 规范：1.函数名和实例化名相同并且首字母大写（有助于区分构造函数和普通函数） 2.必须用new运算符创建对象（与普通函数的区别） 与工厂模式的区别：1.构造函数没有显式地创建对象 2.直接把属性方法赋给this对象 3.没有return语句 小问题：在对run方法的引用上每次实例化的地址都不同，即alert(person1.run == person2.run)的结果是false 二.原型创建的每个函数都有一个prototype属性（对象）。包含可以由特定类型的所有实例共享的属性和方法 1.构造函数与原型模式的声明方式： 通过两种方式的对比可以明白为什么它们在对方法的引用地址上会有区别 2.原型模式的执行流程：构造函数实例里有属性或方法的话就返回，没有就去它的原型对象中找 对属性是在构造函数的实例里还是原型里的判断：hasOwnProperty()---&gt;实例有返回true in操作符 ---&gt;只要存在就返回true ---&gt;两种方法结合判断原型中是否存在属性 3.原型模式创建对象的缺点：共享—–如果某次实例化时改变了原型中的属性，则会影响到之后的实例化对象 —–如果有传入参数的话，之后的实例化对象属性会覆盖掉之前的，无法独立 即用相同原型创建的对象访问原型中的属性时，访问的都是同一个对象解决：构造函数+原型模式的组合模式： 构造函数适合封装属性 原型模式适合封装方法 组合模式： 解决了传参和共享的难题，进一步的优化是把构造函数和原型封装到一起 动态原型模式： 以上两种是JS创建对象时使用较多的方式，优先考虑动态原型模式 4.补充：寄生构造函数：工厂模式+构造函数模式 —&gt;需要创建一个具有额外方法的引用类型 稳妥构造函数： —&gt;构造函数中不用this,外部实例化函数时不用new 三.继承1.原型链正统面向对象语言实现继承的方式：接口实现和继承 ECMAScript只支持继承，实现的方式是依靠原型链 实质：通过原型让一个引用类型继承另一个引用类型的属性和方法 被继承的函数称为超类型（父类、基类）;继承的函数称为子类型（子类、派生类） 继承存在的问题： 字面量重写原型会中断关系 子类型无法给超类型传递参数 2.借用构造函数（对象冒充）—&gt;解决引用共享和不能给超类型传参的问题 新问题：没有原型，无法复用 3.组合继承（最常用）—&gt;通过原型链继承原型的属性方法 —&gt;通过借用构造函数继承实例的属性 —&gt;既实现了函数复用，又保证每个实例的独立性 4.原型式继承—&gt;借助原型并基于已有的对象创建新对象，不用再创建自定义类型 5.寄生式继承（原型式+工厂模式）—&gt;为了封装创建对象的过程 6.寄生组合式继承—&gt;处理组合式继承的问题：超类型在使用过程中被调用了两次： 创建子类型时 在子类型构造函数内部 通过原型链的混成形式调用方法，解决了两次调用的问题 总结：1.创建对象： 工厂模式：用简单的函数创建对象，添加属性方法然后返回它 构造函数模式：可以创建特定的对象，但是它的成员包括函数都不能复用 原型模式：利用函数的prototype属性来指定应该共享的方法和属性 组合模式：利用构造函数定义实例属性，利用原型定义共享方法 2.继承： 原型链继承：通过原型让一个引用类型继承另一个引用类型的属性和方法 借用构造函数（对象冒充）：解决引用共享和超类型不能传参的问题 组合继承：通过原型链继承原型的属性方法，通过借用构造函数继承实例的属性，最常用，但有多次调用超类型构造函数导致的低效率问题 原型式继承：在已有对象上借助原型创建新对象，新对象可以进一步添加属性方法 寄生式继承：封装了创建对象的过程，基于这个可以进一步增强对象 寄生组合式继承：通过原型链的混成形式调用方法，避免多次调用超类型构造函数，基于类型继承的最有效方式]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建你的博客]]></title>
    <url>%2F2017%2F11%2F23%2FHexo-blog%2F</url>
    <content type="text"><![CDATA[一开始自己用hexo搭博客的时候踩了比较多坑，在这里想总结一下做一个简单的搭建教程，后续使用再慢慢完善 初始配置环境 node 作用：生成静态页面 Git 作用：将本地的hexo内容提交到github上 申请Github 作用：作为博客的远程仓库和服务器 Hexo的安装及初始化环境配置好后，创建一个文件夹，进入后执行以下命令： npm install hexo-cli -g 安装hexo hexo init 初始化 npm install hexo generate 生成静态页面 hexo server 启动本地服务之后浏览器输入localhost:4000 就可以看到一个默认的hexo博客啦 Github上的配置进入Github新建一个仓库，这里特别要强调的是仓库名的格式必须为yourusername.github.io，yourusername就是你的Github用户名，这里错误的话，之后直接访问就会404（我就是这样o(╥﹏╥)o）,建好以后就clone一下HTTPS形式的url（这里先不用SSH） 本地Hexo文件的修改进入Hexo文件根目录下的_config.yml，打开以后拉到最下面的deploy那里，改成如下形式：1234deploy: type: git repo: https://github.com/fxbabys/fxbabys.github.io.git branch: master 这里也特别要强调的是冒号后面一定要加空格 然后执行命令安装: npm install hexo-deployer-git --save再执行配置命令: hexo deploy这样本地文件就上传到Github远程库上了，访问https://fxbabys.github.io/就行了 之后每次部署发布文章可以按下面的步骤进行： hexo new &quot;文章名称&quot; 这样会在source/_posts下生成一个md文档 hexo server(hexo s) 上传前本地先预览一下效果 hexo generate(hexo g) hexo deploy(hexo d) 到这里搭建一个hexo博客和发布新文章就完成啦！更个性化的设置可以自己去Hexo官方文档上查看，介绍的都很详细，也可以去网上找教程再多折腾一些自己的喜好（(^▽^)）]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome]]></title>
    <url>%2F2017%2F11%2F19%2Fwelcome%2F</url>
    <content type="text"><![CDATA[Welcome to my technology blog !This is the first blog I built myself and I will update my study and thinking life in it later.I hope it can also help others who read this blog，let’s step forward together！]]></content>
  </entry>
</search>

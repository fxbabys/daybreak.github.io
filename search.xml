<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flex-Grid布局]]></title>
    <url>%2F2018%2F03%2F27%2FFlex-Grid%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[关于Flex&amp;Grid布局的语法实例 Flex：更简洁制作智能布局的现代语法 w3c于09年提出的一个新的布局方案，可以方便地实现各种页面布局 移动端开发的主流：H5页面、微信小程序 对比：实现子元素在父元素水平垂直居中的效果传统定位方案：1234567891011.dad &#123; position: relative;&#125;.son &#123; position: absolute; margin: auto; top: 0; left: 0; bottom: 0; right: 0;&#125; 123456789101112131415.par &#123; background-color: red; width: 300px; height: 500px; position: relative;&#125;.child &#123; background-color: blue; width: 200px; height: 200px; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 上面两种方案都需要同时对父元素与子元素设置定位 弹性盒：12345678910111213.par &#123; background-color: red; width: 300px; height: 500px; display: flex; justify-content: center; align-items: center;&#125;.child &#123; background-color: blue; width: 200px; height: 200px;&#125; 语法详解：初始概念：主轴/纵轴(flex-direction)：默认为row：从左到右、水平排列 column：从上到下、竖直排列开始：Flex容器：父元素显式设置：display: flex Flex项目：Flex容器内的子元素实例—简易导航系统的实现：123456789101112131415161718192021222324252627282930313233343536373839404142// css部分参考html, body &#123; margin: 0; padding: 0; list-style: none;&#125;nav &#123; height: 80px; background-color: #646262; display: flex; align-items: center;&#125;ul &#123; display: flex; flex-grow: 1&#125;ul li &#123; width: 100px; margin: 10px; text-align: center; color: white;&#125;ul li:nth-child(1) &#123; margin-left: auto;&#125;ul button &#123; margin-right: auto; margin-left: 5%; width: 70px; color: white; font-size: 1em; background-color: #50cd50; cursor: pointer;&#125;ul button:hover &#123; background-color: green; transition: all .5s ease;&#125;img &#123; width: 20%; margin-left: 5%;&#125; 实例二—自适应的导航栏关键：搜索框自动填满导航栏剩余的位置实现：.search的属性设为flex: 1(flex-grow、flex-shrink、flex-basis的缩写)扩展：媒体查询：12345678910111213141516171819202122@media all and (max-width: 600px) &#123; .container &#123; flex-wrap: wrap; &#125; .container &gt; li &#123; flex: 1 1 50%; &#125; .search-input &#123; text-align: center; &#125;&#125;@media all and (max-width: 400px) &#123; .container &gt; li &#123; flex: 1 1 100%; &#125; .search-input &#123; text-align: center; &#125; .search &#123; order: 1; &#125;&#125; Grid： CSS布局的未来 二维布局 基本概念： 网格线：分界线构成了网格的结构 网格轨道：两个相邻网格线之间的空间 网格单元格：两个相邻行与相邻列之间的网格线空间 网格区域：由任意数量的网格单元格组成 网格容器属性： grid-template-columns/row：利用空格分隔的值定义网格的列与行 grid-template-areas：定义网格区域名称，从而定义网格模板 grid-(column/row)-gap：指定网格线的大小，即行列之间的宽度 justify/align-content/items：沿列/行轴对齐网格项的内容/网格 网格项属性： grid-column/row：使用特定的网格线确定网格项在网格中的位置 grid-area：对应网格模板给网格项命名 justify/align-self：沿列/行轴对应网格项中的内容 实例：自适应的首页布局：123456789101112131415161718.container &#123; height: 100%; display: grid; grid-template-columns: 1fr 5fr; grid-template-rows: 100px auto 100px;&#125;.header &#123; grid-column: 1 / -1;&#125;.menu &#123; grid-row: 2 / 3;&#125;.content &#123; grid-column: 2 / -1;&#125;.footer &#123; grid-column: 1 / -1;&#125; 参考：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.htmlhttps://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.htmlhttps://www.w3cplus.com/css3/a-complete-guide-css-grid-layout.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5&CSS3关键点]]></title>
    <url>%2F2018%2F03%2F13%2FHTML5-CSS3%E5%85%B3%E9%94%AE%E7%82%B9%2F</url>
    <content type="text"><![CDATA[工作室第七期培训第二课主讲了关于前端三大基础的知识，重点落在HTML5与CSS3上，这里做一个记录，类似的知识以后不断更新~ HTML: DOM树：浏览器解析HTML文本的形式，树上的所有节点都可以通过js访问 元素类型： 块级元素与行内元素的区别 区别一： 块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。区别二： 块级：块级元素可以设置宽高 行内：行内元素不可以设置宽高区别三： 块级：块级元素可以设置margin，padding 行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。区别四： 块级：display:block; 行内：display:inline; 可以通过修改display属性来切换块级元素和行内元素 语义化：用正确的标签做正确的事情，不仅仅让浏览器易于理解与搜索引擎解析，也要让人易于阅读 CSS： 盒模型： box-sizing设置盒模型宽度的计算规则，一般设置成border-box（IE传统盒模型） 浮动： 脱离文档流，浮动后横向排列，浮动元素总是保证自己的顶部和上一个元素（标准流中的）的底部对齐；clear只能影响使用清除的元素本身 扩展：BFC（块级格式化上下文） 浮动与清除浮动只会应用于同一个BFC内的元素 计算BFC的高度时，浮动元素也会参与计算（浮动元素的父元素高度塌陷问题） 定位：absolute: 根据最近设置定位的祖先元素排列 怎样居中一个div： 12345678910111213141516171819202122232425262728293031// 传统方案：position + transform .par &#123; background-color: red; width: 300px; height: 500px; position: relative; &#125; .child &#123; background-color: blue; width: 200px; height: 200px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;// 弹性盒（考虑兼容性）：flex .par &#123; background-color: red; width: 300px; height: 500px; display: flex; justify-content: center; align-items: center; &#125; .child &#123; background-color: blue; width: 200px; height: 200px; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Js基础笔记]]></title>
    <url>%2F2018%2F03%2F04%2FJs%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Github关于js面试题的知识整理，这里慢慢积累~ 解释事件委托事件委托是一种利用事件冒泡机制，只监听父元素而不用监听每个子元素的技术。 优点：只有父元素需要一个监听器，不需要每个子元素都去监听，减少了内存占用 ​ 避免了对子元素的繁杂处理，可以只针对父元素进行处理 例子： e.target 点击元素 e.currentTarget 当前元素 1234567891011121314151617181920212223&lt;style&gt; #par &#123; background: blue; width: 100px; height: 600px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;par&quot;&gt; &lt;div id=&quot;child1&quot;&gt;Item 1&lt;/div&gt; &lt;div id=&quot;child2&quot;&gt;Item 2&lt;/div&gt; &lt;div id=&quot;child3&quot;&gt;Item 3&lt;/div&gt; &lt;div id=&quot;child4&quot;&gt;Item 4&lt;/div&gt; &lt;div id=&quot;child5&quot;&gt;Item 5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(&quot;par&quot;) .addEventListener(&quot;click&quot;, function(e) &#123; console.log(e.target); console.log(e.currentTarget); &#125;);&lt;/script&gt; 解释js中的this如何工作关键：this的值取决于函数怎样被调用 使用了 new ，则 this 指向函数内部 123456789function Constructor() &#123; console.log(this); this.value = 10; console.log(this);&#125;new Constructor();// Constructor&#123;&#125;// Constructor&#123;value: 10&#125; 使用了 apply call 或 bind , this 指向作为参数传入的对象 12345678910function fn() &#123; console.log(this);&#125;var obj = &#123; value: 5&#125;;var boundFn = fn.bind(obj);boundFn(); // -&gt; &#123; value: 5 &#125; // 这里bind只是作为定义绑定了thisfn.call(obj); // -&gt; &#123; value: 5 &#125;fn.apply(obj); // -&gt; &#123; value: 5 &#125; 作为方法调用，如 obj.method()，this 指向这个函数属性的对象 1234567var obj = &#123; value: 5, printThis: function() &#123; console.log(this); &#125;&#125;;obj.printThis(); // -&gt; &#123; value: 5, printThis: ƒ &#125; 以上都没有，则 this 指向全局对象即 window，在严格模式下是undefined 1234function fn() &#123; console.log(this);&#125;fn(); // -&gt; Window &#123;stop: ƒ, open: ƒ, alert: ƒ, ...&#125; 以上两种以上方式，则优先级更高的规则决定 this 的值 ES6箭头函数中，this 指向函数创建时作用域的值，忽略以上所有规则 扩展：this 解释原型继承如何工作所有的js对象都有一个 prototype 属性，指向这个对象的原型对象 当一个属性被访问时，如果直接存在这个对象中则输出 如果不存在这个对象中则通过原型链去找它的原型对象，直到找到这个属性或者原型链末端 这个机制模拟了经典的继承但实际上更像是委托 对于AMD和CommonJS如何认识两种方式都是用来实现模块系统，这个概念直到ES6才在js中出现 CommonJS是同步的，为了服务端开发而设计，语法更接近于其它语言的风格，同时使用服务器端与浏览器端开发之间js切换开销也更小 AMD是异步的，支持异步加载模块，更像是为了浏览器端开发而设计，但是语法风格冗杂，而且大部分时候不是必要的，特别是js只放在一个模块包时 ES6中支持同步与异步加载模块，使得我们可以坚持用一种方法，虽然现在并没有在浏览器与Node端完全展开，但我们可以使用转换程序来转换代码 解释function foo(){}() 为什么没有像IIFE一样工作，需要修改哪些内容才能使它成为一个IIFEIIFE 的含义是立即执行函数表达式，js解析器读取 function foo(){}() 成 function foo(){} 和 () ，前者是一个函数声明而后者是一个括号尝试调用一个函数但是并没有特别声明，因此会报错 修改：(function foo() {})() or (function foo() {}()) 它们不会在全局范围内公开，所以我们甚至可以省略 foo null undefined undeclared 之间的区别，怎样检查它们 undeclared 变量是创建一个变量赋值时没有使用 var let 或 const ，这会导致它成为一个全局变量，在严格模式下会报 ReferenceError ，所以尽量避免使用，可以将它放入 try/catch块中检查 123456function foo() &#123; x = 1; // Throws a ReferenceError in strict mode&#125;foo();console.log(x); // 1 undefined 变量是已经被 declared 但是没有赋值，如果一个函数没有任何返回值也是 undefined ，可以使用 === 或者 typeof 去检查，如果使用 == 检查则 null 也会返回 true 12345678910var foo;console.log(foo); // undefinedconsole.log(foo === undefined); // trueconsole.log(typeof foo === &apos;undefined&apos;); // trueconsole.log(foo == null); // true. Wrong, don&apos;t use this to check!function bar() &#123;&#125;var baz = bar();console.log(baz); // undefined null 变量是明确地被赋值为 null 的变量，代表没有值（与undefined不同）,使用 typeof 检查返回 object, 同样必须使用 === 比较检查，否则 undefined 也会返回 true 1234var foo = null;console.log(foo === null); // trueconsole.log(foo == undefined); // true. Wrong, don&apos;t use this to check! 解释闭包，如何使用闭包是函数与函数声明时词法作用域的结合，词法的意思是词汇范围界定使用在源代码声明变量的位置来确定变量的位置(?)，闭包就是在外部函数返回以后也可以访问外部函数中变量作用域链的函数 使用场景： 用闭包实现数据隐私或是模拟private方法，模块模式中经常用到 部分应用程序嵌套调用的场合 ​ 描述 forEach 和 map 循环的区别，如何抉择forEach 遍历数组中的所有元素 每个元素都执行回调函数 没有返回值 123456const a = [1, 2, 3];const doubled = a.forEach((num, index) =&gt; &#123; // Do something with num and/or index.&#125;);// doubled = undefined map 遍历数组中的所有元素 每个元素都执行回调函数返回一个新元素，最终结果返回一个新数组 123456const a = [1, 2, 3];const doubled = a.map(num =&gt; &#123; return num * 2;&#125;);// doubled = [2, 4, 6] 主要区别：map 返回一个新数组而 forEach 不返回，即如果需要不影响原有数组的结果使用 map 更好，如果不在意原有数组的影响可以使用forEach 扩展： filter 遍历数组所有元素 每个元素执行回调函数做判断，true保留，false取出，最终返回一个过滤的数组 123let ages = data.filter((animal) =&gt; &#123; return animal.type === &apos;dog&apos;;&#125;) reduce 遍历数组所有元素 每个元素执行回调函数，至少接收两个参数，专为累加这类操作而设计，最终返回一个相加的总和 123.reduce((sum, animal) =&gt; &#123; return sum + animal.age;&#125;); 扩展阅读：map、filter、reduce 匿名函数的典例 IIFE，避免变量泄露到全局 123(function() &#123; // some code.&#125;)(); 一次性使用的回调，在调用它们的代码内部进行声明时会更具有可读与自包含性 123setTimeout(function() &#123; console.log(&quot;hei&quot;);&#125;, 1000); 函数式编程或者Loadsh的参数（类似于回调） 12345const arr = [1, 2, 3];const double = arr.map(funtion(e) &#123; return e*2;&#125;);console.log(double); 怎样组织自己的代码，比如模块模式或者经典继承一开始会使用面向对象的方式创建Backbobe模型并添加方法 但现在更好的趋势是使用基于React/Redux鼓励单向函数编程方式的Flux体系结构，使用普通对象与编写实用纯函数来操作这些对象，并且使用 actions 和 reducers 来处理状态 关于经典继承的扩展阅读 new rules 后续学深入再重新理解这个问题 ==]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP5博客搭建知识汇总]]></title>
    <url>%2F2018%2F02%2F26%2FThinkPHP5%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[工作室第七期培训后期主要以TP5搭建个人博客为主，这里将需要用到的知识笔记做个整理再加一些扩展~ ThinkPHP的核心就是MVC思想： Controller： 控制器，整个应用逻辑交互的处理 Model：模型，数据库操作的逻辑处理 View：视图，页面数据的呈现 控制器新建控制器 前台控制器目录下（application/index/controller）新建控制器文件User.php 书写User.php 12345678910&lt;?php // 声明命名空间 namespace app\index\controller; // 声明控制器 class User &#123; public function index() &#123; return &quot;User控制器下的index方法&quot;; &#125; &#125;?&gt; 地址栏访问：域名/index.php/index/User/index 注意： 控制器文件名必须首字母大写，驼峰式命名 控制器名必须跟文件名一一对应 命名空间必须和文件名对应 如果控制器名为驼峰式 UserInfo.php 1域名/index.php/index/user_info/index 控制器如何加载页面 系统View类 123456$view = new \think\View;return $view-&gt;fetch();use think\View;$view = new View();return $view-&gt;fetch(); 系统Controller类 继承系统控制器类 12use think\Controller;class User extends Controller 直接使用系统控制器类的方法 1return $this-&gt;fetch(); 系统函数 1return view(); 控制器的初始化 初始化方法必须继承系统控制器 123public function _initialize() &#123; echo &quot;初始化方法&quot;;&#125; 只要调用控制器下的任意方法，都会先找初始化方法 控制器初始化方法的使用 用来提取控制器下公共的代码 后台权限把控 页面跳转 页面跳转基于系统控制器类，所以控制器必须继承系统控制器 方法所在路径： 1www/tp5/thinkphp/library/traits/controller/Jump.php 跳转方式 成功跳转： 123// $this-&gt;success(提示信息,跳转地址,用户自定义数据,跳转跳转,header信息);// 跳转地址未设置时 默认返回上一个页面$this-&gt;success(&apos;跳转成功&apos;,url(&apos;index/index&apos;)); 失败跳转： 1$this-&gt;error(&apos;跳转失败&apos;); 跳转方法给模板页面的数据 $code 返回的状态码 1 0 $msg 页面提示信息 $wait 等待时间 $url 指定跳转页面，默认返回上一个页面 $data 用户自定义返回的数据 相关配置文件 123// 默认跳转页面对应的模板文件&apos;dispatch_success_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_jump.tpl&apos;,&apos;dispatch_error_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;dispatch_jump.tpl&apos;, 修改成功、失败的模板页面 文件目录：www/tp5/thinkphp/tpl/dispatch_jump.tpl 修改成功、失败模板页面 用户自定义页面跳转模板 修改配置文件 123// 默认跳转页面对应的模板文件&apos;dispatch_success_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;success.tpl&apos;,&apos;dispatch_error_tmpl&apos; =&gt; THINK_PATH . &apos;tpl&apos; . DS . &apos;error.tpl&apos;, 在tpl目录下新建 success.tpl 和 error.tpl 模板 自定义书写跳转页面 重定向 作用：重定向(Redirect)就是通过各种方法将各种网络请求重新定向到其它位置 使用：12redirect(&apos;跳转地址&apos;, &apos;其他参数&apos;, code, &apos;隐式参数&apos;);$this-&gt;redirect(&apos;index/index&apos;, [&apos;id&apos;=&gt;100, &apos;name&apos;=&gt;&apos;abc&apos;]); 空操作和空控制器 空操作 1234// 主要解决一些用户恶意的地址栏输入，导致报错影响交互public function _empty() &#123; $this-&gt;redirect(&apos;index/index);&#125; 空控制器：controller目录下新建Error.php 123456789101112namespace app\index\controller;use think\Controller;class Error extends Controller &#123; public function index() &#123; $this-&gt;redirect(&apos;index/index&apos;); &#125; public function _empty() &#123; $this-&gt;redirect(&apos;index/index&apos;); &#125;&#125; 注意： 网站上线时每一个控制器都必须添加空操作 不论前台后台都需要写一个空控制器 模型新建数据模型 手动新建 打开前台模块（www/tp5/application/index） 新建model目录 在model目录下新建User.php 命令新建 切换到项目目录1php think make:model app\index\model\Users 注意 数据模型的名字建议和表名一致 如果表名与模型名不一致，可以设置表名 1protected $table = &quot;user&quot;; 如果表名有下划线，模型名使用驼峰法命名 模型的实例化 调用静态方法 123use app\index\model\User;$res=User::get(1);dump($res-&gt;toArray()); 实例化数据模型 123$user=new \app\index\model\User();$res=$user::get(2);dump($res-&gt;toArray()); 使用loader 12345use think\Loader;$user=Loader::model(&quot;user&quot;);$res=$user::get(3);dump($res-&gt;toArray()); 使用助手函数 123$user=model(&quot;user&quot;);$res=$user::get(4);dump($res-&gt;toArray()); 查询操作 单条数据 1234567891011// get方法 // 使用数字 $res=User::get(1); // 默认主键 // 使用数组 $res=User::get([&quot;name&quot;=&gt;&apos;zgg&apos;]); // 默认查找用户名 // 使用闭包函数 $res=User::get(function($query)&#123; $query-&gt;where(&quot;id&quot;,15); &#125;);// find方法 $res=User::where(&quot;id&quot;,13)-&gt;find(); 多条数据 123456789101112131415161718// all // 所有数据 $res=User::all(); // 字符串 $res=User::all(&quot;1,2,3&quot;); // 数组 $res=User::all([5,6,7]); // 数组 $res=User::all([&apos;pass&apos;=&gt;&apos;123&apos;]); // 闭包 $res=User::all(function($query)&#123; $query-&gt;where(&quot;pass&quot;,&quot;123&quot;) -&gt;whereOr(&quot;pass&quot;,&quot;456&quot;) -&gt;order(&quot;id&quot;,&quot;desc&quot;); &#125;);// select 和 all 基本类似 $res=User::select(); $res=User::limit(2)-&gt;select(); 获取值 1234// 获取某个值$res=User::where(&quot;id&quot;,5)-&gt;value(&quot;name&quot;);// 获取某列值$res=User::column(&quot;name&quot;,&quot;id&quot;); 动态查询 123// getBy字段名, 查询出第一条数据$res = User::getByName(&quot;user&quot;);dump($res-&gt;toArray()); 增加操作 设置属性 123456// 设置属性$user = new User();$user-&gt;name = &quot;user&quot;;$user-&gt;pass = 13;$user-&gt;age = 22;$user-&gt;save(); // 返回影响行数 通过data方法 1234567$user=new User();$user-&gt;data([ &quot;name&quot;=&gt;&quot;yzmedu22&quot;, &quot;age&quot;=&gt;&quot;22&quot;, &quot;pass&quot;=&gt;&quot;qwe&quot;, ]);$user-&gt;save(); // 返回影响行数 实例化时 1234567891011$user=new User([ &quot;name&quot;=&gt;&quot;yzmedu23&quot;, &quot;pass&quot;=&gt;&apos;zxc&apos;, &quot;age&quot;=&gt;20 ]);// 返回影响行数$user-&gt;save();// allowField 屏蔽掉数据库中不存在的字段$user-&gt;allowField(true)-&gt;save();// 指定插入数据库的字段$user-&gt;allowField([&apos;name&apos;,&apos;age&apos;])-&gt;save(); 获取自增的id 1dump($user-&gt;id); 增加多条数据 123456$user=new User();$list=[ [&apos;name&apos;=&gt;&quot;yzmedu33&quot;,&quot;age&quot;=&gt;33], [&apos;name&apos;=&gt;&quot;yzmedu34&quot;,&quot;age&quot;=&gt;34]];$user-&gt;saveAll($list); create方法 123$user=User::create([ &quot;name&quot;=&gt;&quot;yzmedu35&quot;, &quot;age&quot;=&gt;35 删除操作12345678910111213141516171819202122232425// $user=User::get(1);// 返回影响行数// dump($user-&gt;delete());// 删除主键2$user=User::destroy(2);// 删除主键3,4,5$user=User::destroy(&quot;3,4,5&quot;);$user=User::destroy([6,7,8]);// 删除name$user=User::destroy([&apos;name&apos;=&gt;&quot;yzmedu23&quot;]);// 删除多个条件$user=User::destroy([&apos;name&apos;=&gt;&apos;yzmedu33&apos;,&apos;age&apos;=&gt;33]);// 使用闭包$user=User::destroy(function($query)&#123; $query-&gt;where(&quot;id&quot;,&quot;&lt;&quot;,&quot;15&quot;);&#125;);// 删除数据$user=User::where(&quot;id&quot;,&quot;&gt;&quot;,&quot;19&quot;)-&gt;delete();dump($user); 修改操作123456789101112131415161718192021222324252627282930313233343536373839404142// 设置字段更新数据 $user=User::get(15); $user-&gt;age=19; $res=$user-&gt;save(); // 直接数组修改 $user=new User; $res=$user-&gt;save( [ &quot;pass&quot;=&gt;&quot;qweasd&quot;, &quot;age&quot;=&gt;16, ],[&quot;id&quot;=&gt;16]); // 修改数据 $_POST[&apos;name&apos;]=&quot;yzmedu55&quot;; $_POST[&apos;pass&apos;]=&quot;pass55&quot;; $_POST[&apos;age&apos;]=&quot;55&quot;; $_POST[&apos;sex&apos;]=&quot;nan&quot;; $_POST[&apos;id&apos;]=17; $user=new User; $res=$user-&gt;allowField([&apos;name&apos;,&apos;pass&apos;,&apos;age&apos;])-&gt;save($_POST,[&apos;id&apos;=&gt;17]); // 批量更新 $data=[ [&apos;id&apos;=&gt;15,&apos;name&apos;=&gt;&quot;abc&quot;,&apos;pass&apos;=&gt;456], [&apos;id&apos;=&gt;17,&apos;name&apos;=&gt;&quot;abc&quot;,&apos;pass&apos;=&gt;456], ]; $user=new User; $res=$user-&gt;saveAll($data); echo User::getLastSql(); // 更新操作 $user=new User; $res=$user-&gt;where(&quot;id&quot;,&apos;&gt;&apos;,&apos;17&apos;)-&gt;update([&apos;age&apos;=&gt;18]); $res=User::where(&quot;id&quot;,&quot;&lt;&quot;,&quot;18&quot;)-&gt;update([&apos;pass&apos;=&gt;&apos;zxc&apos;]); // 闭包更新数据 $user=new User; $res=$user-&gt;save([&apos;name&apos;=&gt;&apos;yunzhimeng&apos;],function($query)&#123; $query-&gt;where(&quot;id&quot;,&quot;15&quot;); &#125;); 聚合1234567891011121314151617181920212223// 统计数据条数$tot=User::count();dump($tot);// 条件判断$tot=User::where(&quot;age&quot;,&quot;&gt;&quot;,18)-&gt;count();dump($tot);// 统计最大值$max=User::max(&apos;age&apos;);dump($max);// 统计最小值$min=User::min(&quot;age&quot;);dump($min);// 平均值$avg=User::avg(&apos;age&apos;);dump($avg);// 求和$sum=User::sum(&apos;age&apos;);dump($sum); 获取器 数据模型 1234567891011121314151617// sex 的获取器public function getSexAttr($val) &#123; $status = [ &apos;0&apos; =&gt; &apos;男&apos;, &apos;1&apos; =&gt; &apos;女&apos; ]; return $status[$val];&#125;// status 获取器public function getStatusAttr($value) &#123; $status = [ &apos;0&apos; =&gt; &apos;禁用&apos;, &apos;1&apos; =&gt; &apos;正常&apos; ]; return $status[$value];&#125; 控制器 123456$user = User::all();foreach ($user as $key =&gt; $value) &#123; dump($value-&gt;toArray()); dump($value-&gt;sex); // 经过获取器的操作 dump($value-&gt;getData()); // 不经过获取器的操作&#125; 注意 字段为user_status 修改器名字为getUserStatusAttr 字段为status 修改器名字为getStatusAttr 修改器 数据模型 1234// 密码 修改器public function setPassAttr($value) &#123; return md5($value);&#125; 控制器 12345// 修改器public function setPass() &#123; $user = new User(); $res = $user-&gt;save([&apos;pass&apos;=&gt;&apos;123&apos;], [&apos;id&apos;=&gt;&apos;1&apos;]);&#125; 注意 修改器的触发条件是 save 方法 自动完成 修改器与自动完成的区别 修改器：数据赋值时自动进行转换处理 自动完成：没有手动赋值的情况下手动进行处理 自动完成123456789101112131415// 设置自动完成 无论更新操作和添加操作都会执行// protected $auto = [&apos;time&apos;, &apos;sex&apos;];protected $auto = [];protected $insert = [&apos;create_time&apos;];protected $update = [&apos;update_time&apos;];// 书写自动完成protected function setSexAttr() &#123; return 1;&#125;protected function setCreateTimeAttr() &#123; return time();&#125;protected function setUpdateTimeAttr() &#123; return time();&#125; 时间戳 系统支持自动写入创建和更新的时间戳字段 配置文件中设置 12// 自动写入时间戳字段&apos;auto_timestamp&apos; =&gt; true, 数据模型中设置 12// 设置自动写入时间戳protected $autoWriteTimestamp=true; 可以设置字段默认值 1234// 增加时间的字段protected $createTime=&apos;create_times&apos;;// 更新时间的字段protected $updateTime=&apos;update_times&apos;; 取消更新时间戳设置 1protected $updateTime=false; 视图和模板视图加载页面 继承系统控制器类param1（字符串）：模板渲染param2（数组）：模板赋值param3（数组）：模板替换param4（数组）： 1return $this-&gt;fetch(param1, 2, 3, 4); 使用助手函数：param与fetch相同 1return view(); 使用View类（不建议） 12$view = new View();return $view-&gt;fetch(); 模板赋值 控制器类中的assign方法 123$this-&gt;assign(&apos;name&apos;, $name);$this-&gt;assign(&apos;city&apos;, $city);return view(); // 加载页面 通过fetch方法 1return $this-&gt;fetch(&apos;&apos;, [&apos;name&apos;=&gt;$name, &apos;city&apos;=&gt;$city]); 助手函数 1return view(&apos;&apos;, [&apos;name&apos;=&gt;$name, &apos;city&apos;=&gt;$city]); 对象赋值 123$this-&gt;view-&gt;name = &quot;zgg&quot;;$this-&gt;view-&gt;city = &quot;ganzhou&quot;;return view(); 模板替换 配置文件更改（全局替换） 12345// 视图输出字符串内容替换&apos;view_replace_str&apos; =&gt; [ &apos;__HOMES__&apos;=&gt;&apos;/static/home/public&apos;, &apos;__ADMINS__&apos;=&gt;&apos;/static/admin/public&apos;,], 部分替换 fetch 方法 1return $this-&gt;fetch(&apos;&apos;, [], [&apos;__HOMES__&apos;=&gt;&apos;/static/home/public&apos;]); view 函数 1return view(&apos;&apos;, [], [&apos;__HOMES__&apos;=&gt;&apos;/static/home/public&apos;]); 模板渲染 12345678// 默认加载当前模块 当前控制器 当前方法对应的页面 return $this-&gt;fetch(); // 加载当前模块 当前控制器下的 用户定义页面 return $this-&gt;fetch(&apos;jiazai&apos;); // 加载当前模块 User控制器 jiazai页面 return $this-&gt;fetch(&apos;User/jiazai&apos;); 模板模板标签 普通标签 1234// 模板引擎普通标签开始标记&apos;tpl_begin&apos; =&gt; &apos;&lt;&#123;&apos;,// 模板引擎普通标签结束标记&apos;tpl_end&apos; =&gt; &apos;&#125;&gt;&apos;, 1&lt;h2&gt;&#123;$str&#125;&lt;/h2&gt; 标签库标签 1234// 标签库标签开始标记&apos;taglib_begin&apos; =&gt; &apos;&#123;&apos;,// 标签库标签结束标记&apos;taglib_end&apos; =&gt; &apos;&#125;&apos;, 123&#123;for start=&quot;1&quot; end=&quot;10&quot;&#125; &#123;$i&#125;&#123;/for&#125; 变量输出 字符串 12// 分配字符串$this-&gt;assign(&quot;str&quot;, &quot;TP5.0&quot;); 数组 123456// 分配数组$data = [ &quot;name&quot; =&gt; &quot;zgg&quot;, &quot;age&quot; =&gt; 19,];$this-&gt;assign(&quot;data&quot;, $data); 使用函数 竖线 12345678&lt;h2&gt;&#123;$pass|md5&#125;&lt;/h2&gt;&lt;!-- &lt;h2&gt;&lt;?php echo md5($pass); ?&gt;&lt;/h2&gt; --&gt;&lt;h2&gt;&#123;$time|date=&quot;Y-m-d H:i:s&quot;,###&#125;&lt;/h2&gt;&lt;!-- &lt;?php echo date(&quot;Y-m-d H:i:s&quot;,$time);?&gt; --&gt;&lt;h2&gt;&#123;$pass|md5|strtoupper|substr=0,10&#125;&lt;/h2&gt;&lt;!-- &lt;h2&gt;&lt;?php echo substr(strtoupper(md5($pass)),0,10); ?&gt;&lt;/h2&gt; --&gt; 冒号开始 12&lt;h2&gt;&#123;:md5($pass)&#125;&lt;/h2&gt;&lt;h2&gt;&#123;:date(&apos;Y-m-d H:i:s&apos;,$time)&#125;&lt;/h2&gt; 默认值 12&lt;h2&gt;&#123;$name|default=&quot;小云&quot;&#125;&lt;/h2&gt;&lt;h2&gt;&lt;?php echo (isset($name) &amp;&amp; ($name !== &apos;&apos;)?$name:&quot;小云&quot;); ?&gt;&lt;/h2&gt; 三元运算符 123&lt;h2&gt;&#123;$status?&apos;正常&apos;:&apos;错误&apos;&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$status&gt;2?&apos;正常&apos;:&apos;错误&apos;&#125;&lt;/h2&gt;&lt;h2&gt;&lt;?php echo !empty($status) &amp;&amp; $status&gt;2?&apos;正常&apos;:&apos;错误&apos;; ?&gt;&lt;/h2&gt; 运算符 1234567&lt;h2&gt;&#123;$a&#125;+&#123;$b&#125;=&#123;$a+$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a&#125;-&#123;$b&#125;=&#123;$a-$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a&#125;*&#123;$b&#125;=&#123;$a*$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a&#125;/&#123;$b&#125;=&#123;$a/$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a&#125;%&#123;$b&#125;=&#123;$a%$b&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$a++&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$b--&#125;&lt;/h2&gt; 原样输出 123&#123;literal&#125; &lt;h2&gt;hello &#123;$name&#125;&lt;/h2&gt;&#123;/literal&#125; 系统变量 系统变量：支持输出 $_SERVER、$_ENV、$_POST、$_GET、$_REQUEST、$_SESSION、$_COOKIE 1234&lt;h1&gt;&#123;$_GET[&apos;id&apos;]&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.get.id&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$_SERVER[&apos;HTTP_HOST&apos;]&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.SERVER.http_host&#125;&lt;/h1&gt; 常量输出：详见附录 123456&lt;h1&gt;&#123;$Think.const.app_path&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.app_path&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.ds&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.think_path&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.IS_WIN&#125;&lt;/h1&gt;&lt;h1&gt;&#123;$Think.THINK_VERSION&#125;&lt;/h1&gt; 配置文件输出：常看配置文件 12&lt;h2&gt;&#123;$Think.config.app_namespace&#125;&lt;/h2&gt;&lt;h2&gt;&#123;$Think.config.default_lang&#125;&lt;/h2&gt; 模板注释 12&lt;h1&gt;&#123;//$_GET[&apos;id&apos;]&#125;&lt;/h1&gt;&lt;h1&gt;&#123;/*$Think.get.id*/&#125;&lt;/h1&gt; 包含文件 12&#123;include file=&quot;Public/header&quot;&#125;&#123;include file=&quot;Public/footer,Public/footer&quot;&#125; 模板布局 视图目录下新建 layout.html layout.html 页面中将所有的公共部分保留，非公共部分使用 {__CONTENT__} 替代 {__CONTENT__} 只能存在一个 页面中如何书写123456789101112# 引入模板布局&#123;layout name=&quot;layout&quot;/&#125;# 非公共区域内容&lt;!-- 内容 --&gt;&lt;div class=&quot;col-md-10&quot;&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;img src=&quot;__ADMINS__/img/4.jpg&quot;height=&quot;310px&quot; width=&quot;100%&quot;alt=&quot;&quot;&gt; &lt;h2&gt;联想 后台管理系统&lt;/h2&gt; &lt;p&gt;开发者 ： 赵丰泰&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 模板继承 视图目录下新建 base.html base.html 中对页面进行分割 1234567&lt;div class=&quot;container&quot;&gt; &#123;block name=&quot;nav&quot;&#125;&#123;/block&#125; &lt;div class=&quot;row body&quot;&gt; &#123;block name=&quot;menu&quot;&#125;&#123;/block&#125; &#123;block name=&quot;main&quot;&#125;&#123;/block&#125; &lt;/div&gt;&lt;/div&gt; 使用继承 123456789101112&#123;extend name=&quot;base&quot; /&#125;&#123;block name=&quot;nav&quot;&#125; &#123;include file=&quot;public/nav&quot; /&#125;&#123;/block&#125;&#123;block name=&quot;main&quot;&#125; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h2&gt;联想 后台管理系统&lt;/h2&gt; &lt;p&gt;开发者 ： 赵丰泰&lt;/p&gt; &lt;/div&gt;&#123;/block&#125; 内置标签 volist 循环 name：需要遍历的数据 id：类似 foreach 中 value offset：截取数据的起始位置 length：截取数据的个数 mod：奇偶数 empty：数据为空的使用 key：编号 foreach 循环 name：需要遍历的数据 item：类似 foreach 中 value key：类似 foreach 中 key123&#123;foreach name=&quot;data&quot; item=&quot;val&quot; key=&quot;abc&quot;&#125; &lt;p&gt; &#123;$abc&#125; &#123;$val.id&#125; &#123;$val.name&#125;&lt;/p&gt;&#123;/foreach&#125; for 循环 start：开始值 end：结束值 comparison：比较条件 step：步数 name：循环变量名 默认 i1234567&#123;for start=&quot;0&quot; end=&quot;10&quot; comparison=&quot;elt&quot; step=&quot;2&quot; name=&quot;abc&quot;&#125; &lt;p&gt;&#123;$abc&#125;&lt;/p&gt;&#123;/for&#125;&#123;for start=&quot;10&quot; end=&quot;0&quot; comparison=&quot;gt&quot; step=&quot;-1&quot;&#125; &lt;p&gt;&#123;$i&#125;&lt;/p&gt;&#123;/for&#125; 比较标签 12345678&#123;eq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/eq&#125;&#123;neq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/neq&#125;&#123;lt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/lt&#125;&#123;gt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/gt&#125;&#123;egt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/egt&#125;&#123;elt name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/elt&#125;&#123;heq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/heq&#125;&#123;nheq name=&quot;a&quot; value=&quot;11&quot;&#125;正确&#123;/nheq&#125; if 12345&#123;if condition=&quot;$a eq $b&quot;&#125; &lt;p&gt;a和b数值相等&lt;/p&gt;&#123;else /&#125; &lt;p&gt;a和b数值不相等&lt;/p&gt;&#123;/if&#125; switch 12345&#123;switch name=&quot;week&quot;&#125; &#123;case value=&apos;1&apos;&#125;周一&#123;/case&#125; &#123;case value=&apos;2&apos;&#125;周二&#123;/case&#125; &#123;default /&#125; 周日&#123;/switch&#125; in 和 notin 12345&#123;in name=&quot;week&quot; value=&quot;0,1,2,3,4,5,6&quot;&#125; 合法的数据&#123;else /&#125; 不合法数据&#123;/in&#125; between 和 notbetween 12345&#123;between name=&quot;week&quot; value=&quot;0,6&quot;&#125; 合法数据&#123;else/&#125; 非法数据&#123;/between&#125; 原生PHP 123456&#123;php&#125; echo &quot;123&quot;;&#123;/php&#125;&lt;?php echo &quot;456&quot;; ?&gt; Session与CookieSession 设置 Session 12Session::set(&apos;name&apos;, &apos;zgg&apos;);session(&apos;name&apos;, &apos;100&apos;); 获取 Session 12Session::get(&apos;name&apos;);session(&apos;name&apos;); // 返回 获取到的值 NULL 判断是否设置 12Session::has(&apos;name&apos;);session(&quot;?name&quot;); // 返回 true false 删除 Session 12Session::delete(&quot;data&quot;);session(&apos;name&apos;, null); // 无返回值 清空 Session 12Session::clear();session(null); Cookie 设置 Cookie 12Cookie::set(&apos;name&apos;, &apos;zgg&apos;, 3600);cookie(&apos;name&apos;, &apos;100&apos;, 3600); 获取 Cookie 12Cookie::get(&apos;name&apos;);cookie(&apos;name&apos;); // 返回 获取到的值 NULL 判断是否设置 12Cookie::has(&apos;name&apos;);cookie(&quot;?name&quot;); // 返回 true false 删除 Cookie 12Cookie::delete(&quot;data&quot;);cookie(&apos;name&apos;, null); // 无返回值 清空 Cookie 12Cookie::clear();cookie(null); 验证器控制器中使用验证器// 实例化验证器类 $validate=new Validate( [ &quot;username&quot;=&gt;&quot;require|length:6,12&quot;, &quot;password&quot;=&gt;&quot;require|confirm:repassword&quot; ], [ &quot;username.require&quot;=&gt;&apos;用户名不存在&apos;, &quot;username.length&quot;=&gt;&apos;用户名长度不满足&apos;, &quot;password.require&quot;=&gt;&apos;密码不存在&apos;, &quot;password.confirm&quot;=&gt;&apos;两次密码不一致&apos;, ] ); // 接收用户提交的数据 $data=input(&quot;post.&quot;); // 进行验证 if ($validate-&gt;check($data)) { }else{ dump($validate-&gt;getError()); } 分页 控制器中书写： 12345$data = Db::table(&quot;user&quot;)-&gt;paginate(3);$data = Db::table(&quot;user&quot;)-&gt;paginate(3, true); // 简化版效果$this-&gt;assign(&quot;data&quot;, $data);return $this-&gt;fetch(); 页面中书写 12345678910&#123;volist name=&quot;data&quot; id=&quot;val&quot;&#125; &lt;tr&gt; &lt;td&gt;&#123;$val.id&#125;&lt;/td&gt; &lt;td&gt;&#123;$val.name&#125;&lt;/td&gt; &lt;td&gt;&#123;$val.pass&#125;&lt;/td&gt; &lt;/tr&gt; &#123;/volist&#125;&#123;$data-&gt;render()&#125;]]></content>
      <tags>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket实践]]></title>
    <url>%2F2018%2F02%2F02%2FWebSocket%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[做小程序项目的时候有实时通信的需求，这里就整理一下WebSocket的知识 关于WebSocket 前言：Web应用的信息交互过程一般是客户端通过浏览器发出一个请求，服务器端接收完请求后进行处理并且返回结果给客户端，然后客户端浏览器解析信息，这样的机制对于实时要求比较高的应用来说就有很大的受限了，因此需要有一种高效节能的双向通信机制来保证数据的实时传输，WebSocket应运而生 概念： MDN: WebSocket是一个可以创建和服务器间进行双向会话的高级技术，通过这个API你可以向服务器发送消息并接受基于事件驱动的响应，这样就不用向服务器轮询获取数据了 WebSocket有web TCP之称，顾名思义是用来通信的，作为HTML5中新增的一种通信协议，由TCP协议与编程API组成，可以在浏览器与服务器之间建立双向连接，以基于事件的方式，赋予浏览器原生的实时通信能力，从而扩展我们的web应用，提升应用性能与用户体验 为什么使用：在WebSocket出现之前有一些其它的实时通讯方案，比如轮询、长轮询、服务器发送事件 轮询(Polling)：客户端以一定的时间间隔向服务器发送请求，通过频繁请求的方式来保持客户端和服务器端的数据同步。通常采取setInterval或者setTimeout实现。问题：客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，这样很多请求就是没有必要的，浪费带宽，低效率 长轮询(Long Polling)：对定时轮询的改进和提高，当服务器端没有数据更新的时候，连接会保持一段时间周期直到数据或状态改变或者时间过期，以此减少无效的客户端与服务器间的交互。问题：如果服务端的数据变更非常频繁的话，与定时轮询比较起来没有本质上性能的提高 服务器发送事件(Server-Sent Event)：是HTML5规范的一个组成部分，可以实现服务器到客户端的单向数据通信，通过SSE，客户端可以自动获取数据更新，而不用重复发送HTTP请求。问题：只支持到服务器到客户端单向的事件推送，而且所有版本的IE都不支持SSE WebSocket：在流量与负载量增大的情况下，相比于传统的Ajax轮询方案有极大的性能优势，在开发方面也不算复杂，只需要实例化WebSocket创建连接，成功后就可以发送相应消息了 Node实现这里采用Node的ws库来实现简单的WebSocket服务器 服务器： 1234567891011121314var WebSocketServer = require(&quot;ws&quot;).Server;var wss = new WebSocketServer(&#123; port: 3001&#125;);wss.on(&quot;connection&quot;, function(ws) &#123; ws.on(&quot;message&quot;, function(msg) &#123; console.log(msg); ws.send(&quot;Nice to meet you!&quot;); &#125;); ws.on(&quot;close&quot;, function() &#123; console.log(&quot;Stop client&quot;); &#125;);&#125;); 小程序客户端： 1234567891011121314151617181920wx.connectSocket(&#123; url: &apos;服务器的链接:3001&apos;, data: &#123;&#125;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, method: &apos;GET&apos;, success: function() &#123; console.log(&quot;客户端连接成功&quot;); &#125;&#125;),wx.onSocketOpen(function() &#123; console.log(&quot;WebSocket连接已打开&quot;); wx.sendSocketMessage(&#123; data: &apos;Hello!&apos; &#125;);&#125;),wx.onSocketMessage(function(msg) &#123; console.log(&quot;接收到：&quot;+ msg);&#125;); 这里特别提一下wx.onSocketMessage()，因为它只接收字符串和二进制类型的数据，因此如果需要发送json格式的数据就需要转换一下，只要是支持WebSocket肯定支持原生window.JSON，所以可以直接使用JSON.parse()和JSON.stringify()来转换 这样一个双向通信的实例基本就完成了]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2018%2F01%2F22%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[浏览公众号时看到一篇介绍HTTP较全的文章，这里做一个摘录总结，后续学习会不断完善改进~ 简单介绍 HTTP协议：超文本传输协议，用于从万维网服务器传输超文本到本地浏览器的传送协议，是互联网上应用最为广泛的一种网络协议，所有www文件都必须遵守的这个标准 HTTP基于TCP/IP通信协议来传送数据（HTML文件、图片文件、查询结果等） HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。于1990年提出，不断地完善和扩展 HTTP协议以客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即Web服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息 HTTP协议版本 HTTP0.9是第一个版本，请求(Request)只有一行，比如：GET www.baidu.com HTTP1.0最早于1996年在网页中使用，只是使用一些较为简单的网页和网络请求上 HTTP1.1在1999年开始广泛应用于现在的各大浏览器网络请求中，同时它也是当前使用最为广泛的协议 HTTP1.1的升级部分 缓存处理：HTTP1.0主要使用header里的If-Modified-Since,Expires来作为缓存判断的标准，而HTTP1.1则引入了更多的缓存控制策略如Entity tag,If-Unmodified-Since,If-Match,If-None-Match等更多可供选择的缓存头来控制缓存策略 带宽优化及网络连接：HTTP1.0中存在浪费带宽的现象，比如客户端只是需要某个对象的一部分但 服务器却将整个对象传送过来了，并且不支持断点续传功能；HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206(Partial Content) ，这样就方便了开发者自有的选择以便于充分利用带宽和连接 错误通知的管理：HTTP1.1中新增了24个错误状态响应码，如409(Conflict) 表示请求的资源与资源的当前状态发生冲突，410(Gone)表示服务器上的某个资源被永久性的删除 Host头处理：HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的URL并没有传递主机名(hostname),但随着虚拟主机技术的发展，一台物理服务器上可以存在多个虚拟主机，并且共享一个IP地址；HTTP1.1的请求消息和响应消息都应支持Host头域，并且请求消息中如果没有Host头域就会报告400(Bad Request)错误 长连接：HTTP1.1支持长连接(PersistentConnection)和请求的流水线(Pipelining)处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中 默认开启Connection：Keep-alive,一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点 如何建立连接(三次握手)HTTP是基于TCP协议的，浏览器最快也要在第三次握手时才能捎带HTTP请求报文，真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动，三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号 第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包,此时服务器进入SYN_RECV状态 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕后，客户端和服务器进入ESTABLISHED(TCP连接成功)状态,完成三次握手 如何关闭连接(四次挥手) 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，另一方执行被动关闭 TCP连接的拆除需要发送四个包，客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作 客户端发送一个FIN，用来关闭客户端到服务器的数据传送 服务器收到这个FIN，发回一个ACK，确认序号为收到的序号+1，和SYN一样，一个FIN将占用一个序号 服务器关闭与客户端的连接，发送一个FIN给客户端 客户端发回ACK报文确认，并将确认序号设置为收到序号+1 浏览器阻塞 浏览器对于同一个域名，一般PC端浏览器针对单个域名的server同时建立6~8个连接，手机端的连接数则控制在4~6个(根据浏览器内核的不同可能会有所差异)，超过浏览器最大连接数限制，后续请求就会被阻塞 HTTP2前述概念 SPDYSPDY协议是Google提出的基于传输控制协议(TCP)的应用层协议，通过压缩、多路复用和优先级来缩短加载时间，是一种更快加速的内容传输协议，于2009年年中发布，Chrome、FireFox、Oprea已默认开启SPDY SPDY协议设定目标 页面加载时间降低50% 无需网站作者修改任何内容 最小化配置复杂度，无需变更网络基础设施注：为了降低50%的页面加载时间，SPDY引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层TCP连接 HTTP2：SPDY升级版 HTTP-WG在2012年初提议了HTTP2.0，并吸收SPDY的经验教训在此基础上制定官方标准 HTTP2的主要目标是改进传输性能，更有效地利用网络资源，实现低延迟和高吞吐量 HTTP2致力于突破上一代标准的性能限制，也是一个扩展，之所以要递增一个大版本，主要是因为改变了客户端与服务器之间交换数据的方式 HTTP2如何提高效率 二进制分帧：HTTP2.0所有帧都采用二进制编码 帧：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位 消息：指逻辑上的HTTP消息，比如请求、响应等，由一个或多个帧组成 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符 多路复用：允许通过单一的HTTP/2连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP2不再依赖多个TCP连接去实现多流并行。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错(乱序发送)，还可以分优先级，最后再在另一端把它们重新组合。HTTP2.0连接都是持久化的，而且客户端与服务器之间只需要一个连接(一个域名一个连接)即可 请求优先级： 将HTTP消息分解为很多个独立的帧后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个31比特的优先值：0表示最高优先级，2的-31次方表示最低优先级 服务器可以根据流的优先级，控制资源分配(CPU、内存、带宽)，而在响应数据准备好之后，优先将最高优先级的帧发送给客户端 HTTP2.0解决了所有低效的问题：浏览器可以在发现资源时立即分配请求，指定每个流的优先级，让服务器决定最优的响应次序，这样请求不用排队，既节省了时间也最大限度地利用了每个连接 header压缩：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2使用encoder来减少需要传输的header大小，通讯双方各自cache一份headerfields表，既避免了重复header的传输，又减小了需要传输的大小 服务端推送： 服务器可以对一个客户端请求发送多个响应并且服务器向客户端推送资源无需客户端明确地请求 HTTP2.0连接后，客户端与服务器交换SET-TINGS帧，借此可以限定双向并发的流的最大数量 所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认猜想 服务器必须遵循请求-响应的循环，只能借着对请求的响应推送资源 服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤 HTTP2的多路复用与HTTP1.1的长连接复用有什么区别 HTTP1.0一次请求-响应，建立一个连接，用完关闭，每一个请求都要建立一个连接 HTTP1.1Pipeling解决方式为：若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等情况，后续请求只能被阻塞，毫无办法，即线头阻塞 HTTP2多个请求可同时在一个连接上并行执行，某个请求任务耗时严重也不会影响到其它连接的正常执行 如何应用到自己的项目现有任何网站和应用，无需做任何修改都可以在HTTP2.0上跑起来，HTTP服务器必须运行HTTP2.0协议，但大部分用户都不会因此受影响，NGINX的话只要在配置文件中启动相应的协议就可以了]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建Web服务器]]></title>
    <url>%2F2018%2F01%2F18%2FCentos7%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[最近在虚拟机里装了centos7来配置lamp服务器，其中踩了好多好多……坑o(╥﹏╥)o，必须做个记录 centos7安装 这里就是网上下好iso镜像，然后一步步装好，建议初学者选GNONE桌面版方便操作 Apache、Mysql、PHP安装 Apacheapache软件包名称叫做httpdyum install httpd出现提示时一路 y+回车 就好 启动Apache并将其设置为开机启动 systemctl start httpd.service systemctl enable httpd.service 检查httpd服务状态： systemctl status httpd.service 看到绿色的active(running)表示httpd服务正在运行中，enabled 表示httpd服务已设为开机启动 这样HTTP协议就启动了，因为它要用到端口80，因此防火墙要放通80，这里直接就关掉它 systemctl stop firewalld.service 停止firewall systemctl disable firewalld.service 禁止开机启动 现在可以通过ip addr查询当前系统ip地址，在浏览器访问就可以看到apache页面 Tips: 这里可以将虚拟机内部ip配置为静态的，然后修改主机hosts文件对应别名如myserver之后即可通过http://myserver直接访问 PHPyum install php这里有需要的话可以进入/etc/php.ini做一些配置的修改测试Apache能不能正常调用php，在/var/www/html目录下新建一个输出phpinfo的文件vim /var/www/html/phpinfo.php使用浏览器打开可以看到php信息页则说明正常然后安装常用的扩展yum -y install php-mysql php-gd php-imap php-ldap php-mbstring php-odbc php-pear php-xml php-xmlrpc Mysql这里推荐安装MariaDB(从RHEL 7开始Red Hat公司推荐使用它替换Mysql)yum install mariadb-server mariadbsystemctl start mariadb 启动mariadbsystemctl enable mariadb 设置为开机启动 这里可以启动数据库守护进程 mysql_secure_installation 用来设置root密码，允许远程root登录等等 mysql -u root -p使用root账号登录mariadb show mysql切换到mysql GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION; 修改登录权限设置为允许远程登录 配置apache虚拟目录apache默认工程目录是在/var/www下的，而编辑该目录必须是root用户，因此我们有必要自定义一个目录，让apache也能识别vim /etc/httpd/conf/httpd.conf打开apache配置文件找到&lt;dir alias_module&gt;，在内部添加1234567示例：Alias /myweb &quot;/home/daybreak/www&quot;&lt;Directory &quot;/home/daybreak/www&quot;&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt; 这里我的自定义路径为/home/daybreak/www，对应别名是myweb，在浏览器输入http&quot;//myserver/myweb就能对真实目录/home/daybreak/www下文件进行访问 注意：这里直接访问后很可能会出现403forbidden的错误，解决方案如下 确保配置虚拟目录时设置了目录访问权限即Require all granted 到这里可能是网站目录的权限问题，apache要求目录具有执行权限，也就是x，所以要确保访问的目录树都具有这些权限，例如我的目录时/home/daybreak/www，则需要 1234chmod 755 /homechmod 755 /home/daybreakchmod 755 /home/daybreak/www或者直接 chmod 755 -R /home 如果依然是403，那就是selinux的问题，把目录进行一下selinux权限设置chcon -R -t httpd_sys_content_t /home 这样访问成功后就可以通过自定义的目录访问web文档]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步JavaScript请求]]></title>
    <url>%2F2017%2F12%2F29%2F%E5%BC%82%E6%AD%A5JavaScript%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[在Udacity上系统学了异步JavaScript请求的课程，这里结合之前自己的理解做一个总结~ Ajax与XHR在JavaSctipt中发出异步HTTP请求的步骤： 使用XMLHttpRequest构造函数创建XHR对象 使用.open()方法-设置HTTP方法和要获取的资源的URL 设置.onload()属性-将此属性设为成功获取数据后将运行的函数 设置.onerror()属性-将此属性设为出现错误后将运行的函数 使用.send()方法-发送请求 使用响应： 使用.responseText属性-存储异步请求响应的文本 XMLHttpRequest：简称XHR，它提供了向服务器发送请求和解析服务器响应流畅的接口，可以以异步方式从服务器获得更多的信息IE6及以下不能直接通过XHR对象实例化XMLHttpRequest，兼容性实现如下：1234567891011121314151617181920function createXHR() &#123; if(typeof XMLHttpRequest != &apos;undefined&apos;) &#123; return new XMLHttpRequest(); &#125; else if(typeof ActiveXObject != &apos;undefined&apos;) &#123; var versions = [ &apos;MSXML2.XMLHttp.6.0&apos;, &apos;MSXML2.XMLHttp.3.0&apos;, &apos;MSXML2.XMLHttp&apos; ]; for(var i = 0; i &lt; versions.length; i++) &#123; try&#123; return new ActiveXObject(versions[i]); &#125; catch(e) &#123; // 跳过 &#125; &#125; &#125; else &#123; throw new Error(&apos;你的浏览器不支持XHR对象！&apos;); &#125;&#125; GET与POST： Ajax使用时，GET的使用频率高于POST，了解一下HTTP头部信息，包含服务器返回的响应头信息和客户端发出去的请求头信息 GET请求： 最常用的请求类型，常用于向服务器查询某些信息，在.open()方法的第二个参数可以通过URL后的问号给服务器传递键值对数据，服务器接收到以后就会返回响应数据，用encodeURIComponent()进行编码处理解决特殊字符传参产生的问题POST请求： 多用于表单提交时，通过.send()方法向服务器提交数据，同时一般POST请求还需要用XHR来模仿表单提交xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); 性能上说POST请求比GET请求消耗更多，相同数据下，GET请求最多比POST快两倍 封装Ajax：1234567891011121314151617181920212223242526272829303132333435363738394041// 名值对编码function params(data) &#123; var arr = []; for(var i in data) &#123; arr.push(encodeURIComponent(i) + &apos;=&apos; + encodeURIComponent(data[i])); &#125; return arr.join(&apos;&amp;&apos;);&#125;function ajax(obj) &#123; var xhr = new createXHR(); obj.url = obj.url + &apos;?rand=&apos; + Math.random(); obj.data = params(obj.data); if(obj.method === &apos;get&apos;) &#123; obj.url = obj.url.indexOf(&apos;?&apos;) == -1 ? obj.url + &apos;?&apos; + obj.data : obj.url + &apos;&amp;&apos; + obj.data; &#125; if(obj.async === true) &#123; xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) callback(); &#125; &#125; xhr.open(obj.method, obj.url, obj.async); if(obj.method === &apos;post&apos;) &#123; xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;); xhr.send(obj.data); &#125; else &#123; xhr.send(); &#125; if(obj.async === false) callback(); function callback() &#123; if(xhr.status == 200) &#123; obj.success(xhr.responseText); &#125; else &#123; console.log(&apos;数据返回失败！状态代码：&apos; + xhr.status + &apos;，状态信息：&apos; + xhr.statusText); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Web性能优化]]></title>
    <url>%2F2017%2F12%2F02%2FWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在书上看到了关于Web性能优化方面的知识，这里先记录下来，方便以后加以实践~ Web性能优化分为服务器端和浏览器端两个方面： 压缩源码和图片► JavaScript文件源代码可以采用混淆压缩的方式► CSS文件源码可以进行普通压缩► JPG图片可以根据具体质量来压缩为50%-70%► PNG可以使用一些开源压缩软件来压缩，比如24色变成8色、去掉一些PNG格式信息等 选择合适的图片格式► 如果图片颜色数较多就使用JPG格式► 如果图片颜色数较少就使用PNG格式► 如果能够通过服务器端判断浏览器支持WebP，就使用WebP格式和SVG格式 合并静态资源► 包括CSS、JavaScript和小图片，减少HTTP请求 开启服务器端的Gzip压缩► 对于文本资源非常有效，对图片资源则没那么大的压缩比率 使用CDN► 或者一些公开库使用第三方提供的静态资源地址（比如jQuery、normalize、css）。一方面增加并发下载量，另一方面能够和其他网站共享缓存 延长静态资源缓存时间► 这样频繁访问网站的访客就可以更快地访问。但是这里要通过修改文件名的方式，确保资源更新的时候，用户会拉取到最新的内容 把CSS放在页面头部，JavaScript放在页面底部► 这样就不会阻塞页面渲染，让页面出现长时间的空白]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作]]></title>
    <url>%2F2017%2F11%2F30%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[随着做项目的深入，对Git的使用也越来越频繁，这里就做一个常用操作的总结，不断更新~ Git理念► 工作区（即本地文件）► 暂存区► 本地仓库► 远程仓库 使用Git项目的文件都是在上面四个地方传递 本地项目关联远程仓库远程库建好以后就可以运行这条命令关联到本地项目：git remote add origin your-remote-repository-url 如果是直接克隆远程仓库到本地的话：git clone your-remote-repository-url 可以运行以下命令查看结果： git remote -v 查看当前项目的远程库git branch -a 查看当前项目的所有分支 远程库同步到本地► 在提交更新以前都要先同步一下本地仓库1git pull 等同于 git fetch + git merge 如果需要放弃本地修改，强制覆盖本地版本的话（即保持与远程库一致）：123git fetch --allgit reset --hard origin/mastergit pull 提交本地更新到远程库git status 检查当前项目状态 然后对于未跟踪的文件执行以下命令： 123git add untrack-file-path 跟踪单个本地文件，提交到暂存区git commit -m &quot;your commit&quot; 将跟踪过的文件即在暂存区的文件提交到本地仓库git push 将本地仓库提交到远程库 提交到远程库常用的命令还有： git add . 跟踪本地所有未跟踪的文件git push -f 强制提交更新，覆盖远程库 — 慎用！！！ 版本回退► 将当前版本回退到已提交的版本历史中git reset --hard HEAD^ 一个^号代表回退一个版本 更多时候我们都会找到对应的版本号进行回退：首先 git log 显示最近到最远的提交日志如果只想显示版本号和评论信息的话可以加上 --pretty=oneline 参数现在就可以 git reset --hard version number 回退到对应的版本 这里还有一个常用命令：git reflog 显示你的每一次命令，对于自己命令的整理很有帮助 检查修改► 已修改，未暂存git diff ► 已暂存，未提交git diff --cached ► 已提交，未推送git diff master origin/master 撤销修改► 向commit中添加忘记的文件(即更新最近的commit) 编辑文件 保存文件 暂存文件 git commit --amend ► 还原commitgit revert &lt;SHA&gt; 撤销目标commit做出的更改，同时创建一个新的commit记录这一更改 ► 重置commitgit reset &lt;reference&gt; 清除commit 将HEAD和当前分支指针移到引用的commit 使用--hard选项清除commit 使用--sort选项将commit的更改移至暂存区 使用--mixed选项取消暂存已被commit的更改 ► 已修改，未暂存git checkout -- file-path ► 已暂存，未提交git reset HEAD file-path 先撤销暂存区的修改git checkout -- file-path 再撤销工作区的修改 PS: 以上两个步骤都可以用 git reset --hard 完成，一步到位将修改完全恢复到未修改的状态 ► 已提交，未推送git reset --hard origin/master 从远程库将代码取回 ► 已推送git reset --hard HEAD^ 先回退本地库的版本git push -f 再强制推送到远程库 分支与合并git branch ： 列出仓库中所有的分支名称 — 活跃分支旁会显示一个星号 创建新的分支 删除分支 — 无法删除当前所在的分支 git checkout 切换分支，可以创建新的分支，-b选项可以附加切换到该分支 git log --oneline --decorate 显示日志中的分支git log --oneline --decorate --graph --all 显示实际的所有分支 git merge &lt;other-branch&gt; 合并分支 发生合并时，git将： 查看将合并的分支 查看分支的历史记录并寻找两个分支的commit历史记录都有的单个commit 将单个分支上更改的代码行合并到一起 提交一个commit来记录合并操作 合并有以下两种类型： 快进合并-要合并的分支位于检出分支前面。检出分支的指针将向前移动，指向另一分支所指向的同一commit 普通类型的合并 两个完全不同的分支被合并 创建一个合并commit 合并冲突：当相同的行在要合并的不同分支上做出了更改时，就会出现合并冲突。解决： 找到并删掉存在合并冲突指示符的所有行 决定保留哪些行 保存文件 暂存文件 提交commit]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验参考]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[逐步补上之前的数据结构实验代码，之后也会不断完善，仅供参考(^▽^) 顺序表链表的创建输出及两种有序表的合并 对于顺序表和单链表定义不同的结构体，顺序表通过下标创建并输出链表为带头结点的单链表，使用尾插法创建并输出 从头开始遍历两个升序表，将更大的存入第三个表中，并将其标记后移对于单链表，需要使用头插法插入第三个单链表中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 顺序表的创建输出及两个升序表合并成一个升序顺序表*/#include&lt;stdio.h&gt;#include&lt;math.h&gt;typedef struct &#123; int a[100]; int len;&#125;list;void inputList(list *L) &#123; int x, i = 0; printf(&quot;输入一串数(以-1结束)：&quot;); while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123; L-&gt;a[i] = x; i++; &#125; L-&gt;len = i;&#125;void printList(list *L) &#123; printf(&quot;\n线性表为：&quot;); int i; for(i = 0; i &lt; L-&gt;len ; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125; printf(&quot;\n&quot;);&#125;void insertList(list *L, int x) &#123; int i; for(i = L-&gt;len-1; i &gt; 0 &amp;&amp; L-&gt;a[i] &gt; x; i--) &#123; L-&gt;a[i+1] = L-&gt;a[i]; &#125; L-&gt;a[i+1] = x; L-&gt;len++;&#125;void mergeDoubleUp(list *L1, list *L2, list *L3) &#123; int i = 0, j = 0, tail = 0; while(i &lt; L1-&gt;len &amp;&amp; j &lt; L2-&gt;len) &#123; if(L1-&gt;a[i] &lt; L2-&gt;a[j]) &#123; L3-&gt;a[tail] = L1-&gt;a[i]; i++; &#125; else &#123; L3-&gt;a[tail] = L2-&gt;a[j]; j++; &#125; tail++; &#125; while(i &lt; L1-&gt;len) &#123; L3-&gt;a[tail] = L1-&gt;a[i]; i++; tail++; &#125; while(j &lt; L2-&gt;len) &#123; L3-&gt;a[tail] = L2-&gt;a[j]; j++; tail++; &#125; L3-&gt;len = tail;&#125;int main() &#123; list L1, L2, L3; inputList(&amp;L1); inputList(&amp;L2); mergeDoubleUp(&amp;L1, &amp;L2, &amp;L3); printList(&amp;L3); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* 单链表的创建输出、两个升序链表合并为一个降序链表*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct k &#123; int data; struct k *next;&#125;node;void createList(node *h) &#123; node *p, *tail; tail = h; int x; printf(&quot;输入一串数(以-1结束)：&quot;); while(scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x != -1) &#123; p = (node *)malloc(sizeof(node)); p-&gt;data = x; p-&gt;next = NULL; tail-&gt;next = p; tail = p; &#125;&#125;void printList(node *h) &#123; node *p; for(p = h-&gt;next; p != NULL; p = p-&gt;next) &#123; printf(&quot;%d &quot;, p-&gt;data); &#125;&#125;void mergeDoubleDown(node *h1, node *h2, node *h3) &#123; node *i, *j, *head; i = h1-&gt;next; j = h2-&gt;next; while(i != NULL &amp;&amp; j != NULL) &#123; if(i-&gt;data &lt; j-&gt;data) &#123; head = i; i = i-&gt;next; &#125; else &#123; head = j; j = j-&gt;next; &#125; // 头插法建立h3链表 head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125; // 尾部处理 while(i != NULL) &#123; head = (node *)malloc(sizeof(node)); head-&gt;data = i-&gt;data; i = i-&gt;next; head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125; while(j != NULL) &#123; head = (node *)malloc(sizeof(node)); head-&gt;data = j-&gt;data; j = j-&gt;next; head-&gt;next = h3-&gt;next; h3-&gt;next = head; &#125;&#125;int main()&#123; node h1, h2, h3; h1.next = NULL; h2.next = NULL; h3.next = NULL; createList(&amp;h1); createList(&amp;h2); printf(&quot;\n链表1为&quot;);printList(&amp;h1); printf(&quot;\n链表2为&quot;);printList(&amp;h2); mergeDoubleDown(&amp;h1, &amp;h2, &amp;h3); printf(&quot;\n链表3为&quot;);printList(&amp;h3); return 0;&#125; 顺序表的排序及单链表求最值 通过两次循环，默认为升序，如果第一次循环出现降序则进入第二次循环，第二次循环若出现升序则说明无序 设置两个标记分别从两边遍历，左为奇数时左标记继续，右为偶数时右标记继续，直到左为偶数右为奇数时则交换 设置当前标记和前驱标记遍历整个单链表，并通过预设的最大标记指针和最大前驱标记指针不断比较，遍历完最大标记指针就指向最大值 123456789101112131415161718192021222324252627282930313233343536373839404142/* 判断顺序表是否有序、实现奇偶分开、实现选择排序算法*/int isSort(sort *L) &#123; // 返回-1说明无序，1则有序 int i, j; // 两次循环判断 for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123; if(L-&gt;a[i] &gt; L-&gt;a[j]) &#123; for(i = 0, j = 1; j &lt; L-&gt;len; i++, j++) &#123; if(L-&gt;a[i] &lt; L-&gt;a[j]) return -1; &#125; &#125; &#125; return 1;&#125;void divert(sort *L) &#123; int i = 0, j = L-&gt;len-1; while(i &lt; j) &#123; while(L-&gt;a[i] % 2 != 0) i++; while(L-&gt;a[j] % 2 == 0) j--; if(i &lt; j) &#123; int temp = L-&gt;a[i]; L-&gt;a[i] = L-&gt;a[j]; L-&gt;a[j] = temp; &#125; else break; &#125;&#125;void selectSort(sort *L) &#123; int i; for(i = 0; i &lt; L-&gt;len; i++) &#123; int min = i, j; for(j = i; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] &lt; L-&gt;a[min]) min = j; &#125; int temp = L-&gt;a[min]; L-&gt;a[min] = L-&gt;a[i]; L-&gt;a[i] = temp; &#125;&#125; 123456789101112131415161718/* 选出单链表的最大值并移至末尾*/void removeMax(node *h) &#123; node *pre, *p, *preMax, *max; preMax = h; max = preMax-&gt;next; pre = preMax-&gt;next; p = max-&gt;next; for(; p != NULL; p = p-&gt;next, pre = pre-&gt;next) &#123; if(p-&gt;data &gt; max-&gt;data) &#123; preMax = pre; max = p; &#125; &#125; preMax-&gt;next = max-&gt;next; pre-&gt;next = max; max-&gt;next = NULL;&#125; 带头指针型单链表及模式匹配算法 头指针型单链表创建时对于第一个输入单独造头结点，之后与带头结点型单链表相同 采用递归不断分解直到达最后一个结点输出 从头开始遍历文本串t，同时不断跟模式串p匹配直到成功或遍历结束匹配失败 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 创建输出头指针型单链表、合并两个升序头指针型单链表为降序、将单链表从尾至首输出*/node *createList() &#123; int x; node *h, *p, *tail; printf(&quot;输入一串数(以-1结束)：&quot;); /* 造头结点 */ scanf(&quot;%d&quot;, &amp;x); if(x == -1) return; h = (node *)malloc(sizeof(node)); h-&gt;data = x; h-&gt;next = NULL; tail = h; scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; p = (node *)malloc(sizeof(node)); p-&gt;data = x; p-&gt;next = NULL; tail-&gt;next = p; tail = p; scanf(&quot;%d&quot;, &amp;x); &#125; return h;&#125;void printList(node *h) &#123; printf(&quot;链表为：&quot;); node *p; for(p = h; p != NULL; p = p-&gt;next) &#123; printf(&quot;%d &quot;, p-&gt;data); &#125; printf(&quot;\n&quot;);&#125;node *mergeDoubleDown(node *h1, node *h2, node *h3) &#123; node *i, *j, *k; i = h1; j = h2; while(i != NULL &amp;&amp; j != NULL) &#123; if(i-&gt;data &lt; j-&gt;data) &#123; k = i; i = i-&gt;next; k-&gt;next = h3; h3 = k; &#125; else &#123; k = j; j = j-&gt;next; k-&gt;next = h3; h3 = k; &#125; &#125; // 尾部处理 while(i != NULL) &#123; k = i; i = i-&gt;next; k-&gt;next = h3; h3 = k; &#125; while(j != NULL) &#123; k = j; j = j-&gt;next; k-&gt;next = h3; h3 = k; &#125; return h3;&#125;void revPrintList(node *h) &#123; if(h-&gt;next != NULL) &#123; revPrintList(h-&gt;next); &#125; printf(&quot;%d &quot;, h-&gt;data);&#125; 12345678910111213141516171819202122232425262728/* 朴素的模式匹配算法*/void creStr(seqString *s) &#123; char x; int i = 0; while((x = getchar()) != &apos;\n&apos;) &#123; s-&gt;str[i] = x; i++; &#125; s-&gt;len = i;&#125;int simpleMatch(seqString t, seqString p) &#123; int i; for(i = 0; i &lt; t.len; i++) &#123; if(success(t, p, i)) return i; &#125; return -1;&#125;int success(seqString t, seqString p, int i) &#123; int j; for(j = 0; j &lt; p.len; j++) &#123; if(t.str[i+j] != p.str[j]) return 0; &#125; return 1;&#125; 稀疏矩阵的转置与递归程序设计 首先将行列数与非零元数存入第一个三元组，再根据输入将非零元存入对应位置快速转置时需要一遍扫描填入非零元所在的新位置数组，之后一步转置 递归时传入空格的个数作为参数，将空格作为数字 递归分解整体成第一个和其余个数为两部分进行比较返回比较结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* 稀疏矩阵的创建输出、朴素转置与快速转置*/typedef struct &#123; int r, c, e;&#125;SYZ; void inputMatrix(SYZ ma[]) &#123; int i = 0, m = 0, n = 0, r = 0, c = 0, e = 0; printf(&quot;输入行数和列数(m n)：&quot;); scanf(&quot;%d %d&quot;, &amp;m, &amp;n); ma[0].r = m; ma[0].c = n; printf(&quot;\n输入三元组(格式如3 4 5), 以回车分隔, 输入0 0 0结束：\n&quot;); scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e); while(r != 0) &#123; i++; ma[i].r = r; ma[i].c = c; ma[i].e = e; scanf(&quot;%d %d %d&quot;, &amp;r, &amp;c, &amp;e); &#125; ma[0].e = i;&#125;void printMatrix(SYZ m[]) &#123; int i, j; int k = 1; printf(&quot;\n矩阵为：\n&quot;); for(i = 1; i &lt;= m[0].r; i++) &#123; for(j = 1; j &lt;= m[0].c; j++) &#123; if(k &lt;= m[0].e &amp;&amp; m[k].r == i &amp;&amp; m[k].c == j) &#123; printf(&quot; %d &quot;, m[k].e); k++; &#125; else printf(&quot; 0 &quot;); &#125; printf(&quot;\n&quot;); &#125;&#125;void generalTrans(SYZ ma[], SYZ mb[]) &#123; if(ma[0].e == 0) return; // 行列维数互换 mb[0].r = ma[0].c; mb[0].c = ma[0].r; mb[0].e = ma[0].e; // 扫描ma三元组,依次加到mb中 int k, col, e; for(k = 1, col = 1; col &lt;= ma[0].c; col++) &#123; for(e = 1; e &lt;= ma[0].e; e++) &#123; if(ma[e].c == col) &#123; mb[k].r = ma[e].c; mb[k].c = ma[e].r; mb[k].e = ma[e].e; k++; &#125; &#125; &#125;&#125;void fillNum(SYZ m[], int num[]) &#123; // 计算不同元素的个数, 存入num[] int i, k; for(i = 0; i &lt;= m[0].c; i++) num[i] = 0; for(i = 0; i &lt;= m[0].e; i++) &#123; k = m[i].c; num[k]++; &#125;&#125;void fillPos(int num[], int pos[], int len) &#123; pos[1] = 1; int k; // 从2到原列数 for(k = 2; k &lt;= len; k++) pos[k] = pos[k-1]+ num[k-1];&#125;void quickTrans(SYZ ma[], SYZ mb[]) &#123; // 一遍扫描，获取num[]和pos[] int num[20], pos[20]; fillNum(ma, num); fillPos(num, pos, ma[0].c); // 一步转置 int i, k, c; mb[0].r = ma[0].c; mb[0].c = mb[0].r; mb[0].e = mb[0].e; for(i = 1; i &lt;= ma[0].e; i++) &#123; c = ma[i].c; k = pos[c]; mb[k].r = ma[i].c; mb[k].c = ma[i].r; mb[k].e = ma[i].e; pos[c]++; &#125;&#125; 123456789101112131415/* 递归打印数字金字塔*/void printTriangle(int j, int n) &#123; if(n &lt;= 0) return; printTriangle(j+1, n-1); // 打印第n行 int i; printf(&quot;\n&quot;); for(i = 0; i &lt; j; i++) printf(&quot; &quot;); for(i = 1; i &lt;= n; i++) printf(&quot;%3d&quot;, i); for(i = n-1; i &gt;0; i--) printf(&quot;%3d&quot;, i);&#125; 1234567891011121314151617/* 递归查找顺序表元素下标、最大值下标*/int find(List L, int i, int j, int x) &#123; if(i &gt; j) return -1; if(L.arr[i] == x) return i; else return find(L, i+1, j, x);&#125;int findMax(List L, int i, int j) &#123; if(i &gt; j) return -1; if(i == j) return i; int k = findMax(L, i+1, j); if(L.arr[i] &gt; L.arr[k]) return i; else return k;&#125; 创建二叉树及前中后序遍历输出 输入字母，#代表NULL，然后先建左子树，再建右子树 前序递归先输出根的值再遍历左子树，最后遍历右子树；中序递归先遍历左子树，再输出根值，再遍历右子树；后序递归先遍历左、右子树，再输出根值 前序非递归需要先输出根值，然后保存回溯点，再进入左子树，到底后根据回溯点进入右子树；而后序非递归需要先保存回溯点，进入左子树，然后再输出回溯点值，进入右子树 1234567891011121314151617181920/* 创建二叉树*/typedef struct k&#123; char data; struct k *L, *R;&#125;bTree;bTree *creaTree() &#123; bTree *t; char c = getchar(); if(c == &apos;#&apos;) return NULL; t = malloc(sizeof(bTree)); t-&gt;data = c; t-&gt;L = creaTree(); t-&gt;R = creaTree(); return t;&#125; 12345678910111213141516171819202122/* 前中后序递归算法*/void preTraverse(bTree *t) &#123; if(t == NULL) return; printf(&quot;%c &quot;, t-&gt;data); preTraverse(t-&gt;L); preTraverse(t-&gt;R);&#125;void midTraverse(bTree *t) &#123; if(t == NULL) return; midTraverse(t-&gt;L); printf(&quot;%c &quot;, t-&gt;data); midTraverse(t-&gt;R);&#125;void postTraverse(bTree *t) &#123; if(t == NULL) return; postTraverse(t-&gt;L); postTraverse(t-&gt;R); printf(&quot;%c &quot;, t-&gt;data);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 前序、中序非递归算法*/typedef struct &#123; bTree *a[Max]; int top;&#125;Stack;void initStack(Stack *S) &#123; S-&gt;top = 0; &#125;void push(Stack *S, bTree *t) &#123; if(t == NULL || S-&gt;top == Max-1) return; S-&gt;a[S-&gt;top] = t; S-&gt;top++;&#125;bTree *pop(Stack *S) &#123; bTree *t; if(S-&gt;top == 0) return NULL; S-&gt;top--; t = S-&gt;a[S-&gt;top]; return t;&#125;int empty(Stack *S) &#123; if(S-&gt;top == 0) return 1; return 0;&#125;void preDisplay(bTree *t) &#123; Stack S; initStack(&amp;S); while(t != NULL || !empty(&amp;S)) &#123; if(t != NULL) &#123; printf(&quot;%c &quot;, t-&gt;data); push(&amp;S, t); t = t-&gt;L; &#125; else &#123; t = pop(&amp;S); t = t-&gt;R; &#125; &#125;&#125;void midDisplay(bTree *t) &#123; Stack S; initStack(&amp;S); while(t != NULL || !empty(&amp;S)) &#123; if(t != NULL) &#123; push(&amp;S, t); t = t-&gt;L; &#125; else &#123; t = pop(&amp;S); printf(&quot;%c &quot;, t-&gt;data); t = t-&gt;R; &#125; &#125;&#125; 有向网络邻接表的创建及优先遍历 先初始化结点数和边数，再输入顶点信息初始化顶点表，最后输入两边结点和权值信息利用头插法将新边表结点逐个插入到顶点头部 出度直接找到对应顶点计算边表结点个数，入度需要通过遍历整个顶点表找到边表结点值为该值的结点计算个数 从任意结点开始深度优先遍历即访问对应顶点下的未访问过的邻接点，根据邻接点的值访问对应的顶点，直至为空；广度优先遍历类似于二叉树的层次遍历，利用队列操作，默认从0开始，没访问过则访问并将顶点入队，然后顶点出队并依次访问该顶点下的邻接点，邻接点未访问过则访问并入队，直至为空 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 创建有向网络邻接表*/typedef struct k1 &#123; int eData; // 边点下标 int weight; struct k1 *next;&#125;eNode; // 边表结点typedef struct k2 &#123; int vData; // 顶点下标 eNode *first; // 边表头指针&#125;vNode; // 顶点表结点typedef struct&#123; vNode adjList[Max]; int numV, numE;&#125;ALGraph;int visited[Max] = &#123;0&#125;; // 访问状态数组void creaALGraph(ALGraph *G) &#123; int i, j, vi, vj, weight; eNode *e; printf(&quot;请输入结点数n和边数e&lt;n,e&gt;：&quot;); scanf(&quot;&lt;%d,%d&gt;&quot;, &amp;G-&gt;numV, &amp;G-&gt;numE); // 建立顶点表 printf(&quot;请连续输入顶点信息&lt;V&gt;：\n&quot;); fflush(stdin); for(i = 0; i &lt; G-&gt;numV; i++) &#123; scanf(&quot;&lt;%d&gt;&quot;, &amp;(G-&gt;adjList[i].vData)); G-&gt;adjList[i].first = NULL; &#125; // 建立边表 printf(&quot;连续输入两边结点和权值&lt;vi,vj,weight&gt;：\n&quot;); fflush(stdin); for(j = 0; j &lt; G-&gt;numE; j++) &#123; scanf(&quot;&lt;%d,%d,%d&gt;&quot;, &amp;vi, &amp;vj, &amp;weight); e = (eNode *)malloc(sizeof(eNode)); e-&gt;eData = vj; e-&gt;weight = weight; e-&gt;next = G-&gt;adjList[vi].first; // 将新边表结点插入到顶点Vi头部 G-&gt;adjList[vi].first = e; // 头插法 &#125;&#125;void printALGraph(ALGraph *G) &#123; int i, j; eNode *p; for(i = 0; i &lt; G-&gt;numV; i++) &#123; printf(&quot;%3d-&gt;&quot;, G-&gt;adjList[i].vData); p = G-&gt;adjList[i].first; while(p) &#123; printf(&quot;%3d&quot;, p-&gt;eData); p = p-&gt;next; &#125; printf(&quot;\n&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132/* 输出指定结点的入度和出度*/int getInDegree(ALGraph *G, int n) &#123; int count = 0, i; eNode *e; for(i = 0; i &lt; G-&gt;numV; i++) &#123; if(G-&gt;adjList[i].vData != n) &#123; e = G-&gt;adjList[i].first; while(e != NULL) &#123; if(e-&gt;eData == n) count++; e = e-&gt;next; &#125; &#125; &#125; return count;&#125;int getOutDegree(ALGraph *G, int n) &#123; int count = 0, i; eNode *e; for(i = 0; i &lt; G-&gt;numV; i++) &#123; if(G-&gt;adjList[i].vData == n) &#123; e = G-&gt;adjList[i].first; while(e != NULL) &#123; count++; e = e-&gt;next; &#125; break; &#125; &#125; return count;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 输出深度优先遍历和广度优先遍历结果*/typedef struct &#123; int f, r; int a[Max];&#125;Queue;void DFS(ALGraph *G, int i) &#123; eNode *p; if(visited[i]) return; printf(&quot;%d &quot;, G-&gt;adjList[i].vData); visited[i] = 1; p = G-&gt;adjList[i].first; while(p) &#123; if(visited[p-&gt;eData] == 0) DFS(G, p-&gt;eData); p = p-&gt;next; &#125;&#125;void initQueue(Queue *Q) &#123; Q-&gt;f = 0; Q-&gt;r = 0; &#125;void inQueue(Queue *Q, int i) &#123; if((Q-&gt;r+1)%Max == Q-&gt;f) return; Q-&gt;a[Q-&gt;r] = i; Q-&gt;r = (Q-&gt;r+1)%Max;&#125;int outQueue(Queue *Q) &#123; int i; if(Q-&gt;f == Q-&gt;r) return; i = Q-&gt;a[Q-&gt;f]; Q-&gt;f = (Q-&gt;f+1)%Max; return i;&#125;int isEmpty(Queue *Q) &#123; if(Q-&gt;f == Q-&gt;r) return 1; return 0;&#125;void BFS(ALGraph *G) &#123; int i; eNode *p; Queue Q; for(i = 0; i &lt; G-&gt;numV; i++) visited[i] = 0; // 初始化访问状态 initQueue(&amp;Q); for(i = 0; i &lt; G-&gt;numV; i++) &#123; // 默认从0开始遍历 if(visited[i] == 0) &#123; visited[i] = 1; printf(&quot;%d &quot;, G-&gt;adjList[i].vData); // 没访问过则访问并将顶点入队 inQueue(&amp;Q, i); while(!isEmpty(&amp;Q)) &#123; int i = outQueue(&amp;Q); p = G-&gt;adjList[i].first; // 顶点出队, 依次访问该顶点下的邻接点 while(p) &#123; if(visited[p-&gt;eData] == 0) &#123; // 邻接点未访问过则访问并入队 visited[p-&gt;eData] = 1; printf(&quot;%d &quot;, G-&gt;adjList[p-&gt;eData].vData); inQueue(&amp;Q, p-&gt;eData); &#125; p = p-&gt;next; &#125; &#125; &#125; &#125;&#125; 二分查找与二叉排序树 递归的划分判断对应下标值与key的大小而调整递归对应区间返回结果，非递归的划分通过while循环判断调整区间返回相等时的下标值，基于x:y的划分只是公式特殊一些 二叉排序树的创建就是不断插入结点的过程，使用递归时需要注意真正插入到子树，删除结点需要分度数：0度结点直接删除，1度结点由孙代子，2度结点找到前驱交换值后再删除1度结点 分块索引表的前提是数据分块有序，以界限为下标，对应的key为块的最大值，从而可以通过索引表快速查找到值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 递归与非递归实现基于x:y的划分查找 */typedef struct &#123; int a[100]; int len;&#125;list;void inputList(list *L) &#123; int x, i = 0; printf(&quot;输入一串数(以-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; L-&gt;a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; L-&gt;len = i;&#125;void printList(list *L) &#123; printf(&quot;\n线性表为：&quot;); int i; for(i = 0; i &lt; L-&gt;len ; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125; printf(&quot;\n&quot;);&#125;int BinSearchCurison(list *L, int Low, int High, int key, int X, int Y) &#123; int m; if(Low &gt; High) return -1; m = Low + (High-Low)*X/(X+Y); // 按比例划分 if(L-&gt;a[m] == key) return m; if(L-&gt;a[m] &gt; key) return BinSearch(L, Low, m-1, key, X, Y); else return BinSearch(L, m+1, High, key, X, Y);&#125;int BinSearch(list *L, int Low, int High, int key, int X, int Y) &#123; int m; while(Low &lt;= High) &#123; m = Low + (High-Low)*X/(X+Y); if(L-&gt;a[m] == key) return m; else if(L-&gt;a[m] &gt; key) High = m-1; else Low = m+1; &#125; return -1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 创建二叉排序树并对其进行查找、插入和删除，使用中序遍历验证 */#define Max 100typedef struct k&#123; int data; struct k *L, *R;&#125;bTree;typedef struct &#123; bTree *a[Max]; int top;&#125;Stack;bTree *insertBSTree(bTree *t, int x) &#123; bTree *p; p = malloc(sizeof(bTree)); p-&gt;data = x; p-&gt;L = NULL; p-&gt;R = NULL; if(t == NULL) return p; if(x &lt;= t-&gt;data) t-&gt;L = insertBSTree(t-&gt;L, x); else t-&gt;R = insertBSTree(t-&gt;R, x); return t;&#125;bTree *creaTree() &#123; bTree *t; int x; t = NULL; scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; t = insertBSTree(t, x); scanf(&quot;%d&quot;, &amp;x); &#125; return t;&#125;void midTraverse(bTree *t) &#123; if(t == NULL) return; midTraverse(t-&gt;L); printf(&quot;%d &quot;, t-&gt;data); midTraverse(t-&gt;R);&#125;bTree *searchBST(bTree *t, int x) &#123; if(t == NULL) return NULL; if(x == t-&gt;data) return t; if(x &lt; t-&gt;data) return searchBST(t-&gt;L, x); else return searchBST(t-&gt;R, x);&#125;void FindBST(bTree **t, bTree **pre, bTree **p, int x) &#123; *pre = NULL; *p = *t; while((*p) != NULL) &#123; // 查找到对应的结点，p指向它，pre指向p的双亲 if((*p)-&gt;data == x) break; if(x &lt; (*p)-&gt;data) &#123; (*pre) = (*p); (*p) = (*p)-&gt;L; &#125; else &#123; (*pre) = (*p); (*p) = (*p)-&gt;R; &#125; &#125;&#125;void del_0(bTree **pre, bTree **p) &#123; if((*pre)-&gt;L == *p) (*pre)-&gt;L = NULL; else if((*pre)-&gt;R == *p) (*pre)-&gt;R = NULL; free(*p);&#125;void del_1(bTree **pre, bTree **p) &#123; if((*pre)-&gt;L == *p) &#123; // 判断p是左子树还是右子树 if((*p)-&gt;L != NULL) (*pre)-&gt;L = (*p)-&gt;L; else (*pre)-&gt;L = (*p)-&gt;R; &#125; else &#123; if((*p)-&gt;L != NULL) (*pre)-&gt;R = (*p)-&gt;L; else (*pre)-&gt;R = (*p)-&gt;R; &#125; free(*p);&#125;void del_2(bTree **p) &#123; // 前驱替换 bTree *preQ, *q; int temp; preQ = (*p); q = (*p)-&gt;L; while(q-&gt;R != NULL) &#123; preQ = q; q = q-&gt;R; &#125;; // 找到p的前驱q, q的双亲preQ temp = (*p)-&gt;data; // p、q值互换 (*p)-&gt;data = q-&gt;data; q-&gt;data = temp; if(preQ-&gt;L == q) &#123; // 删除1度结点q if(q-&gt;L != NULL) preQ-&gt;L = q-&gt;L; else preQ-&gt;L = q-&gt;R; &#125; else &#123; if(q-&gt;L != NULL) preQ-&gt;R = q-&gt;L; else preQ-&gt;R = q-&gt;R; &#125; free(q);&#125;bTree *delBST(bTree *t, int x) &#123; bTree *pre, *p; if(t == NULL) return NULL; FindBST(&amp;t, &amp;pre, &amp;p, x); // 删除0度结点 if(p-&gt;L == NULL &amp;&amp; p-&gt;R == NULL) del_0(&amp;pre, &amp;p); // 删除1度结点 else if((p-&gt;L == NULL) != (p-&gt;R == NULL)) del_1(&amp;pre, &amp;p); // 删除2度结点 else if(p-&gt;L != NULL &amp;&amp; p-&gt;R != NULL) del_2(&amp;p); return t;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 创建分块索引表，并进行查找 */#define M 30#define DIS 7typedef struct &#123; int a[M]; int len;&#125;List;typedef struct &#123; int addr; // 地址 int key; // 关键字&#125;sNode;typedef struct &#123; sNode s[M]; int len;&#125;sList;void creaList(List *L) &#123; int x, i = 0; printf(&quot;输入一串数(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; L-&gt;a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; L-&gt;len = i;&#125;void printList(List *L) &#123; int i; for(i = 0; i &lt; L-&gt;len; i++) &#123; printf(&quot;%d &quot;, L-&gt;a[i]); &#125;&#125;void creaSList(sList *S, List *L) &#123; int i, j, max, k = 0; for(i = 0; i &lt; L-&gt;len; i=i+DIS) &#123; max = L-&gt;a[i]; for(j = i; j &lt; i+DIS &amp;&amp; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] &gt; max) max = L-&gt;a[j]; &#125; S-&gt;s[k].addr = i; S-&gt;s[k].key = max; k++; &#125; S-&gt;len = k;&#125;void printSList(sList *S) &#123; int i; for(i = 0; i &lt; S-&gt;len; i++) &#123; printf(&quot;%d--%d &quot;, S-&gt;s[i].addr, S-&gt;s[i].key); &#125;&#125;int sListFind(sList *S, List *L, int x) &#123; int i, j; for(i = 0; i &lt; S-&gt;len; i++) &#123; if(S-&gt;s[i].key == x) return S-&gt;s[i].addr; else if(S-&gt;s[i].key &gt; x) &#123; // 进入顺序表 for(j = S-&gt;s[i].addr; j &lt; S-&gt;s[i].addr+DIS &amp;&amp; j &lt; L-&gt;len; j++) &#123; if(L-&gt;a[j] == x) return j; &#125; return -1; &#125; &#125; return -1;&#125; 常用排序算法 首先从最后一个双亲开始进行堆调整，然后将堆顶与堆的末尾位置（哨位）交换，之后去掉哨位，重复进行堆调整、交换过程直至排序完成，根据大根堆还是小根堆实现升序或降序排序 以最开始的元素x为基准，从最后一位开始设标志位，违反大小规则就交换头尾两边，将数据集分成左边小于x和右边大于x两个集合，重复这样的过程直至有序 从头至尾，归并所有相邻有序段，类似于两个升序表合并，利用辅助的数组保存归并结果，最终一趟归并完成所有归并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 堆排序 */#define M 30int initArray(int a[]) &#123; int x, i; i = 0; a[i] = -1; i++; printf(&quot;输入关键字(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; return i-1;&#125;int minChildPos(int a[], int i, int n) &#123; int k = i*2; if(k &gt; n) return -1; if(k+1 &gt; n || a[k] &lt; a[k+1]) return k; return k+1;&#125;void adjustHeap(int a[], int i, int n) &#123; int t, k; t = a[i]; k = minChildPos(a, i, n); while(k != -1 &amp;&amp; t &gt; a[k]) &#123; a[i] = a[k]; i = k; k = minChildPos(a, i, n); &#125; a[i] = t;&#125;void heapSort(int a[], int n) &#123; int t, i; // 第一次堆调整 for(i = n/2; i &gt;= 1; i--) &#123; adjustHeap(a, i, n); &#125; // 极值交换排序 for(i = n; i &gt; 1; i--) &#123; t = a[i]; a[i] = a[1]; a[1] = t; adjustHeap(a, 1, i-1); &#125;&#125; 1234567891011121314151617181920212223242526272829/* 快速排序 */#define M 30int initArray(int a[]) &#123; int x, i = 0; printf(&quot;输入关键字(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; return i-1;&#125;void quickSort(int a[], int L, int H) &#123; int i, j, t; i = L, j = H; t = a[i]; if(i &gt; j) return; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; a[j] &gt;= t) j--; if(i &lt; j) &#123; a[i] = a[j]; i++; &#125; while(i &lt; j &amp;&amp; a[i] &lt;= t) i++; if(i &lt; j) &#123; a[j] = a[i]; j--; &#125; &#125; a[i] = t; quickSort(a, L, j-1); quickSort(a, i+1, H);&#125; 123456789101112131415161718192021222324252627282930313233343536373839/* 归并排序 */#define M 30int initArray(int a[]) &#123; int x, i = 0; printf(&quot;输入关键字(-1结束)：&quot;); scanf(&quot;%d&quot;, &amp;x); while(x != -1) &#123; a[i] = x; i++; scanf(&quot;%d&quot;, &amp;x); &#125; return i-1;&#125;void mergeOne(int a[], int b[], int len, int staPos, int step) &#123; int i, j, k, endi, endj; i = staPos; j = i + step; k = i; if(j &gt;= len) &#123; for(j = i; j &lt; len; j++) b[j] = a[j]; return; &#125; endi = j-1; endj = (j+step-1&lt;len)?j+step-1:len-1; while(i &lt;= endi &amp;&amp; j &lt;= endj) &#123; if(a[i] &lt;= a[j]) &#123; b[k] = a[i]; i++; &#125; else &#123; b[k] = a[j]; j++; &#125; k++; &#125; while(i &lt;= endi) &#123; b[k] = a[i]; k++; i++; &#125; while(j &lt;= endj) &#123; b[k] = a[j]; k++; j++; &#125;&#125;void mergeAll(int a[], int b[], int len, int step) &#123; int i; for(i = 0; i &lt; len; i=i+2*step) mergeOne(a, b, len, i, step); for(i = 0; i &lt; len; i++) a[i] = b[i];&#125;void mergeSort(int a[], int b[], int len) &#123; int step; for(step = 1; step &lt; len; step=step*2) mergeAll(a, b, len, step);&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数防抖与函数节流]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[前言► 实际开发中以下场景往往由于事件频繁被触发，从而频繁执行DOM操作、资源加载等行为，导致页面卡顿甚至浏览器崩溃： window对象的 resize、scroll 事件 拖拽时的 mousemove 事件 射击游戏中的 mousedown、keydown 事件 文字输入、自动完成的 keyup 事件 ► 对于 window 的 resize 事件，实际需求一般是停止改变大小n毫秒后执行；而其它事件一般是以一定的频率执行。 ► 针对这两种需求就出现了 debounce (防抖) 和 throttle (节流) 两种解决办法 函数防抖► 如果用手一直按住一个弹簧，它将不会弹起直到你松手为止，也就是调用动作n毫秒后才会执行该动作，如果n毫秒内再次调用则重新计算执行时间 简单实现： debounce 方法接收两个参数，一个是需要防抖动的函数 fn ，另一个是延迟时间 delay 函数节流► 将水龙头拧到水以水滴的形式流出，每隔一段时间就有一滴水流出，也就是预先设定一个执行周期，调用动作的时刻不小于这个执行周期就执行它 简单实现：throttle 方法也是接收两个参数，一个是需要节流的函数 fn ，另一个是函数执行间隔阈值 threshhold 总结可以参考一下防抖和节流与正常触发的对比效果图： ► debounce 可以想象成把很多事件压缩成了一个事件，throttle 可以想象成像阀门一样定时打开调节流量 ► 简单来说，debounce 适合只执行一次的情况，比如 搜索框的自动完成：在停止输入后才提交一次ajax请求； throttle 适合每隔一定时间间隔内执行不超过一次的情况，比如 拖动滚动条、移动鼠标、滚轮事件的处理等]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6基础概念]]></title>
    <url>%2F2017%2F11%2F23%2FES6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[let命令基本用法► 用来声明变量，类似于 var，但只在 let 命令所在的代码块内有效 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceErrorb // 1 ► 使用 let ，声明的变量只在块级作用域内有效，因此 for 循环的计数器很适合用 let 命令 ► for 循环还有一个特别之处，设置循环变量的那部分是一个副作用域，而循环体内部是一个单独的子作用域 1234for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abs&apos;; console.log(i);&#125; 不存在变量提升► var 命令会有变量提升，也就是变量可以在声明之前使用，值为 undefined ► let 命令改变了这种语法行为，它所声明的变量一定要在声明后使用，否则就报错 暂时性死区► 只要块级作用域内存在 let 命令，它所声明的变量就绑定这个区域，不受外部的影响 123456var tmp = 123;if(true) &#123; tmp = &apos;abc&apos;; //ReferenceError let temp;&#125; ► 上述代码中虽然存在全局变量 tmp,但是块级作用域内 let 又声明了一个局部变量 tmp，导致后者绑定了这个块级作用域，所以在 let 声明变量之前，对 tmp 赋值都会报错 ► ES6 明确规定，区块中如果存在 let 和 const 命令，在语法上，这个区块就形成了”暂时性死区” ► 这也意味着 typeof 命令不再是一个百分百安全的操作，这样规定暂时性死区和 let、const 语句不出现变量提升，主要就是为了防止变量在声明前就使用它从而减少错误 不可重复声明► let 不允许在相同作用域内，重复声明同一个变量，也即不能在函数内部重新声明参数 123456789function func(arg) &#123; let arg; //执行会报错&#125;function func(arg) &#123; &#123; let arg; //不会报错 &#125;&#125; const命令基本用法► 用来声明一个只读的常量，一旦声明，值就不能改变，这也意味着，const 一旦声明变量就必须立即初始化，不能留到之后再赋值，其它与 let 命令类似 本质► const 实际保证的，不是变量的值不能改动，而是变量所指向的内存地址不能改动 12345678const foo = &#123;&#125;;//添加属性可以成功foo.prop = 123;foo.prop;//指向另一个对象就会报错foo = &#123;&#125;; 箭头函数基本用法► ES6 允许使用“箭头”（=&gt;）定义函数 123456var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;; ► 如果箭头函数不需要参数或者需要多个参数，就使用圆括号 1234567891011var f = () =&gt; 5;//等同于var f = function() &#123; return 5;&#125;;var sum = (num1,num2) =&gt; num1 + num2;//等同于var sum = function(num1,num2) &#123; return num1 + num2;&#125; ► 代码块多于一条语句的话就要用大括号括起来并且使用 return 语句返回 ► 由于大括号被解释为代码块，所以箭头函数返回的是一个对象的话，必须在对象外面加上括号 12345var getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot;&#125;);//等同于var getTempItem = function(id) &#123; return &#123; id: id, name: &quot;Temp&quot;&#125;;&#125;; ► 箭头函数使表达式更简洁12const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n; ► 其它用途… 使用注意点► 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象 ► 不可以当作构造函数，即不能使用 new 命令 ► 没有 arguments 对象，需要的话可以用 rest 参数代替 ► 不能使用 yield 命令，所以箭头函数不能用作 Generator 函数 尤其注意第一点，在箭头函数中 this 对象的指向是固定的 123456789function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;,100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); // id: 42 ► 上例中 setTimeout 的参数是一个箭头函数，它的定义生效在 foo 函数生成时，真正执行就要等到100ms后，如果是普通函数的话，执行时 this 应该指向全局对象 window ，即输出 21 ，但箭头函数导致this总是指向函数定义生效时所在的对象( {id: 42} )，所以输出 42 . ► this 指向的固定化，不是箭头函数内部有这样的机制，而是它没有自己的 this，所以它内部的 this 就是外层代码块的 this ,这也是它不能用作构造函数的原因 所以箭头函数转换成ES5的代码如下： 123456789101112function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id: &apos;,this.id); &#125;,100);&#125;function foo() &#123; var _this = this; setTimeout(function() &#123; console.log(&apos;id: &apos;,_this.id); &#125;,100);&#125; 对象和数组数组的解构赋值► ES6 允许按照一定模式，从数组和对象中提取值同时对变量进行赋值，这被称为 解构 1let [a,b,c] = [1,2,3]; 上面的代码中从数组中提取值并按照对应位置对变量赋值 本质上这种写法属于”模式匹配”, 只要等号两边的模式相同，左边的变量就会被赋予对应的值, 如果不完全解构即左边的模式只匹配一部分的右边的数组，解构也成功 一些例子：1234567891011121314151617/*完全解构*/let [ , , third] = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;];third // &apos;baz&apos;let [head, ...tail] = [1,2,3,4];head // 1tail // [2,3,4]/*不完全解构*/let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4]a // 1b // 2d // 4 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值 对象的解构赋值► 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名才能正确取到值 12345678910let &#123; bar, foo &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;foo // &quot;aa&quot;bar // &quot;cc&quot;let &#123; baz &#125; = &#123; foo: &quot;aa&quot;, bar: &quot;cc&quot; &#125;;baz // undefined/*变量名与属性名不一致的写法*/let &#123; foo: baz &#125; = &#123; foo: &apos;aa&apos;, bar: &apos;cc&apos; &#125;;baz // &quot;aa&quot; 变量名与属性名不一致的写法实际上说明，对象的解构赋值是下面形式的简写： 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aa&quot;, bar: &apos;cc&apos; &#125;; 即对象的解构赋值是先找到同名属性，再赋给对应的变量。真正被赋值的是后者而不是前者 ► 对象的解构赋值，可以很方便地将现有对象的方法赋值给对应的变量 1let &#123; log, sin, cos &#125; = Math; 解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象 用途12345/*交换变量的值*/let x = 1;let y = 2;[x, y] = [y, x] 12345678910111213141516/*从函数返回多个值*/// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();//返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 12345/*函数参数的定义*/// 参数是一组无次序的值时function f(&#123; x, y, z &#125;) &#123; ... &#125;f(&#123; z: 3, y: 5, x: 0 &#125;) 1234567/*提取JSON数据*/let jsonData = &#123; id: 42, data: [860, 504]&#125;;let &#123; id, data: number &#125; = jsonData; 123456789jQuery.ajax = function(url, &#123; async = true, beforeSend = function() &#123;&#125;, cache = true, complete = function() &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123;&#125;; 123/* 输入模块的指定方法 */const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础]]></title>
    <url>%2F2017%2F11%2F23%2FjQuery%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础核心代码风格‘$’： jQuery 当中最重要并且独有的对象：jQuery对象1234567$(function() &#123;&#125;); //执行一个匿名函数$(&apos;#box&apos;); //进行执行的ID元素选择$(&apos;#box&apos;).css(&apos;color&apos;,&apos;red&apos;); //执行功能函数/*等同于*/jQuery(function() &#123;&#125;);jQuery(&apos;#box&apos;); 执行功能函数时，先获取元素返回 jQuery 对象后再调用功能函数，同时返回的还是 jQuery 对象，所以可以连缀不停的调用功能函数 1$(&apos;#box&apos;).css(&apos;color&apos;,&apos;red&apos;).css(&apos;font-size&apos;,&apos;50px&apos;); 加载模式jQuery 等待加载： 1$(document).ready(function () &#123;&#125;); 它的执行时机只需等待网页中的DOM结构加载完毕就可以执行包裹的代码，并且可以执行多次不会覆盖 window.onload 需要等待图片之类的大型元素加载完毕后才能执行JS代码，在网速慢的情况下，图片还在缓慢加载时，页面上任何的JS交互功能都会处在假死状态，同时只能执行一次，会给实际开发带来困难 对象互换jQuery 对象是 jQuery 库独有的对象，通过JS封装而来，可以直接输出得到它的信息 只要使用代码包裹以后，最终返回的都是 jQuery 对象，好处就是可以连缀处理，如果需要返回原生的DOM对象的话，可以这么处理： 1$(&apos;#box&apos;).get(0); //ID元素的第一个原生DOM 从get(0)的索引看出， jQuery 可以批量处理DOM，在循环遍历上会更方便 多个库之间的冲突同一个项目中引入多个第三方库时，由于没有命名空间的约束，不同库之间很容易发生冲突 对于同样使用’$’作为基准起始符的库(如 Base 库)，想和 jQuery 共存的话有两种办法： 先引入 jQuery 库，这样’$’的所有权就归之后的库所有， jQuery 可以直接用jQuery对象调用，或者创建一个新符(‘$$’)给它用： 12345var $$ = jQuery;$(function () &#123; $(&apos;#box&apos;).get(0); // 都是Base的$ $$(&apos;#box&apos;).width(0); // jQuery的$$&#125;); 后引入 jQuery 库，’$’归 jQuery 库，jQuery 有一个方法可以放弃： 12345jQuery.noConflict(); // 将$符所有权剔除var $$ = jQuery;$(function () &#123; ... // $属于Bae, $$属于jQuery&#125;); 工具函数字符串操作12var str = &apos; sad&apos;;$.trim(str); //去除字符串左右空格 数组和对象操作12345678910/*$.each()遍历数组*/var arr = [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;];$.each(arr,function(index, value) &#123; $(&apos;#box&apos;).html($(&apos;#box&apos;).html + index + &apos;.&apos; + value + &apos;&lt;br&gt;&apos;);&#125;);/*遍历对象*/$.each($.ajax(), function(name, fn) &#123; $(&apos;#box&apos;).html($(&apos;#box&apos;).html() + name + &apos;.&apos; + &apos;&lt;br&gt;&lt;br&gt;&apos;);&#125;) 123456/*$.grep()数据筛选*/var arr = [5,3,5,7,45,98,23,10];$.grep(arr, function(element, index) &#123; return element &lt; 6 &amp;&amp; index &lt; 5;&#125;);/*index从0开始计算*/ 1234567/*$.map()修改数据*/var arr = [5,6,87,54,32,4,10];$.map(arr, function(element, index) &#123; if(element &lt; 6 &amp;&amp; index &lt; 5) &#123; return element + 1; &#125;&#125;); ► $.merge() 合并两个数组 ► $.unique() 删除重复的DOM元素 ► .toArray() 合并多个DOM元素组成数组 … 测试操作 URL操作123456/*$.param()将对象键值对转换为URL字符串键值对*/var obj = &#123; name : &apos;Lee&apos;, age : &apos;20&apos;&#125;;$.param(obj); 其它操作jQuery提供了一个预备绑定函数上下文的工具函数: $.proxy(),可以解决如外部事件触发调用对象方法时this的指向问题 12345678910111213141516171819/*$.proxy()调整this指向*/var obj = &#123; name : &apos;Lee&apos;, test: function() &#123; alert(this.name); &#125;&#125;$(&apos;#box&apos;).click(obj.test); //this指向为#box元素，undefined$(&apos;#box&apos;).click($.proxy(obj,&apos;test&apos;)); //this指向为对象box，Lee/*等效于*/var obj = &#123; name : &apos;Lee&apos;, test : function() &#123; var _this = obj; alert(_this.name); &#125;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象与原型]]></title>
    <url>%2F2017%2F11%2F23%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这里会先把之前已经写好的总结陆续放上来，主要也是有一个时间顺序记录自己的学习过程（(#^.^#)） 面向对象与原型一.创建对象：1.最基本的创建一个对象并添加属性和方法 缺点：每创建一个类似对象，都会产生大量代码 解决：工厂模式解决实例化对象产生大量重复代码，即设计一个实例化的函数 2.工厂模式： 新问题：无法区别实例的来源对象 解决：用构造函数来创建特定的对象 3.构造函数 重复实例化和对象识别的问题都得到解决 规范：1.函数名和实例化名相同并且首字母大写（有助于区分构造函数和普通函数） 2.必须用new运算符创建对象（与普通函数的区别） 与工厂模式的区别：1.构造函数没有显式地创建对象 2.直接把属性方法赋给this对象 3.没有return语句 小问题：在对run方法的引用上每次实例化的地址都不同，即alert(person1.run == person2.run)的结果是false 二.原型创建的每个函数都有一个prototype属性（对象）。包含可以由特定类型的所有实例共享的属性和方法 1.构造函数与原型模式的声明方式： 通过两种方式的对比可以明白为什么它们在对方法的引用地址上会有区别 2.原型模式的执行流程：构造函数实例里有属性或方法的话就返回，没有就去它的原型对象中找 对属性是在构造函数的实例里还是原型里的判断：hasOwnProperty()---&gt;实例有返回true in操作符 ---&gt;只要存在就返回true ---&gt;两种方法结合判断原型中是否存在属性 3.原型模式创建对象的缺点：共享—–如果某次实例化时改变了原型中的属性，则会影响到之后的实例化对象 —–如果有传入参数的话，之后的实例化对象属性会覆盖掉之前的，无法独立 即用相同原型创建的对象访问原型中的属性时，访问的都是同一个对象解决：构造函数+原型模式的组合模式： 构造函数适合封装属性 原型模式适合封装方法 组合模式： 解决了传参和共享的难题，进一步的优化是把构造函数和原型封装到一起 动态原型模式： 以上两种是JS创建对象时使用较多的方式，优先考虑动态原型模式 4.补充：寄生构造函数：工厂模式+构造函数模式 —&gt;需要创建一个具有额外方法的引用类型 稳妥构造函数： —&gt;构造函数中不用this,外部实例化函数时不用new 三.继承1.原型链正统面向对象语言实现继承的方式：接口实现和继承 ECMAScript只支持继承，实现的方式是依靠原型链 实质：通过原型让一个引用类型继承另一个引用类型的属性和方法 被继承的函数称为超类型（父类、基类）;继承的函数称为子类型（子类、派生类） 继承存在的问题： 字面量重写原型会中断关系 子类型无法给超类型传递参数 2.借用构造函数（对象冒充）—&gt;解决引用共享和不能给超类型传参的问题 新问题：没有原型，无法复用 3.组合继承（最常用）—&gt;通过原型链继承原型的属性方法 —&gt;通过借用构造函数继承实例的属性 —&gt;既实现了函数复用，又保证每个实例的独立性 4.原型式继承—&gt;借助原型并基于已有的对象创建新对象，不用再创建自定义类型 5.寄生式继承（原型式+工厂模式）—&gt;为了封装创建对象的过程 6.寄生组合式继承—&gt;处理组合式继承的问题：超类型在使用过程中被调用了两次： 创建子类型时 在子类型构造函数内部 通过原型链的混成形式调用方法，解决了两次调用的问题 总结：1.创建对象： 工厂模式：用简单的函数创建对象，添加属性方法然后返回它 构造函数模式：可以创建特定的对象，但是它的成员包括函数都不能复用 原型模式：利用函数的prototype属性来指定应该共享的方法和属性 组合模式：利用构造函数定义实例属性，利用原型定义共享方法 2.继承： 原型链继承：通过原型让一个引用类型继承另一个引用类型的属性和方法 借用构造函数（对象冒充）：解决引用共享和超类型不能传参的问题 组合继承：通过原型链继承原型的属性方法，通过借用构造函数继承实例的属性，最常用，但有多次调用超类型构造函数导致的低效率问题 原型式继承：在已有对象上借助原型创建新对象，新对象可以进一步添加属性方法 寄生式继承：封装了创建对象的过程，基于这个可以进一步增强对象 寄生组合式继承：通过原型链的混成形式调用方法，避免多次调用超类型构造函数，基于类型继承的最有效方式]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建你的博客]]></title>
    <url>%2F2017%2F11%2F23%2FHexo-blog%2F</url>
    <content type="text"><![CDATA[一开始自己用hexo搭博客的时候踩了比较多坑，在这里想总结一下做一个简单的搭建教程，后续使用再慢慢完善 初始配置环境 node 作用：生成静态页面 Git 作用：将本地的hexo内容提交到github上 申请Github 作用：作为博客的远程仓库和服务器 Hexo的安装及初始化环境配置好后，创建一个文件夹，进入后执行以下命令： npm install hexo-cli -g 安装hexo hexo init 初始化 npm install hexo generate 生成静态页面 hexo server 启动本地服务之后浏览器输入localhost:4000 就可以看到一个默认的hexo博客啦 Github上的配置进入Github新建一个仓库，这里特别要强调的是仓库名的格式必须为yourusername.github.io，yourusername就是你的Github用户名，这里错误的话，之后直接访问就会404（我就是这样o(╥﹏╥)o）,建好以后就clone一下HTTPS形式的url（这里先不用SSH） 本地Hexo文件的修改进入Hexo文件根目录下的_config.yml，打开以后拉到最下面的deploy那里，改成如下形式：1234deploy: type: git repo: https://github.com/fxbabys/fxbabys.github.io.git branch: master 这里也特别要强调的是冒号后面一定要加空格 然后执行命令安装: npm install hexo-deployer-git --save再执行配置命令: hexo deploy这样本地文件就上传到Github远程库上了，访问https://fxbabys.github.io/就行了 之后每次部署发布文章可以按下面的步骤进行： hexo new &quot;文章名称&quot; 这样会在source/_posts下生成一个md文档 hexo server(hexo s) 上传前本地先预览一下效果 hexo generate(hexo g) hexo deploy(hexo d) 到这里搭建一个hexo博客和发布新文章就完成啦！更个性化的设置可以自己去Hexo官方文档上查看，介绍的都很详细，也可以去网上找教程再多折腾一些自己的喜好（(^▽^)）]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome]]></title>
    <url>%2F2017%2F11%2F19%2Fwelcome%2F</url>
    <content type="text"><![CDATA[Welcome to my technology blog !This is the first blog I built myself and I will update my study and thinking life in it later.I hope it can also help others who read this blog，let’s step forward together！]]></content>
  </entry>
</search>
